# F3.1: Create Product Catalog Page

**Sprint:** 3
**Type:** Frontend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint3-F3.1-catalog-page
**Created:** 2026-02-16
**Dependencies:** F3.2 (ProductCard) ✅, F3.3 (ProductGrid) ✅, F3.4 (ProductFilters) ✅

---

## Description

Create the public product catalog page at `/products`. This page assembles the existing ProductGrid, ProductFilters, and ProductCard components into a fully functional catalog with server-side data fetching, URL-based filter state, and pagination.

The page must:
- Fetch products from `GET /products` with query params derived from URL searchParams
- Fetch product types from `GET /product-types` for the type filter dropdown
- Sync filter state bidirectionally with URL search params (ProductFilters → URL, URL → ProductFilters)
- Display paginated results with a new Pagination component
- Handle loading, error, and empty states gracefully

---

## Acceptance Criteria

- [x] Page renders at `/products` route
- [x] Products are fetched from `GET /products` with correct query params
- [x] Product types are fetched from `GET /product-types` for the type filter dropdown
- [x] ProductFilters component controls URL search params (search, typeSlug, minPrice, maxPrice, isHot, sort)
- [x] Changing filters updates the URL and triggers a new product fetch
- [x] URL params are read on initial load to restore filter state (deep-linkable)
- [x] Pagination component renders when totalPages > 1
- [x] Clicking a page number updates the URL `page` param and fetches that page
- [x] Changing filters resets page to 1
- [x] Loading state shows ProductGrid skeletons during fetch
- [x] Error state shows an alert with a retry option
- [x] Empty state (no products matching filters) shows ProductGrid empty state
- [x] Page has a title/heading ("Catalog" or similar)
- [x] Pagination component is reusable (separate component in `components/ui/`)
- [x] Product service (`lib/services/productService.ts`) is created with typed methods
- [x] Unit tests for Pagination component (16 tests)
- [x] Unit tests for catalog page behavior (20 tests)
- [x] All existing tests pass (345 total)
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `frontend/lib/services/productService.ts` | API service for product endpoints |
| `frontend/components/ui/pagination.tsx` | Reusable Pagination component |
| `frontend/components/ui/pagination.test.tsx` | Tests for Pagination component |
| `frontend/app/products/page.tsx` | Catalog page (Client Component) |
| `frontend/app/products/page.test.tsx` | Tests for catalog page |

---

## Technical Notes

### Architecture Decision: Client Component with useSearchParams

The catalog page will be a **Client Component** (`'use client'`) because:
- It needs interactive filters (ProductFilters uses `onChange` handlers)
- URL state must sync bidirectionally with component state
- Next.js App Router `useSearchParams()` + `useRouter()` for URL management

### Data Fetching Pattern

Use `useEffect` to fetch data when URL params change:
1. Read params from `useSearchParams()`
2. Build query params object (omitting undefined values)
3. Call `productService.list(params)` and `productTypeService.getAll()`
4. Update component state with results

### Product Service

Follow existing pattern from `productTypeService.ts`:
```typescript
export const productService = {
  async list(params?: ListProductsParams): Promise<ProductListResponse> { ... },
};
```

Where `ListProductsParams` = `operations['listProducts']['parameters']['query']` from auto-generated types.

### URL Param Sync

- ProductFilters `onFiltersChange` → build new URLSearchParams → `router.push(url)`
- On mount/URL change → read searchParams → pass as `value` to ProductFilters
- Pagination click → update `page` param → `router.push(url)`
- Filter change → reset page to 1

### Pagination Component

Reusable UI component in `components/ui/pagination.tsx`:
- Props: `currentPage`, `totalPages`, `onPageChange`
- Shows page numbers with prev/next buttons
- Truncates with ellipsis for many pages
- Disabled state for first/last page nav

### Key Imports

- Types: `import type { components, operations } from '@/lib/api/types'`
- API client: `import { apiClient } from '@/lib/api/client'`
- Utils: `import { cn, getLocalizedName } from '@/lib/utils'`
- Product types service: `import { productTypeService } from '@/lib/services/productTypeService'`

---

## Implementation Plan

### Phase 1: Product Service (`productService.ts` + tests)

**Goal**: Create a typed service for `GET /products`, following the `productTypeService` pattern.

**Files to create:**
- `frontend/lib/services/productService.ts`
- `frontend/lib/services/productService.test.ts`

#### Step 1.1: Write tests (RED)

Mock `apiClient.get` following `productTypeService.test.ts` pattern.

**Test cases:**
1. `list()` - calls `GET /products` with empty params when none provided
2. `list(params)` - passes all filter params as query parameters
3. `list()` - returns empty data array with pagination meta when no products
4. `list()` - propagates ApiException on network error
5. `list()` - omits undefined params from the request

**Key:** Returns full `ProductListResponse` (with `data` + `meta`), NOT just `data` array.

#### Step 1.2: Implement (GREEN)

```typescript
type ProductListResponse = components['schemas']['ProductListResponse'];
type ListProductsParams = operations['listProducts']['parameters']['query'];

export const productService = {
  async list(params?: ListProductsParams): Promise<ProductListResponse> {
    const cleanParams = params
      ? Object.fromEntries(Object.entries(params).filter(([, v]) => v !== undefined))
      : {};
    const response = await apiClient.get<ProductListResponse>('/products', { params: cleanParams });
    return response.data;
  },
};
```

#### Step 1.3: Verify — run `npx jest --testPathPatterns productService.test`

---

### Phase 2: Pagination Component (`components/ui/pagination.tsx` + tests)

**Goal**: Create a reusable pagination component in `components/ui/`.

**Files to create:**
- `frontend/components/ui/pagination.tsx`
- `frontend/components/ui/pagination.test.tsx`

**Props interface:**
```typescript
interface PaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
  className?: string;
}
```

#### Step 2.1: Write tests (RED)

**Test cases (~16 tests):**

- **Rendering:** not rendered when totalPages <= 1; rendered when > 1; has Prev/Next buttons; applies className
- **Button state:** Prev disabled on page 1; Next disabled on last page; both enabled on middle page
- **Page numbers:** all numbers for small totals (<=7); current page highlighted with `aria-current="page"`; ellipsis for many pages
- **Interactions:** page click calls `onPageChange(page)`; Prev calls `onPageChange(currentPage-1)`; Next calls `onPageChange(currentPage+1)`; clicking current page does NOT fire callback
- **Accessibility:** `nav` with `aria-label="Pagination"`; `aria-current="page"` on current

#### Step 2.2: Implement (GREEN)

- `<nav aria-label="Pagination">` wrapper
- Use existing `Button` component with variants (`outline` for pages, `default` for current)
- Ellipsis with `MoreHorizontal` icon for large page counts
- Page generation: always show first, last, and ±1 around current; ellipsis in gaps; all pages if totalPages <= 7

#### Step 2.3: Verify — run `npx jest --testPathPatterns pagination.test`

---

### Phase 3: Catalog Page (`app/products/page.tsx` + tests)

**Goal**: Assemble ProductFilters, ProductGrid, and Pagination into a page with URL-synced filter state.

**Files to create:**
- `frontend/app/products/page.tsx`
- `frontend/app/products/page.test.tsx`

#### Step 3.1: Write tests (RED)

Mock `next/navigation` (useSearchParams, useRouter), `productService`, `productTypeService`, `ProductGrid`, `ProductFilters`, and `Pagination` to isolate page logic.

**Test cases (~20 tests):**

- **Initial rendering:** heading "Catalog"; ProductFilters renders; ProductGrid renders; loading state initially; calls both services on mount
- **Data loading success:** products passed to grid; types passed to filters; Pagination shown when totalPages > 1; hidden when <= 1
- **URL param sync (read):** reads search, page, all filter params from URL and passes to service/components
- **URL param sync (write):** filter change → `router.push()` with updated params; filter change resets page to 1; page change updates URL
- **Error state:** alert on fetch failure; retry button; refetch on retry click
- **Empty state:** empty array passed to grid when no results

#### Step 3.2: Implement (GREEN)

- `'use client'` with `<Suspense>` wrapper (useSearchParams requires it)
- Read filters from `useSearchParams()`, derive `ProductFiltersValue`
- `useEffect` fetches products when `searchParams` changes (with cleanup/cancellation)
- `useEffect` fetches product types once on mount
- `handleFiltersChange`: merge filters → build URLSearchParams → `router.push()` (page reset to 1)
- `handlePageChange`: update page param → `router.push()`
- Price string→number conversion when calling service
- Sort type assertion for the union type
- Error state with Alert + retry button

#### Step 3.3: Verify
- `npx jest --testPathPatterns products/page.test` — all page tests pass
- `npm test` — all existing tests pass
- `npm run lint` — no errors
- `npm run build` — succeeds

---

### Sequencing

```
Phase 1 (productService) ──┐
                            ├──► Phase 3 (Catalog page)
Phase 2 (Pagination)     ──┘
```

Phases 1 and 2 are independent but done sequentially for TDD focus. Phase 3 depends on both.

### Potential Challenges

1. **Suspense boundary** — `useSearchParams()` requires wrapping in `<Suspense>` (same as login page)
2. **Price conversion** — `ProductFiltersValue` stores strings; API expects numbers
3. **Sort type narrowing** — URL param is `string | null`, needs cast to union type
4. **Radix mocks NOT needed** — page tests mock child components entirely
5. **act() warnings** — React 19 async warnings are expected, not failures

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing (41 new tests, 345 total)
- [x] Code follows project standards (no `any`, proper types)
- [x] No linting errors
- [x] Build succeeds
- [x] Production code validator passed

---

*Ticket created: 2026-02-16*
