# F3.3: Implement ProductGrid Component

**Sprint:** 3
**Type:** Frontend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint3-F3.3-product-grid
**Created:** 2026-02-16
**Dependencies:** F3.2 (ProductCard) ✅

---

## Description

Implement a responsive `ProductGrid` component that renders a grid of `ProductCard` components. The grid must handle three states: loading (skeleton placeholders), empty (no results message), and populated (responsive grid of cards). It receives an array of products and displays them in a CSS Grid layout that adapts from 1 column on mobile to 4 columns on desktop.

This is a **presentational component** (Server Component compatible) — it does not fetch data. The parent page (F3.1 catalog page) will handle data fetching and pass products as props.

---

## Acceptance Criteria

- [x] Renders a responsive grid: 1 col (mobile) → 2 cols (sm) → 3 cols (lg) → 4 cols (xl)
- [x] Renders a `ProductCard` for each product in the array
- [x] Shows loading skeleton placeholders when `loading` prop is true
- [x] Shows empty state message when products array is empty and not loading
- [x] Accepts optional `className` prop for external styling
- [x] Accepts optional `columns` prop to override default grid columns (for reuse in different layouts)
- [x] Unit tests for all states (loading, empty, populated)
- [x] All tests pass
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `frontend/components/product/ProductGrid.tsx` | ProductGrid component |
| `frontend/components/product/ProductGrid.test.tsx` | Tests for ProductGrid |
| `frontend/components/product/index.ts` | Re-export ProductGrid |
| `frontend/components/ui/skeleton.tsx` | Skeleton primitive (if not already present) |

---

## Implementation Steps

### Step 1: Verify/Add Skeleton UI Primitive
1. Check if `frontend/components/ui/skeleton.tsx` exists
2. If not, add a simple Skeleton component (standard shadcn/ui pattern)

### Step 2: Write Tests (TDD Red Phase)
1. Test loading state: renders skeleton placeholders
2. Test empty state: renders empty message when products is `[]` and not loading
3. Test populated state: renders correct number of ProductCards
4. Test grid layout: applies responsive grid CSS classes
5. Test custom className: merges with base grid classes
6. Test columns override: accepts custom column configuration

### Step 3: Implement ProductGrid (TDD Green Phase)
1. Define `ProductGridProps` interface: `products: Product[]`, `loading?: boolean`, `className?: string`, `skeletonCount?: number`
2. Render loading state with skeleton cards
3. Render empty state with centered message
4. Render populated grid with `ProductCard` for each product
5. Use Tailwind CSS Grid for responsive layout

### Step 4: Export from Barrel
1. Add `ProductGrid` export to `frontend/components/product/index.ts`

---

## Technical Notes

- **Server Component**: No `'use client'` directive — pure presentational component
- **Types**: Use `components['schemas']['Product']` from `@/lib/api/types`
- **Pattern**: Follow F3.2 patterns — same file structure, mock patterns, test conventions
- **Skeleton count**: Default to a reasonable number (e.g., 8) for the loading state
- **Tailwind Grid**: Use `grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6`
- **Empty state**: Simple text message, not overly designed (can be enhanced later)
- **Reusability**: The component should work for catalog page, search results, and hot products sections

---

## Implementation Plan

### Phase 1: Prerequisites — Skeleton UI Primitive

No new `skeleton.tsx` file needed. The project already uses `animate-pulse` + `bg-muted` patterns inline (see `ButtonGroupSkeleton`, `ProductTypesTable`). The skeleton card markup will live inside `ProductGrid.tsx` as a private `ProductCardSkeleton` function (not exported). Extract to a reusable primitive later if needed.

### Phase 2: Tests (Red Phase)

**File**: `frontend/components/product/ProductGrid.test.tsx`

**Mock strategy**: Mock `ProductCard` itself (not its internal deps) to isolate ProductGrid logic. Each mocked card renders a `div` with `data-testid="product-card-{id}"`.

**Test cases** (14 tests in 6 describe blocks):

**describe('ProductGrid - Loading state')**:
1. Renders skeleton placeholders when `loading={true}` (default count = 8)
2. Renders custom skeleton count via `skeletonCount` prop
3. Does not render ProductCards when loading (loading takes priority)
4. Renders sr-only "Loading products..." text for accessibility

**describe('ProductGrid - Empty state')**:
5. Renders "No products found" when `products=[]` and not loading
6. Does not render empty message when loading

**describe('ProductGrid - Populated state')**:
7. Renders a ProductCard for each product
8. Does not render empty message when products exist
9. Does not render skeletons when not loading

**describe('ProductGrid - Grid layout')**:
10. Applies responsive grid CSS classes (`grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6`)
11. Applies custom `className` to grid container

**describe('ProductGrid - Columns override')**:
12. Applies custom columns when `columns` prop is provided (replaces defaults via twMerge)
13. Uses default columns when `columns` prop is not provided

**describe('ProductGrid - Skeleton card structure')**:
14. Skeleton cards contain aspect-square image area and text-line placeholders

### Phase 3: Implementation (Green Phase)

**File**: `frontend/components/product/ProductGrid.tsx`

1. **Props interface**: `products: Product[]`, `loading?: boolean`, `className?: string`, `skeletonCount?: number` (default 8), `columns?: string`
2. **Private `ProductCardSkeleton`**: `rounded-xl border bg-card` wrapper with `aspect-square bg-muted animate-pulse` image area + two `h-4 bg-muted animate-pulse rounded` text lines. Uses `aria-hidden="true"`.
3. **Loading state**: Grid container with `role="status"` + `aria-live="polite"`, renders `skeletonCount` skeletons + sr-only text. Uses same grid classes as populated state (prevents layout shift).
4. **Empty state**: Centered `text-muted-foreground` paragraph "No products found" with `py-12`.
5. **Populated state**: Grid of `<ProductCard key={product.id} product={product} />`.
6. **Column system**: `const DEFAULT_COLUMNS = 'grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4'` — `columns ?? DEFAULT_COLUMNS` passed to `cn()` so custom columns fully replace defaults.
7. **Server Component**: No `'use client'` — pure presentational, no hooks/handlers.

### Phase 4: Refactor

- Verify skeleton mimics ProductCard visual structure (image + title + price)
- Confirm `columns` prop works correctly with twMerge deduplication
- No changes to ProductCard needed

### Phase 5: Export & Verify

1. Update `frontend/components/product/index.ts` barrel export
2. Run tests: `npm test -- --testPathPatterns="ProductGrid"`
3. Run lint: `npm run lint`
4. Run build: `npm run build`

### Files Summary

| File | Action | Purpose |
|------|--------|---------|
| `frontend/components/product/ProductGrid.test.tsx` | Create | 14 test cases |
| `frontend/components/product/ProductGrid.tsx` | Create | ProductGrid + ProductCardSkeleton (private) |
| `frontend/components/product/index.ts` | Modify | Add ProductGrid export |

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing
- [x] E2E tests updated (if applicable)
- [x] Code follows project standards
- [x] No linting errors
- [x] Build succeeds

---

*Ticket created: 2026-02-16*
