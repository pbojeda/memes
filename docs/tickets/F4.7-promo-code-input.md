# F4.7: Implement Promo Code Input

**Sprint:** 4
**Type:** Frontend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint4-F4.7-promo-code-input
**Created:** 2026-02-19
**Dependencies:** B4.4 (promo code validation backend) ✅

---

## Description

Implement a reusable `PromoCodeInput` component that lets users enter a promo code, validates it against the `POST /promo-codes/validate` endpoint, and displays the result (discount details on success, error message on failure). Also create a `promoCodeService` to call the validation API.

The component is designed to be embedded in the cart page order summary and the checkout page. It is a self-contained input + button + feedback unit — it does **not** modify cart state or store the applied code (that responsibility belongs to the checkout flow in F4.5).

### Scope

- `promoCodeService` with `validate()` method
- `PromoCodeInput` presentational component with:
  - Text input + "Apply" button
  - Loading state during validation
  - Success feedback: code, discount type, calculated discount
  - Error feedback: validation message from backend
  - "Remove" action to clear an applied code
- Unit tests for service and component

### Out of scope

- Cart store integration (no promo code state in cartStore — deferred to F4.5)
- `POST /cart/promo-code` (apply) and `DELETE /cart/promo-code` (remove) — those are checkout actions, not validation
- Admin promo code CRUD

---

## Acceptance Criteria

- [x] `promoCodeService.validate(code, orderTotal?)` calls `POST /promo-codes/validate` and returns typed response
- [x] Service handles both valid (`valid: true`) and invalid (`valid: false`) responses without throwing
- [x] Service throws `ApiException` for HTTP 400 (input validation errors)
- [x] `PromoCodeInput` renders text input with "Apply" button
- [x] Button is disabled when input is empty or while loading
- [x] Input is auto-uppercased on change (visual feedback that codes are case-insensitive)
- [x] Shows loading spinner/text while validating
- [x] On valid code: shows success message with discount details (type, value, calculated discount)
- [x] On invalid code: shows error message from backend
- [x] On API error (400): shows generic error message
- [x] "Remove" button clears applied code and resets to input state
- [x] Calls `onApply` callback with validation result when code is valid
- [x] Calls `onRemove` callback when user removes applied code
- [x] Component accepts optional `orderTotal` prop for discount calculation
- [x] All a11y: `aria-invalid`, `aria-describedby`, labels
- [x] Unit tests for promoCodeService
- [x] Unit tests for PromoCodeInput (all states: empty, loading, success, error, remove)
- [x] All tests pass
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `frontend/lib/services/promoCodeService.ts` | Service to call `POST /promo-codes/validate` |
| `frontend/lib/services/__tests__/promoCodeService.test.ts` | Unit tests for service |
| `frontend/components/promo-code/PromoCodeInput.tsx` | Promo code input component |
| `frontend/components/promo-code/PromoCodeInput.test.tsx` | Unit tests for component |
| `frontend/components/promo-code/testing/fixtures.ts` | Test fixtures for promo code validation responses |

---

## Technical Notes

### API Contract

`POST /promo-codes/validate` (public, no auth)

Request:
```json
{ "code": "SUMMER20", "orderTotal": 79.99 }
```

Success response (HTTP 200):
```json
{
  "data": {
    "valid": true,
    "code": "SUMMER20",
    "discountType": "PERCENTAGE",
    "discountValue": 20,
    "calculatedDiscount": 15.99,
    "message": "Promo code applied"
  }
}
```

Invalid code response (HTTP 200):
```json
{
  "data": {
    "valid": false,
    "code": "EXPIRED10",
    "message": "Promo code has expired"
  }
}
```

Input error response (HTTP 400):
```json
{
  "success": false,
  "error": { "message": "code is required...", "code": "INVALID_PROMO_CODE_DATA", "field": "code" }
}
```

### API Types (auto-generated)

```typescript
import type { components } from '@/lib/api/types';

// Response wrapper
type PromoCodeValidationResponse = components['schemas']['PromoCodeValidationResponse'];
// { data?: { valid?, code?, discountType?, discountValue?, calculatedDiscount?, message? } }
```

### Component Props

```typescript
interface PromoCodeResult {
  valid: boolean;
  code: string;
  discountType?: 'PERCENTAGE' | 'FIXED_AMOUNT';
  discountValue?: number;
  calculatedDiscount?: number | null;
  message: string;
}

interface PromoCodeInputProps {
  orderTotal?: number;        // Pass to API for discount calculation
  onApply?: (result: PromoCodeResult) => void;   // Called when valid code applied
  onRemove?: () => void;      // Called when user removes applied code
}
```

### Service Pattern

Follow `addressService.ts` — use `apiClient` from `@/lib/api/client`, unwrap `response.data.data`, let `apiClient` throw `ApiException` for non-2xx.

### Component States

1. **Idle** — Empty input, "Apply" button disabled
2. **Input** — User typed something, "Apply" button enabled
3. **Loading** — Validating, input disabled, button shows "Applying..."
4. **Applied** — Valid code, show success details + "Remove" button, hide input
5. **Error** — Invalid code or API error, show error message, input remains editable

### Patterns to Follow

- **AddressForm** — blur handling, `ApiException` instanceof check
- **Success feedback** — `useState<string | null>` + Alert
- **Test mocking** — mock `../../../lib/services/promoCodeService` with relative path (jest.mock doesn't resolve `@/`)
- **Radix-free** — this component uses only Input + Button + Alert (no portal issues)

---

## Implementation Plan

### Overview

TDD approach: fixtures first, then service (test + impl), then component (test + impl). No Radix portals in this component — only Input, Button, Alert, Badge from shadcn/ui. All `jest.mock()` calls use relative paths.

---

### Step 1 — Test Fixtures

**File to create:** `frontend/components/promo-code/testing/fixtures.ts`

Create factory functions for the two possible API response shapes (valid and invalid code). These will be reused in both service tests and component tests.

```typescript
import type { components } from '@/lib/api/types';

type PromoCodeValidationData = NonNullable<
  components['schemas']['PromoCodeValidationResponse']['data']
>;

/**
 * Factory for a successful (valid=true) promo code validation result.
 * The inner `data` object — already unwrapped from the API envelope.
 */
export const createValidPromoResult = (
  overrides: Partial<PromoCodeValidationData> = {}
): PromoCodeValidationData => ({
  valid: true,
  code: 'SUMMER20',
  discountType: 'PERCENTAGE',
  discountValue: 20,
  calculatedDiscount: 15.99,
  message: 'Promo code applied',
  ...overrides,
});

/**
 * Factory for a failed (valid=false) promo code validation result.
 * The inner `data` object — already unwrapped from the API envelope.
 */
export const createInvalidPromoResult = (
  overrides: Partial<PromoCodeValidationData> = {}
): PromoCodeValidationData => ({
  valid: false,
  code: 'EXPIRED10',
  message: 'Promo code has expired',
  ...overrides,
});
```

**Notes:**
- Mirror the pattern from `components/cart/testing/fixtures.ts` and `components/product/testing/fixtures.ts`.
- The type is the inner `data` object from `PromoCodeValidationResponse`, not the outer wrapper. This reflects what the service returns after unwrapping.
- `discountType` is `components['schemas']['DiscountType']` which resolves to `"PERCENTAGE" | "FIXED_AMOUNT"`.

**Checkpoint:**
```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npx tsc --noEmit
```

---

### Step 2 — promoCodeService Tests (Red)

**File to create:** `frontend/lib/services/__tests__/promoCodeService.test.ts`

Write the tests before implementing the service. Mock `apiClient` at the module level with a relative path.

```typescript
import { promoCodeService } from '../promoCodeService';
import { apiClient } from '../../api/client';
import { ApiException } from '../../api/exceptions';
import { createValidPromoResult, createInvalidPromoResult } from '../../../components/promo-code/testing/fixtures';

// Must use relative path — jest.mock() doesn't resolve @/ aliases
jest.mock('../../api/client', () => ({
  apiClient: {
    post: jest.fn(),
  },
}));

const mockApiClient = apiClient as jest.Mocked<typeof apiClient>;

describe('promoCodeService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('validate', () => {
    it('should call POST /promo-codes/validate with code and orderTotal', async () => {
      const data = createValidPromoResult();
      mockApiClient.post.mockResolvedValueOnce({ data: { data } });

      await promoCodeService.validate('SUMMER20', 79.99);

      expect(mockApiClient.post).toHaveBeenCalledWith(
        '/promo-codes/validate',
        { code: 'SUMMER20', orderTotal: 79.99 }
      );
    });

    it('should call POST /promo-codes/validate without orderTotal when not provided', async () => {
      const data = createValidPromoResult();
      mockApiClient.post.mockResolvedValueOnce({ data: { data } });

      await promoCodeService.validate('SUMMER20');

      expect(mockApiClient.post).toHaveBeenCalledWith(
        '/promo-codes/validate',
        { code: 'SUMMER20' }
      );
    });

    it('should return unwrapped data for a valid code', async () => {
      const data = createValidPromoResult();
      mockApiClient.post.mockResolvedValueOnce({ data: { data } });

      const result = await promoCodeService.validate('SUMMER20', 79.99);

      expect(result).toEqual(data);
      expect(result.valid).toBe(true);
      expect(result.discountType).toBe('PERCENTAGE');
      expect(result.calculatedDiscount).toBe(15.99);
    });

    it('should return unwrapped data for an invalid code (valid=false) without throwing', async () => {
      const data = createInvalidPromoResult();
      mockApiClient.post.mockResolvedValueOnce({ data: { data } });

      const result = await promoCodeService.validate('EXPIRED10', 79.99);

      expect(result).toEqual(data);
      expect(result.valid).toBe(false);
      expect(result.message).toBe('Promo code has expired');
    });

    it('should throw ApiException for HTTP 400 (input validation error)', async () => {
      const error = new ApiException('INVALID_PROMO_CODE_DATA', 'code is required', 400);
      mockApiClient.post.mockRejectedValueOnce(error);

      await expect(promoCodeService.validate('')).rejects.toThrow(ApiException);
      await expect(promoCodeService.validate('')).rejects.toMatchObject({
        status: 400,
        code: 'INVALID_PROMO_CODE_DATA',
      });
    });

    it('should propagate network errors', async () => {
      const error = new ApiException('NETWORK_ERROR', 'Unable to connect to server', 0);
      mockApiClient.post.mockRejectedValueOnce(error);

      await expect(promoCodeService.validate('SUMMER20')).rejects.toThrow(ApiException);
    });
  });
});
```

**Checkpoint:** Run tests (they will fail — red phase):
```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npx jest --testPathPatterns="promoCodeService.test"
```

---

### Step 3 — promoCodeService Implementation (Green)

**File to create:** `frontend/lib/services/promoCodeService.ts`

Follow exactly the same pattern as `addressService.ts`: import `apiClient` from `@/lib/api/client`, import types from `@/lib/api/types`, unwrap `response.data.data`.

```typescript
import { apiClient } from '../api/client';
import type { components } from '../api/types';

type PromoCodeValidationData = NonNullable<
  components['schemas']['PromoCodeValidationResponse']['data']
>;

export interface ValidatePromoCodeRequest {
  code: string;
  orderTotal?: number;
}

export const promoCodeService = {
  /**
   * Validate a promo code against the backend.
   * Returns the validation result for both valid (valid=true) and invalid (valid=false) codes.
   * Does NOT throw for valid=false — only throws ApiException for HTTP 400 (input errors).
   *
   * @param code - The promo code string (will be uppercased by the backend validator)
   * @param orderTotal - Optional order total for discount calculation
   */
  async validate(code: string, orderTotal?: number): Promise<PromoCodeValidationData> {
    const body: ValidatePromoCodeRequest = { code };
    if (orderTotal !== undefined) {
      body.orderTotal = orderTotal;
    }
    const response = await apiClient.post<{ data: PromoCodeValidationData }>(
      '/promo-codes/validate',
      body
    );
    return response.data.data;
  },
};
```

**Important notes:**
- The response shape is `{ data: PromoCodeValidationData }` — one unwrap level via `response.data.data`. This mirrors `addressService.ts` where `response.data.data` gives the inner payload.
- `orderTotal` is only included in the request body if defined. Do not send `orderTotal: undefined` as it may cause validation issues on the backend.
- The service does NOT handle `valid=false` specially. It returns the result as-is. The component decides what to show.
- `apiClient` automatically throws `ApiException` for non-2xx responses (via `transformError` in `client.ts`). The service does not need a try/catch.

**Checkpoint:** Tests must now pass (green phase):
```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npx jest --testPathPatterns="promoCodeService.test"
```

---

### Step 4 — PromoCodeInput Component Tests (Red)

**File to create:** `frontend/components/promo-code/PromoCodeInput.test.tsx`

Test all 5 component states (idle, input, loading, applied, error). Mock `promoCodeService` with a relative path.

```typescript
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { PromoCodeInput } from './PromoCodeInput';
import { promoCodeService } from '../../lib/services/promoCodeService';
import { ApiException } from '../../lib/api/exceptions';
import { createValidPromoResult, createInvalidPromoResult } from './testing/fixtures';

// Must use relative path — jest.mock() doesn't resolve @/ aliases
jest.mock('../../lib/services/promoCodeService', () => ({
  promoCodeService: {
    validate: jest.fn(),
  },
}));

const mockPromoCodeService = promoCodeService as jest.Mocked<typeof promoCodeService>;

describe('PromoCodeInput', () => {
  const mockOnApply = jest.fn();
  const mockOnRemove = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('idle state (empty input)', () => {
    it('should render promo code input with label', () => {
      render(<PromoCodeInput />);

      expect(screen.getByLabelText(/promo code/i)).toBeInTheDocument();
    });

    it('should render "Apply" button', () => {
      render(<PromoCodeInput />);

      expect(screen.getByRole('button', { name: /apply/i })).toBeInTheDocument();
    });

    it('should have "Apply" button disabled when input is empty', () => {
      render(<PromoCodeInput />);

      expect(screen.getByRole('button', { name: /apply/i })).toBeDisabled();
    });

    it('should not show success or error feedback in idle state', () => {
      render(<PromoCodeInput />);

      expect(screen.queryByRole('alert')).not.toBeInTheDocument();
    });
  });

  describe('input state (user has typed)', () => {
    it('should enable "Apply" button when input has text', async () => {
      const user = userEvent.setup();
      render(<PromoCodeInput />);

      await user.type(screen.getByLabelText(/promo code/i), 'SUMMER20');

      expect(screen.getByRole('button', { name: /apply/i })).toBeEnabled();
    });

    it('should auto-uppercase the input value', async () => {
      const user = userEvent.setup();
      render(<PromoCodeInput />);

      await user.type(screen.getByLabelText(/promo code/i), 'summer20');

      expect(screen.getByLabelText(/promo code/i)).toHaveValue('SUMMER20');
    });
  });

  describe('loading state', () => {
    it('should disable input and button while validating', async () => {
      const user = userEvent.setup();
      let resolveValidate: (value: ReturnType<typeof createValidPromoResult>) => void;
      mockPromoCodeService.validate.mockImplementation(
        () => new Promise((resolve) => { resolveValidate = resolve; })
      );

      render(<PromoCodeInput />);
      await user.type(screen.getByLabelText(/promo code/i), 'SUMMER20');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      expect(screen.getByLabelText(/promo code/i)).toBeDisabled();
      expect(screen.getByRole('button', { name: /applying/i })).toBeDisabled();

      resolveValidate!(createValidPromoResult());
    });

    it('should show "Applying..." text on button during validation', async () => {
      const user = userEvent.setup();
      let resolveValidate: (value: ReturnType<typeof createValidPromoResult>) => void;
      mockPromoCodeService.validate.mockImplementation(
        () => new Promise((resolve) => { resolveValidate = resolve; })
      );

      render(<PromoCodeInput />);
      await user.type(screen.getByLabelText(/promo code/i), 'SUMMER20');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      expect(screen.getByRole('button', { name: /applying/i })).toBeInTheDocument();

      resolveValidate!(createValidPromoResult());
    });
  });

  describe('applied state (valid code)', () => {
    it('should hide input and apply button after valid code is applied', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(createValidPromoResult());

      render(<PromoCodeInput />);
      await user.type(screen.getByLabelText(/promo code/i), 'SUMMER20');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.queryByLabelText(/promo code/i)).not.toBeInTheDocument();
        expect(screen.queryByRole('button', { name: /apply/i })).not.toBeInTheDocument();
      });
    });

    it('should show applied code name in success feedback', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(createValidPromoResult());

      render(<PromoCodeInput />);
      await user.type(screen.getByLabelText(/promo code/i), 'SUMMER20');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.getByText('SUMMER20')).toBeInTheDocument();
      });
    });

    it('should show discount details in success feedback', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(
        createValidPromoResult({ discountType: 'PERCENTAGE', discountValue: 20, calculatedDiscount: 15.99 })
      );

      render(<PromoCodeInput orderTotal={79.99} />);
      await user.type(screen.getByLabelText(/promo code/i), 'SUMMER20');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.getByText(/20%/i)).toBeInTheDocument();
        expect(screen.getByText(/15\.99/)).toBeInTheDocument();
      });
    });

    it('should show "Remove" button in applied state', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(createValidPromoResult());

      render(<PromoCodeInput />);
      await user.type(screen.getByLabelText(/promo code/i), 'SUMMER20');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.getByRole('button', { name: /remove/i })).toBeInTheDocument();
      });
    });

    it('should call onApply callback with result when code is valid', async () => {
      const user = userEvent.setup();
      const result = createValidPromoResult();
      mockPromoCodeService.validate.mockResolvedValueOnce(result);

      render(<PromoCodeInput onApply={mockOnApply} />);
      await user.type(screen.getByLabelText(/promo code/i), 'SUMMER20');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(mockOnApply).toHaveBeenCalledWith(result);
      });
    });

    it('should call promoCodeService.validate with orderTotal when provided', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(createValidPromoResult());

      render(<PromoCodeInput orderTotal={79.99} />);
      await user.type(screen.getByLabelText(/promo code/i), 'SUMMER20');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(mockPromoCodeService.validate).toHaveBeenCalledWith('SUMMER20', 79.99);
      });
    });
  });

  describe('remove action', () => {
    it('should reset to idle state when "Remove" is clicked', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(createValidPromoResult());

      render(<PromoCodeInput onRemove={mockOnRemove} />);
      await user.type(screen.getByLabelText(/promo code/i), 'SUMMER20');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.getByRole('button', { name: /remove/i })).toBeInTheDocument();
      });

      await user.click(screen.getByRole('button', { name: /remove/i }));

      await waitFor(() => {
        expect(screen.getByLabelText(/promo code/i)).toBeInTheDocument();
        expect(screen.getByRole('button', { name: /apply/i })).toBeInTheDocument();
      });
    });

    it('should clear the input when "Remove" is clicked', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(createValidPromoResult());

      render(<PromoCodeInput onRemove={mockOnRemove} />);
      await user.type(screen.getByLabelText(/promo code/i), 'SUMMER20');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.getByRole('button', { name: /remove/i })).toBeInTheDocument();
      });

      await user.click(screen.getByRole('button', { name: /remove/i }));

      await waitFor(() => {
        expect(screen.getByLabelText(/promo code/i)).toHaveValue('');
      });
    });

    it('should call onRemove callback when "Remove" is clicked', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(createValidPromoResult());

      render(<PromoCodeInput onRemove={mockOnRemove} />);
      await user.type(screen.getByLabelText(/promo code/i), 'SUMMER20');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.getByRole('button', { name: /remove/i })).toBeInTheDocument();
      });

      await user.click(screen.getByRole('button', { name: /remove/i }));

      expect(mockOnRemove).toHaveBeenCalledTimes(1);
    });
  });

  describe('error state (invalid or API error)', () => {
    it('should show error message from backend for invalid code (valid=false)', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(
        createInvalidPromoResult({ message: 'Promo code has expired' })
      );

      render(<PromoCodeInput />);
      await user.type(screen.getByLabelText(/promo code/i), 'EXPIRED10');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.getByText(/promo code has expired/i)).toBeInTheDocument();
      });
    });

    it('should keep input visible and editable after invalid code', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(createInvalidPromoResult());

      render(<PromoCodeInput />);
      await user.type(screen.getByLabelText(/promo code/i), 'EXPIRED10');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.getByLabelText(/promo code/i)).toBeInTheDocument();
        expect(screen.getByLabelText(/promo code/i)).not.toBeDisabled();
      });
    });

    it('should set aria-invalid on input after invalid code', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(createInvalidPromoResult());

      render(<PromoCodeInput />);
      await user.type(screen.getByLabelText(/promo code/i), 'EXPIRED10');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.getByLabelText(/promo code/i)).toHaveAttribute('aria-invalid', 'true');
      });
    });

    it('should show generic error message for ApiException (HTTP 400)', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockRejectedValueOnce(
        new ApiException('INVALID_PROMO_CODE_DATA', 'code is required', 400)
      );

      render(<PromoCodeInput />);
      await user.type(screen.getByLabelText(/promo code/i), '!');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.getByText(/invalid promo code/i)).toBeInTheDocument();
      });
    });

    it('should show generic error for unexpected API failures', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockRejectedValueOnce(new Error('Network error'));

      render(<PromoCodeInput />);
      await user.type(screen.getByLabelText(/promo code/i), 'SUMMER20');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.getByText(/could not apply promo code/i)).toBeInTheDocument();
      });
    });

    it('should clear error when user edits input after error', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(createInvalidPromoResult());

      render(<PromoCodeInput />);
      await user.type(screen.getByLabelText(/promo code/i), 'EXPIRED10');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.getByRole('alert')).toBeInTheDocument();
      });

      await user.type(screen.getByLabelText(/promo code/i), 'X');

      await waitFor(() => {
        expect(screen.queryByRole('alert')).not.toBeInTheDocument();
      });
    });

    it('should not call onApply for invalid code', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(createInvalidPromoResult());

      render(<PromoCodeInput onApply={mockOnApply} />);
      await user.type(screen.getByLabelText(/promo code/i), 'EXPIRED10');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(mockOnApply).not.toHaveBeenCalled();
      });
    });
  });

  describe('accessibility', () => {
    it('should have aria-describedby on input pointing to error message', async () => {
      const user = userEvent.setup();
      mockPromoCodeService.validate.mockResolvedValueOnce(createInvalidPromoResult());

      render(<PromoCodeInput />);
      await user.type(screen.getByLabelText(/promo code/i), 'EXPIRED10');
      await user.click(screen.getByRole('button', { name: /apply/i }));

      await waitFor(() => {
        expect(screen.getByLabelText(/promo code/i)).toHaveAttribute('aria-describedby', 'promo-code-error');
      });
    });
  });
});
```

**Checkpoint:** Run tests (they will fail — red phase):
```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npx jest --testPathPatterns="PromoCodeInput.test"
```

---

### Step 5 — PromoCodeInput Component Implementation (Green)

**File to create:** `frontend/components/promo-code/PromoCodeInput.tsx`

Implement the component to pass all tests. Use `useState` for the 5 states. No Radix portals — just Input, Button, Alert, Badge from shadcn/ui.

```typescript
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Badge } from '@/components/ui/badge';
import { promoCodeService } from '@/lib/services/promoCodeService';
import { ApiException } from '@/lib/api/exceptions';
import type { components } from '@/lib/api/types';

type PromoCodeValidationData = NonNullable<
  components['schemas']['PromoCodeValidationResponse']['data']
>;

// Re-export as a named interface for consumers (e.g. CartPageContent)
export interface PromoCodeResult extends PromoCodeValidationData {
  valid: boolean;
  code: string;
  message: string;
}

export interface PromoCodeInputProps {
  orderTotal?: number;
  onApply?: (result: PromoCodeResult) => void;
  onRemove?: () => void;
}

type ComponentState = 'idle' | 'input' | 'loading' | 'applied' | 'error';

export function PromoCodeInput({ orderTotal, onApply, onRemove }: PromoCodeInputProps) {
  const [code, setCode] = useState('');
  const [state, setState] = useState<ComponentState>('idle');
  const [appliedResult, setAppliedResult] = useState<PromoCodeValidationData | null>(null);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value.toUpperCase();
    setCode(value);
    // Clear error when user edits after an error
    if (state === 'error') {
      setState(value.trim() ? 'input' : 'idle');
      setErrorMessage(null);
    } else {
      setState(value.trim() ? 'input' : 'idle');
    }
  };

  const handleApply = async () => {
    if (!code.trim() || state === 'loading') return;

    setState('loading');
    setErrorMessage(null);

    try {
      const result = await promoCodeService.validate(code.trim(), orderTotal);

      if (result.valid) {
        setAppliedResult(result);
        setState('applied');
        onApply?.(result as PromoCodeResult);
      } else {
        setErrorMessage(result.message ?? 'Invalid promo code');
        setState('error');
      }
    } catch (error) {
      if (error instanceof ApiException) {
        setErrorMessage('Invalid promo code. Please check and try again.');
      } else {
        setErrorMessage('Could not apply promo code. Please try again.');
      }
      setState('error');
    }
  };

  const handleRemove = () => {
    setCode('');
    setAppliedResult(null);
    setErrorMessage(null);
    setState('idle');
    onRemove?.();
  };

  const isLoading = state === 'loading';
  const isApplied = state === 'applied';
  const hasError = state === 'error';
  const isButtonDisabled = !code.trim() || isLoading;

  if (isApplied && appliedResult) {
    return (
      <div className="space-y-2">
        <div className="flex items-center justify-between gap-2 rounded-md border border-green-200 bg-green-50 px-3 py-2">
          <div className="flex flex-col gap-1">
            <div className="flex items-center gap-2">
              <Badge variant="secondary">{appliedResult.code}</Badge>
              {appliedResult.discountType && appliedResult.discountValue !== undefined && (
                <span className="text-sm text-muted-foreground">
                  {appliedResult.discountType === 'PERCENTAGE'
                    ? `${appliedResult.discountValue}% off`
                    : `€${appliedResult.discountValue} off`}
                </span>
              )}
            </div>
            {appliedResult.calculatedDiscount !== undefined &&
              appliedResult.calculatedDiscount !== null && (
                <span className="text-sm font-medium text-green-700">
                  -{appliedResult.calculatedDiscount.toFixed(2)} saved
                </span>
              )}
          </div>
          <Button
            type="button"
            variant="ghost"
            size="sm"
            onClick={handleRemove}
            aria-label="Remove promo code"
          >
            Remove
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-2">
      <Label htmlFor="promo-code">Promo Code</Label>
      <div className="flex gap-2">
        <Input
          id="promo-code"
          type="text"
          placeholder="Enter promo code"
          value={code}
          onChange={handleChange}
          disabled={isLoading}
          aria-invalid={hasError}
          aria-describedby={hasError ? 'promo-code-error' : undefined}
        />
        <Button
          type="button"
          onClick={handleApply}
          disabled={isButtonDisabled}
        >
          {isLoading ? 'Applying...' : 'Apply'}
        </Button>
      </div>
      {hasError && errorMessage && (
        <Alert variant="destructive" role="alert">
          <AlertDescription id="promo-code-error">{errorMessage}</AlertDescription>
        </Alert>
      )}
    </div>
  );
}
```

**Important notes:**
- The `'use client'` directive is required because this component uses `useState`.
- The `applied` state replaces the entire form with a summary card. This avoids conditional rendering complexity within the same JSX tree.
- Error messages: use `result.message` for `valid=false` (comes from backend), use `'Invalid promo code. Please check and try again.'` for `ApiException` (HTTP 400), use `'Could not apply promo code. Please try again.'` for unexpected errors. These must match the test assertions exactly.
- `aria-invalid` is a boolean prop on `<Input>` — pass it as `{hasError}` not as `{"true"/"false"}`.
- `aria-describedby="promo-code-error"` must point to the `id` on the `<AlertDescription>` element.
- The `Badge` component shows the code in the applied state — this gives visual distinction from regular text.
- `type="button"` on all buttons to prevent accidental form submission if this component is embedded inside a `<form>`.

**Checkpoint:** Tests must now pass (green phase):
```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npx jest --testPathPatterns="PromoCodeInput.test"
```

---

### Step 6 — Full Test Suite and Build Verification

Run the complete test suite and verify the build passes.

```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npx jest --testPathPatterns="promo-code|promoCode"
```

Then run the full lint and build:
```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npm run lint && npm run build
```

---

### File Summary

| File | Action | Purpose |
|------|--------|---------|
| `frontend/components/promo-code/testing/fixtures.ts` | Create | Test factories for valid/invalid promo code validation results |
| `frontend/lib/services/__tests__/promoCodeService.test.ts` | Create | Service unit tests (TDD red phase) |
| `frontend/lib/services/promoCodeService.ts` | Create | Service calling `POST /promo-codes/validate` |
| `frontend/components/promo-code/PromoCodeInput.test.tsx` | Create | Component unit tests covering all 5 states (TDD red phase) |
| `frontend/components/promo-code/PromoCodeInput.tsx` | Create | Promo code input component |

### Existing Code Reused

- `apiClient` from `frontend/lib/api/client.ts` — HTTP client (identical pattern to `addressService`)
- `ApiException` from `frontend/lib/api/exceptions.ts` — error type checking in component
- `components['schemas']['PromoCodeValidationResponse']` from `frontend/lib/api/types.ts` — auto-generated API types
- `Button`, `Input`, `Label`, `Alert`, `AlertDescription`, `Badge` from `frontend/components/ui/` — all existing shadcn/ui primitives

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing
- [x] Code follows project standards
- [x] No linting errors
- [x] Build succeeds

---

*Ticket created: 2026-02-19*
