# F3.9: Create Admin Product Form (Create/Edit)

**Sprint:** 3
**Type:** Frontend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint3-F3.9-admin-product-form
**Created:** 2026-02-17
**Dependencies:** F3.8 (Admin products list page) ✅

---

## Description

Implement the admin product form for creating and editing products. This is a multi-field form accessible from the admin products list page. It includes bilingual text fields (es/en), product type selection, pricing, sizes, color, flags, and an image management section. The form is a separate page (`/admin/products/new` and `/admin/products/[productId]/edit`) following the pattern where the admin products table's Edit action already links to `/admin/products/{id}/edit`.

---

## Acceptance Criteria

- [x] Create product form page at `/admin/products/new`
- [x] Edit product form page at `/admin/products/[productId]/edit`
- [x] Form fields: title (es/en), description (es/en), productTypeId (select), price, compareAtPrice, availableSizes (multi-select from S/M/L/XL/XXL), color, isActive, isHot, memeSourceUrl, memeIsOriginal
- [x] Product type dropdown populated from `productTypeService.getAll()`
- [x] Edit mode: form pre-populated from `GET /products/{productId}` (admin endpoint)
- [x] Create submits `POST /products`, edit submits `PATCH /products/{productId}`
- [x] Image management section: list existing images, add new image (URL input), delete image, set primary, reorder
- [x] Client-side validation for required fields (title.es, productTypeId, price)
- [x] API error display (e.g., duplicate slug, invalid data)
- [x] Loading states during submit and data fetch
- [x] Navigation: back to products list, redirect after successful save
- [x] `adminProductService` extended with `create`, `update`, `getById`, `addImage`, `updateImage`, `deleteImage` methods
- [x] Unit tests for form component(s) and service methods
- [x] All tests pass
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `frontend/app/admin/products/new/page.tsx` | Create product page |
| `frontend/app/admin/products/[productId]/edit/page.tsx` | Edit product page |
| `frontend/components/admin/products/ProductForm.tsx` | Shared form component for create/edit |
| `frontend/components/admin/products/ProductForm.test.tsx` | Tests for ProductForm |
| `frontend/components/admin/products/ProductImageManager.tsx` | Image list/add/delete/reorder section |
| `frontend/components/admin/products/ProductImageManager.test.tsx` | Tests for ProductImageManager |
| `frontend/lib/services/adminProductService.ts` | Add create, update, getById, image CRUD methods |
| `frontend/lib/services/adminProductService.test.ts` | Tests for new service methods |

---

## Implementation Steps

### Step 1: Extend adminProductService
1. Add `getById(productId)` → `GET /products/{productId}` (admin endpoint)
2. Add `create(data)` → `POST /products`
3. Add `update(productId, data)` → `PATCH /products/{productId}`
4. Add `addImage(productId, data)` → `POST /products/{productId}/images`
5. Add `updateImage(productId, imageId, data)` → `PATCH /products/{productId}/images/{imageId}`
6. Add `deleteImage(productId, imageId)` → `DELETE /products/{productId}/images/{imageId}`

### Step 2: Build ProductForm component
1. Form state for all product fields
2. Product type dropdown (fetched from productTypeService)
3. Bilingual inputs for title and description (es/en tabs or side-by-side)
4. Available sizes as checkboxes (S, M, L, XL, XXL)
5. Price and compareAtPrice number inputs
6. Color text input
7. Boolean toggles: isActive, isHot, memeIsOriginal
8. memeSourceUrl text input
9. Client-side validation
10. Submit handler (create or update mode)
11. Error and loading states

### Step 3: Build ProductImageManager component
1. Display existing images with thumbnails
2. Mark primary image visually
3. Add image by URL
4. Delete image with confirmation
5. Toggle isPrimary on an image
6. Reorder images (sortOrder)

### Step 4: Create page routes
1. `/admin/products/new/page.tsx` — renders ProductForm in create mode
2. `/admin/products/[productId]/edit/page.tsx` — fetches product by ID, renders ProductForm in edit mode

### Step 5: Write Tests (TDD throughout)
1. Service method tests (mock apiClient)
2. ProductForm tests: renders fields, validation, submit create, submit update, error handling
3. ProductImageManager tests: renders images, add/delete/reorder, primary toggle
4. Page-level tests: loading state, error state, navigation

---

## Technical Notes

- **Types**: Use `components['schemas']['CreateProductRequest']`, `UpdateProductRequest`, `Product`, `CreateProductImageRequest`, `ProductImage` from `@/lib/api/types`
- **LocalizedString**: `{ es?: string; en?: string }` — for MVP, `es` is required, `en` is optional (ADR-003)
- **Sizes enum**: `"S" | "M" | "L" | "XL" | "XXL"` from API spec
- **Admin route guard**: Already handled by admin layout's `ProtectedRoute`
- **Product type selector**: Fetch active product types via `productTypeService.getAll({ isActive: true })`
- **Edit link**: AdminProductsTable already links to `/admin/products/${product.id}/edit`
- **Image upload**: For MVP, images are added by URL (not file upload). Cloudinary upload is backend-only (B3.7)
- **priceChangeReason**: Only on UpdateProductRequest — show conditionally when price changes in edit mode
- **Radix Select in tests**: Mock with native `<select>` (portals don't work in JSDOM)

---

## Implementation Plan

### Existing Code to Reuse

**Services:**
- `adminProductService` at `frontend/lib/services/adminProductService.ts` — extend with new methods (do NOT recreate)
- `productTypeService` at `frontend/lib/services/productTypeService.ts` — `getAll({ isActive: true })` for type dropdown

**UI Primitives** (all in `frontend/components/ui/`):
- `Button`, `Input`, `Label`, `Card`, `Alert`/`AlertDescription`, `Badge`, `Checkbox`
- `Select`, `SelectTrigger`, `SelectContent`, `SelectItem`, `SelectValue`

**Utilities:**
- `getLocalizedName(name)` from `lib/utils.ts`
- `formatPrice(price)` from `lib/utils.ts`
- `ApiException` from `lib/api/exceptions.ts`

**Types** (auto-generated, never edit directly):
- `components['schemas']['Product']`, `ProductResponse`, `ProductDetail`, `ProductDetailResponse`
- `components['schemas']['CreateProductRequest']`, `UpdateProductRequest`
- `components['schemas']['ProductImage']`, `CreateProductImageRequest`, `UpdateProductImageRequest`
- `components['schemas']['ProductType']`

**Test Fixtures:**
- `createProduct`, `createProductImage`, `createProductImages` from `components/product/testing/fixtures.ts`

**Patterns to Follow:**
- `ProductTypeFormDialog.tsx` — form with validation, loading state, apiError display
- `AdminProductsPage` (`page.tsx`) — page state management pattern
- `AdminProductsTable.tsx` — sentinel value for Radix Select, `actionLoadingId` pattern

### New Service Methods (add to `adminProductService.ts`)

7 new methods:

| Method | Endpoint | Returns |
|--------|----------|---------|
| `getById(productId)` | `GET /products/{productId}` | `Product` (from `response.data.data`) |
| `create(data: CreateProductRequest)` | `POST /products` | `Product` |
| `update(productId, data: UpdateProductRequest)` | `PATCH /products/{productId}` | `Product` |
| `listImages(productId)` | `GET /products/{productId}/images` | `ProductImage[]` |
| `addImage(productId, data: CreateProductImageRequest)` | `POST /products/{productId}/images` | `ProductImage` |
| `updateImage(productId, imageId, data: UpdateProductImageRequest)` | `PATCH /products/{productId}/images/{imageId}` | `ProductImage` |
| `deleteImage(productId, imageId)` | `DELETE /products/{productId}/images/{imageId}` | `void` |

Also add `patch` to the apiClient mock in `adminProductService.test.ts`.

### Key Technical Decisions

1. **Form state:** Flat object with `titleEs`, `titleEn`, `descriptionEs`, `descriptionEn` (not nested LocalizedString). Build LocalizedString on submit.
2. **`isActive` in edit mode:** NOT included in `UpdateProductRequest` — activate/deactivate are handled by separate endpoints on the list page. Display current status as read-only info only.
3. **`priceChangeReason`:** Show input only when `isEditMode && price changed from original`. Track original price via `useRef`.
4. **Images in edit page:** Two parallel fetches — `getById` + `listImages` — via `Promise.all`. Pass as separate `product` and `initialImages` props to `ProductForm`.
5. **Create mode images:** After successful create, redirect to `/admin/products/{id}/edit` so images can be added there. No image management on the create page.
6. **ProductForm props:** `product?: Product`, `initialImages?: ProductImage[]`, `onSuccess?: (product: Product) => void`.
7. **Radix Select mock in tests:** Mock `@/components/ui/select` with native `<select>` element (same pattern as `ProductFilters.test.tsx`).
8. **Product type loading:** Done inside `ProductForm` (self-contained). Show disabled select while loading.
9. **Price input:** `type="number"`, `step="0.01"`, `min="0"`. Store as string in form state, parse on submit.
10. **Sizes:** `const SIZES = ['S', 'M', 'L', 'XL', 'XXL'] as const`. Use `Checkbox` array with `availableSizes: string[]` in form state.

### Component Details

**ProductImageManager** — Controlled component:
```
Props: { productId: string; images: ProductImage[]; onImagesChange: (images: ProductImage[]) => void }
Internal state: newImageUrl, isAdding, actionLoadingId
```
- Sort images by `sortOrder` ascending
- "Add Image" toggles URL input + confirm/cancel
- On add: call `adminProductService.addImage(...)`, then `onImagesChange([...images, newImage])`
- On delete: call `adminProductService.deleteImage(...)`, then filter out from images
- On set primary: call `adminProductService.updateImage(...)`, then update isPrimary flags
- Auto-set first image as primary (`isPrimary: images.length === 0`)
- `actionLoadingId` pattern to disable row buttons during async

**ProductForm** — Shared form for create/edit:
```
Props: { product?: Product; initialImages?: ProductImage[]; onSuccess?: (product: Product) => void }
Form state: FormState (flat fields: titleEs, titleEn, descriptionEs, descriptionEn, productTypeId, price, compareAtPrice, color, availableSizes, isActive, isHot, memeSourceUrl, memeIsOriginal, priceChangeReason)
```
- On mount: fetch product types via `productTypeService.getAll({ isActive: true })`
- Edit pre-fill: access `(product.title as Record<string,string>)?.es ?? ''` (not `getLocalizedName`)
- Validation: `titleEs` required, `productTypeId` required, `price` required and >= 0
- On submit build: `{ title: { es: titleEs, ...(titleEn ? { en: titleEn } : {}) }, ... }`
- For update: only include `priceChangeReason` if price changed
- Images section: only render `ProductImageManager` in edit mode (when `product?.id` exists)
- Mock `ProductImageManager` in form tests (tested separately)

**Page routes:**
- `new/page.tsx`: Thin wrapper, `onSuccess` redirects to `/admin/products/{id}/edit`
- `[productId]/edit/page.tsx`: Fetches `getById` + `listImages` via `Promise.all`, passes both to `ProductForm`; shows loading/error states

### Implementation Order (TDD)

1. `adminProductService.test.ts` — add failing tests for 7 new methods (add `patch` to mock)
2. `adminProductService.ts` — implement 7 new methods (make tests pass)
3. `ProductImageManager.test.tsx` — write failing tests
4. `ProductImageManager.tsx` — implement (make tests pass)
5. `ProductForm.test.tsx` — write failing tests
6. `ProductForm.tsx` — implement (make tests pass)
7. `new/page.tsx` + `new/page.test.tsx`
8. `[productId]/edit/page.tsx` + `[productId]/edit/page.test.tsx`
9. Run `npm test`, `npm run lint`, `npm run build`

### Testing Strategy

**Service tests** (`adminProductService.test.ts`):
- One `describe` per method, follow existing style
- Test: correct endpoint called, correct data returned, error propagation

**ProductImageManager tests:**
- Renders each image thumbnail, primary badge, empty state
- Add image flow: show input → enter URL → confirm → service called → `onImagesChange` called
- Delete: service called → `onImagesChange` with filtered list
- Set primary: service called → `onImagesChange` with updated flags
- `actionLoadingId` disables buttons during async
- Mock `adminProductService` and `next/image`

**ProductForm tests:**
- Renders all fields (required + optional)
- Product type dropdown populated from service
- Validation: empty title.es, missing type, missing/negative price
- Create submit: correct `CreateProductRequest` payload
- Edit pre-fill: all fields populated from product
- Edit submit: correct `UpdateProductRequest` payload
- `priceChangeReason` visible only when price changed in edit mode
- API error display
- Loading states on submit button
- Mock: `adminProductService`, `productTypeService`, `ProductImageManager`, `next/image`, Radix Select (`@/components/ui/select`)

**Page tests:**
- Mock `ProductForm` as simple stub
- `new/page`: renders, redirects to edit page on success
- `edit/page`: calls getById + listImages, loading state, error state, retry

### Key Patterns

- **Radix Select in JSDOM:** Mock `@/components/ui/select` with native `<select>` (same as `ProductFilters.test.tsx`)
- **`act()` warnings:** React 19 async state warnings are expected, not failures
- **`useRouter` mock:** `jest.mock('next/navigation', () => ({ useParams: () => ({ productId: 'prod-1' }), useRouter: () => ({ push: mockPush }) }))`
- **Admin route guard:** Already in admin layout — no additional auth needed in pages
- **`isActive` not updatable:** Not in `UpdateProductRequest` — show as read-only badge in edit mode

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing (51 new tests, 580 total)
- [x] Code follows project standards
- [x] No linting errors
- [x] Build succeeds

---

*Ticket created: 2026-02-17*
