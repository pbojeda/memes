# B3.7: Implement Product Image Upload

**Sprint:** 3
**Type:** Backend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint3-B3.7-product-image-upload
**Created:** 2026-02-12
**Dependencies:** B3.1 (Product models - completed)

---

## Description

Implement the product image management system: a file upload endpoint (`POST /upload/image`) and product image CRUD endpoints (`/products/:productId/images`). The upload endpoint accepts multipart/form-data, validates file type/size, uploads to **Cloudinary** (free tier: 25GB storage + 25GB bandwidth/month), and returns the CDN URL. The product image endpoints manage image metadata (url, altText, isPrimary, sortOrder) linked to products.

This task covers two API areas defined in the OpenAPI spec:
1. **File upload** — `POST /upload/image` (multipart, staff only) — uploads to Cloudinary
2. **Product image CRUD** — list, add, update, delete image records for a product

---

## Acceptance Criteria

### Upload Endpoint (`POST /upload/image`)
- [ ] Accepts multipart/form-data with `file` field and optional `folder` field
- [ ] Validates file type against allowed types (JPEG, PNG, WebP — from `ALLOWED_FILE_TYPES` env var)
- [ ] Validates file size against max (from `MAX_FILE_SIZE_MB` env var, default 5MB)
- [ ] Uploads file to Cloudinary using the Cloudinary SDK
- [ ] Uses `folder` param to organize in Cloudinary (e.g., `products/`, `memes/`)
- [ ] Returns `{ url, filename, size, mimeType }` on success (201) — `url` is the Cloudinary CDN URL
- [ ] Requires auth + MANAGER/ADMIN role
- [ ] Returns 400 for invalid file type or size
- [ ] Storage layer uses a `StorageService` interface so it can be swapped for S3 or local later

### Product Image CRUD
- [ ] `GET /products/:productId/images` — lists all images for a product (public, sorted by sortOrder)
- [ ] `POST /products/:productId/images` — adds image metadata (staff only, validates productId exists)
- [ ] `PATCH /products/:productId/images/:imageId` — updates altText, isPrimary, sortOrder (staff only)
- [ ] `DELETE /products/:productId/images/:imageId` — deletes image record + deletes file from Cloudinary (staff only)
- [ ] When setting `isPrimary: true`, unsets any existing primary image for the same product (transaction)
- [ ] Validates productId is a valid UUID and product exists (not soft-deleted)
- [ ] Validates imageId is a valid UUID and belongs to the product

### General
- [ ] Input validation with descriptive error messages
- [ ] Unit tests for all service functions (Cloudinary mocked)
- [ ] Unit tests for validators
- [ ] All tests pass
- [ ] Build succeeds
- [ ] Lint passes

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `src/infrastructure/storage/storageService.ts` | Storage abstraction interface |
| `src/infrastructure/storage/cloudinaryAdapter.ts` | Cloudinary SDK implementation |
| `src/application/validators/productImageValidator.ts` | Input validation for image CRUD |
| `src/application/validators/uploadValidator.ts` | File upload validation (type, size) |
| `src/application/services/productImageService.ts` | Product image CRUD business logic |
| `src/application/services/uploadService.ts` | File upload business logic (uses StorageService) |
| `src/presentation/controllers/productImageController.ts` | Product image HTTP handlers |
| `src/presentation/controllers/uploadController.ts` | Upload HTTP handler |
| `src/routes/productRoutes.ts` | Add image sub-routes |
| `src/routes/uploadRoutes.ts` | Upload route registration |
| `src/routes/index.ts` | Register upload routes |
| `src/domain/errors/UploadError.ts` | Upload domain errors |
| Tests for each of the above | TDD |

---

## Implementation Steps

### Step 0: Cloudinary Account Setup (Manual — Owner)
1. Create a free Cloudinary account at https://cloudinary.com/users/register_free
2. From the Cloudinary Dashboard, copy the credentials:
   - `Cloud Name`
   - `API Key`
   - `API Secret`
3. Add them to `backend/.env`:
   ```
   CLOUDINARY_CLOUD_NAME=your-cloud-name
   CLOUDINARY_API_KEY=your-api-key
   CLOUDINARY_API_SECRET=your-api-secret
   ```
4. Confirm credentials are set by replying with "credentials ready"

> **Note:** The free tier includes 25GB storage + 25GB bandwidth/month — more than enough for MVP.

### Step 1: Storage Abstraction + Cloudinary Adapter
1. Define `StorageService` interface with `upload(buffer, options)` and `delete(publicId)` methods
2. Implement `CloudinaryAdapter` using the `cloudinary` SDK (v2)
3. Configure Cloudinary from env vars (`CLOUDINARY_CLOUD_NAME`, `CLOUDINARY_API_KEY`, `CLOUDINARY_API_SECRET`)
4. Write tests for Cloudinary adapter (mocking the SDK)

### Step 2: Upload Validation + Domain Errors
1. Create `UploadError` domain errors (InvalidFileType, FileTooLarge)
2. Create upload validators (file type, file size)
3. Write tests for validators

### Step 3: Upload Service + Controller
1. Implement upload service using storage abstraction
2. Configure multer middleware for multipart/form-data (memory storage — buffer only, no disk)
3. Implement upload controller
4. Register route `POST /upload/image` with auth + role middleware
5. Write tests for service and controller

### Step 4: Product Image Validators
1. Create validators for CreateProductImageInput, UpdateProductImageInput
2. Validate URL format, LocalizedText altText, sortOrder, isPrimary
3. Write tests

### Step 5: Product Image Service
1. Implement `listProductImages(productId)` — sorted by sortOrder
2. Implement `addProductImage(productId, input)` — with isPrimary transaction
3. Implement `updateProductImage(productId, imageId, input)` — with isPrimary transaction
4. Implement `deleteProductImage(productId, imageId)`
5. Write tests for each function

### Step 6: Product Image Controller + Routes
1. Implement controller functions for list, add, update, delete
2. Register routes under `/products/:productId/images`
3. Write tests

---

## Technical Notes

- **Cloudinary SDK** (`cloudinary` v2) — upload via `upload_stream` from buffer (no temp files)
- **Multer memory storage**: File stays in memory as buffer, passed to Cloudinary SDK — no disk I/O
- **Storage abstraction**: `StorageService` interface allows swapping `CloudinaryAdapter` for `S3Adapter` or `LocalAdapter` without changing service code. Tests mock the interface.
- **Cloudinary folder structure**: `memestore/{folder}/{uuid}.{ext}` (e.g., `memestore/products/abc-123.jpg`)
- **isPrimary logic**: When setting a new primary image, use a Prisma transaction to unset existing primary + set new one
- **Existing domain errors**: `ProductImageError`, `ProductImageNotFoundError`, `InvalidProductImageDataError` already exist in `domain/errors/ProductImageError.ts`
- **Existing patterns**: Follow `productController.ts` error handling pattern (`handleProductError`)
- Follow `productService.ts` pattern for service layer (validation → Prisma query → error mapping)
- Follow `productValidator.ts` pattern for validators (throwError callback)
- **Env vars already in `.env.example`**: `CLOUDINARY_CLOUD_NAME`, `CLOUDINARY_API_KEY`, `CLOUDINARY_API_SECRET`, `MAX_FILE_SIZE_MB`, `ALLOWED_FILE_TYPES`

---

## Implementation Plan

### Existing Code to Reuse

**Domain Errors:**
- `ProductImageError`, `ProductImageNotFoundError`, `InvalidProductImageDataError` from `backend/src/domain/errors/ProductImageError.ts` (already exist)
- `ProductNotFoundError`, `InvalidProductDataError` from `backend/src/domain/errors/ProductError.ts`

**Validators:**
- `validateUUID()` and `validateSlug()` from `backend/src/application/validators/shared.ts`
- `validateProductId()` from `backend/src/application/validators/productValidator.ts`
- `LocalizedText` type and `validateLocalizedText()` pattern from `productValidator.ts`

**Services:**
- `getProductById()` from `backend/src/application/services/productService.ts` (for verifying product exists)

**Middleware:**
- `authMiddleware` from `backend/src/middleware/authMiddleware.ts`
- `requireRole` from `backend/src/middleware/roleMiddleware.ts`

**Response Helpers:**
- `success()`, `created()`, `noContent()` from `backend/src/utils/responseHelpers.ts`

**Patterns:**
- Error handling pattern from `productController.ts` (handleProductError)
- Service pattern from `productService.ts` (validate → Prisma → error mapping)
- Prisma transaction pattern from `updateProduct()` (for isPrimary logic)

### Files to Create

| File Path | Purpose |
|-----------|---------|
| `backend/src/domain/errors/UploadError.ts` | Upload domain errors (InvalidFileTypeError, FileTooLargeError, UploadFailedError) |
| `backend/src/infrastructure/storage/StorageService.ts` | Storage interface (upload, delete methods) |
| `backend/src/infrastructure/storage/CloudinaryAdapter.ts` | Cloudinary SDK implementation of StorageService |
| `backend/src/infrastructure/storage/cloudinaryConfig.ts` | Cloudinary configuration from env vars |
| `backend/src/application/validators/uploadValidator.ts` | File upload validation (type, size) |
| `backend/src/application/validators/productImageValidator.ts` | Product image CRUD validation (url, altText, isPrimary, sortOrder) |
| `backend/src/application/services/uploadService.ts` | Upload business logic (uses StorageService abstraction) |
| `backend/src/application/services/productImageService.ts` | Product image CRUD business logic |
| `backend/src/presentation/controllers/uploadController.ts` | Upload HTTP handler |
| `backend/src/presentation/controllers/productImageController.ts` | Product image CRUD HTTP handlers |
| `backend/src/middleware/multerConfig.ts` | Multer memory storage configuration |
| `backend/src/routes/uploadRoutes.ts` | Upload route registration |
| `backend/src/domain/errors/UploadError.test.ts` | Tests for UploadError |
| `backend/src/infrastructure/storage/CloudinaryAdapter.test.ts` | Tests for CloudinaryAdapter (mock SDK) |
| `backend/src/application/validators/uploadValidator.test.ts` | Tests for upload validators |
| `backend/src/application/validators/productImageValidator.test.ts` | Tests for product image validators |
| `backend/src/application/services/uploadService.test.ts` | Tests for upload service |
| `backend/src/application/services/productImageService.test.ts` | Tests for product image service |
| `backend/src/presentation/controllers/uploadController.test.ts` | Tests for upload controller |
| `backend/src/presentation/controllers/productImageController.test.ts` | Tests for product image controller |

### Files to Modify

| File Path | Changes |
|-----------|---------|
| `backend/src/routes/productRoutes.ts` | Add nested routes for `/products/:productId/images` |
| `backend/src/routes/index.ts` | Register `uploadRoutes` under `/upload` |
| `backend/package.json` | Add `multer` and `cloudinary` dependencies |

### Implementation Order

#### 1. Domain Layer - Upload Errors
**File:** `backend/src/domain/errors/UploadError.ts`
- Create `UploadError` base class with `code` property
- Create `InvalidFileTypeError` (extends UploadError, code: `INVALID_FILE_TYPE`)
- Create `FileTooLargeError` (extends UploadError, code: `FILE_TOO_LARGE`)
- Create `UploadFailedError` (extends UploadError, code: `UPLOAD_FAILED`)

**File:** `backend/src/domain/errors/UploadError.test.ts`
- Test error instantiation and properties

#### 2. Infrastructure Layer - Storage Abstraction
**File:** `backend/src/infrastructure/storage/StorageService.ts`
- Define `UploadOptions` interface: `{ folder?: string; filename?: string }`
- Define `UploadResult` interface: `{ url: string; publicId: string; size: number }`
- Define `StorageService` interface:
  - `upload(buffer: Buffer, options: UploadOptions): Promise<UploadResult>`
  - `delete(publicId: string): Promise<void>`

**File:** `backend/src/infrastructure/storage/cloudinaryConfig.ts`
- Import `v2` as `cloudinary` from `cloudinary` package
- Configure Cloudinary from env vars: `CLOUDINARY_CLOUD_NAME`, `CLOUDINARY_API_KEY`, `CLOUDINARY_API_SECRET`
- Validate env vars on import (throw error if missing)
- Export configured `cloudinary` instance

**File:** `backend/src/infrastructure/storage/CloudinaryAdapter.ts`
- Implement `CloudinaryAdapter` class implementing `StorageService`
- Constructor: no params (uses configured cloudinary singleton)
- `upload(buffer, options)`:
  - Use `cloudinary.uploader.upload_stream()` with buffer
  - Set `folder: memestore/${options.folder || 'misc'}` for organization
  - Set `public_id: ${uuid()}.${ext}` if not provided
  - Return `{ url, publicId, size }`
  - Wrap Cloudinary errors in `UploadFailedError`
- `delete(publicId)`:
  - Use `cloudinary.uploader.destroy(publicId)`
  - Silently ignore not-found errors (idempotent)
  - Wrap other errors in `UploadFailedError`

**File:** `backend/src/infrastructure/storage/CloudinaryAdapter.test.ts`
- Mock `cloudinary.uploader.upload_stream` and `destroy`
- Test successful upload (returns url, publicId, size)
- Test upload failure (throws UploadFailedError)
- Test successful delete
- Test delete handles not-found gracefully

#### 3. Application Layer - Upload Validation
**File:** `backend/src/application/validators/uploadValidator.ts`
- Export constants from env vars:
  - `MAX_FILE_SIZE_MB` (default: 5)
  - `ALLOWED_FILE_TYPES` (default: `['image/jpeg', 'image/png', 'image/webp']`)
- `validateFileType(mimetype: string, fieldName: string): void`
  - Throw `InvalidFileTypeError` if not in ALLOWED_FILE_TYPES
- `validateFileSize(sizeInBytes: number, fieldName: string): void`
  - Throw `FileTooLargeError` if exceeds MAX_FILE_SIZE_MB
- `validateUploadFile(file: Express.Multer.File): void`
  - Call validateFileType and validateFileSize
- `validateFolder(folder: unknown, fieldName: string): string | undefined`
  - Optional string validation (max 50 chars, alphanumeric + hyphens)

**File:** `backend/src/application/validators/uploadValidator.test.ts`
- Test valid file passes
- Test invalid file type throws InvalidFileTypeError
- Test oversized file throws FileTooLargeError
- Test folder validation (valid, invalid, undefined)

#### 4. Application Layer - Product Image Validation
**File:** `backend/src/application/validators/productImageValidator.ts`
- Import `LocalizedText` type from `productValidator.ts`
- Import `validateUUID` from `shared.ts`
- Import `InvalidProductImageDataError` from domain errors
- Define `CreateProductImageInput`: `{ url: string; altText?: LocalizedText; isPrimary?: boolean; sortOrder?: number }`
- Define `UpdateProductImageInput`: `{ altText?: LocalizedText; isPrimary?: boolean; sortOrder?: number }`
- `validateUrl(url: unknown, fieldName: string): string`
  - Check string, non-empty, max 500 chars
  - Basic URL format check (starts with http:// or https://)
- `validateAltText(altText: unknown, fieldName: string): LocalizedText | undefined`
  - If undefined, return undefined
  - Reuse pattern from productValidator (es required, max 200 chars)
- `validateSortOrder(sortOrder: unknown, fieldName: string): number`
  - Number, >= 0, integer
- `validateCreateProductImageInput(input: CreateProductImageInput): ValidatedCreateProductImageInput`
  - Validate url (required), altText (optional), isPrimary (default false), sortOrder (default 0)
- `validateUpdateProductImageInput(input: UpdateProductImageInput): ValidatedUpdateProductImageInput`
  - Validate only provided fields

**File:** `backend/src/application/validators/productImageValidator.test.ts`
- Test validateUrl (valid, invalid, empty, too long)
- Test validateAltText (valid, missing es, too long)
- Test validateSortOrder (valid, negative, non-integer)
- Test validateCreateProductImageInput (happy path, missing required fields)
- Test validateUpdateProductImageInput (partial updates)

#### 5. Middleware Layer - Multer Configuration
**File:** `backend/src/middleware/multerConfig.ts`
- Import `multer` from `multer`
- Configure multer with memory storage: `multer.memoryStorage()`
- Export `upload` middleware: `multer({ storage: memoryStorage })`
- Single file field name: `file`

#### 6. Application Layer - Upload Service
**File:** `backend/src/application/services/uploadService.ts`
- Import `CloudinaryAdapter` (concrete implementation for now)
- Import validators from `uploadValidator`
- Export interface `UploadFileResult`: `{ url: string; filename: string; size: number; mimeType: string }`
- Export `uploadFile(file: Express.Multer.File, folder?: string): Promise<UploadFileResult>`
  - Validate file using `validateUploadFile(file)`
  - Validate folder if provided
  - Create CloudinaryAdapter instance
  - Call `adapter.upload(file.buffer, { folder })`
  - Return `{ url, filename: publicId, size, mimeType: file.mimetype }`
  - Errors propagate (InvalidFileTypeError, FileTooLargeError, UploadFailedError)

**File:** `backend/src/application/services/uploadService.test.ts`
- Mock CloudinaryAdapter
- Test successful upload (returns url, filename, size, mimeType)
- Test invalid file type throws InvalidFileTypeError
- Test oversized file throws FileTooLargeError
- Test upload failure throws UploadFailedError

#### 7. Application Layer - Product Image Service
**File:** `backend/src/application/services/productImageService.ts`
- Import prisma, validators, domain errors
- Import `getProductById` from productService to verify product exists
- Export `listProductImages(productId: string): Promise<ProductImage[]>`
  - Validate productId UUID
  - Query Prisma: `prisma.productImage.findMany({ where: { productId }, orderBy: [{ sortOrder: 'asc' }, { createdAt: 'asc' }] })`
  - Return array (can be empty)
- Export `addProductImage(productId: string, input: CreateProductImageInput): Promise<ProductImage>`
  - Validate productId and input
  - Verify product exists (not soft-deleted) using `getProductById(productId, false)`
  - If `isPrimary: true`, use Prisma transaction:
    - Unset existing primary: `prisma.productImage.updateMany({ where: { productId, isPrimary: true }, data: { isPrimary: false } })`
    - Create new image: `prisma.productImage.create({ data: { productId, url, altText, isPrimary, sortOrder } })`
  - If `isPrimary: false`, simple create
  - Return created image
- Export `updateProductImage(productId: string, imageId: string, input: UpdateProductImageInput): Promise<ProductImage>`
  - Validate productId, imageId, input
  - Verify image exists and belongs to product: `prisma.productImage.findFirst({ where: { id: imageId, productId } })`
  - Throw `ProductImageNotFoundError` if not found
  - If `isPrimary: true`, use transaction to unset existing primary + update
  - Otherwise, simple update
  - Return updated image
- Export `deleteProductImage(productId: string, imageId: string): Promise<void>`
  - Validate productId, imageId
  - Verify image exists and belongs to product
  - Delete DB record: `prisma.productImage.delete({ where: { id: imageId } })`
  - Delete from Cloudinary: extract publicId from URL, call `storageService.delete(publicId)` (best-effort — log error if Cloudinary fails but don't throw)
  - If image not found in DB, throw `ProductImageNotFoundError`

**File:** `backend/src/application/services/productImageService.test.ts`
- Mock prisma client
- Test listProductImages (returns sorted array, empty array)
- Test addProductImage (success, product not found, isPrimary transaction)
- Test updateProductImage (success, image not found, isPrimary transaction)
- Test deleteProductImage (success, image not found, Cloudinary delete failure logged but not thrown)

#### 8. Presentation Layer - Upload Controller
**File:** `backend/src/presentation/controllers/uploadController.ts`
- Import uploadService, domain errors, response helpers
- Export `uploadImage(req: Request, res: Response, next: NextFunction): Promise<void>`
  - Check `req.file` exists (multer populates this)
  - Extract `folder` from `req.body.folder` (optional)
  - Call `uploadService.uploadFile(req.file, folder)`
  - Return `created(res, result)` (201)
  - Catch errors:
    - `InvalidFileTypeError` → 400
    - `FileTooLargeError` → 400
    - `UploadFailedError` → 500
    - Others → `next(error)`

**File:** `backend/src/presentation/controllers/uploadController.test.ts`
- Mock uploadService
- Mock Express req/res/next
- Test successful upload returns 201
- Test missing file returns 400
- Test InvalidFileTypeError returns 400
- Test FileTooLargeError returns 400

#### 9. Presentation Layer - Product Image Controller
**File:** `backend/src/presentation/controllers/productImageController.ts`
- Import productImageService, domain errors, response helpers
- Export `listImages(req: Request, res: Response, next: NextFunction): Promise<void>`
  - Extract productId from `req.params.productId`
  - Call `productImageService.listProductImages(productId)`
  - Return `success(res, images)`
  - Catch errors with handleProductImageError
- Export `addImage(req: Request, res: Response, next: NextFunction): Promise<void>`
  - Extract productId from params, input from body
  - Call `productImageService.addProductImage(productId, input)`
  - Return `created(res, image)` (201)
  - Catch errors
- Export `updateImage(req: Request, res: Response, next: NextFunction): Promise<void>`
  - Extract productId, imageId from params, input from body
  - Call `productImageService.updateProductImage(productId, imageId, input)`
  - Return `success(res, image)`
  - Catch errors
- Export `deleteImage(req: Request, res: Response, next: NextFunction): Promise<void>`
  - Extract productId, imageId from params
  - Call `productImageService.deleteProductImage(productId, imageId)`
  - Return `noContent(res)` (204)
  - Catch errors
- Private helper `handleProductImageError(error: unknown, res: Response, next: NextFunction): void`
  - Map `InvalidProductImageDataError` → 400
  - Map `ProductImageNotFoundError` → 404
  - Map `ProductNotFoundError` → 404
  - Otherwise `next(error)`

**File:** `backend/src/presentation/controllers/productImageController.test.ts`
- Mock productImageService
- Test listImages returns 200
- Test addImage returns 201
- Test updateImage returns 200
- Test deleteImage returns 204
- Test error handling (400, 404)

#### 10. Routes Layer - Upload Routes
**File:** `backend/src/routes/uploadRoutes.ts`
- Import Express Router
- Import uploadController
- Import authMiddleware, requireRole
- Import multer middleware from multerConfig
- Define route: `POST /image`
  - Middleware: `authMiddleware`, `requireRole([UserRole.MANAGER, UserRole.ADMIN])`, `upload.single('file')`, `uploadController.uploadImage`
- Export router

#### 11. Routes Layer - Product Image Routes (Modify)
**File:** `backend/src/routes/productRoutes.ts`
- Import productImageController
- Add nested routes under `/:productId/images`:
  - `GET /` → `productImageController.listImages` (public, no auth)
  - `POST /` → `authMiddleware`, `requireRole([MANAGER, ADMIN])`, `productImageController.addImage`
  - `PATCH /:imageId` → `authMiddleware`, `requireRole([MANAGER, ADMIN])`, `productImageController.updateImage`
  - `DELETE /:imageId` → `authMiddleware`, `requireRole([MANAGER, ADMIN])`, `productImageController.deleteImage`

#### 12. Routes Layer - Register Upload Routes (Modify)
**File:** `backend/src/routes/index.ts`
- Import uploadRoutes
- Add: `router.use('/upload', uploadRoutes);`

#### 13. Dependencies - Install Packages
**File:** `backend/package.json`
- Add to dependencies:
  - `"cloudinary": "^2.0.0"`
  - `"multer": "^1.4.5-lts.1"`
- Add to devDependencies:
  - `"@types/multer": "^1.4.12"`

**Command:** `cd backend && npm install`

### Testing Strategy

#### Test Files to Create
All test files listed in "Files to Create" section above.

#### Key Test Scenarios

**Upload Service Tests:**
- Happy path: Valid image upload returns URL and metadata
- Invalid file type: Throws InvalidFileTypeError
- File too large: Throws FileTooLargeError
- Cloudinary failure: Throws UploadFailedError

**Product Image Service Tests:**
- listProductImages: Returns empty array, returns sorted images
- addProductImage: Success, product not found, isPrimary transaction (unsets old primary)
- updateProductImage: Success, image not found, isPrimary transaction
- deleteProductImage: Success, image not found

**Controller Tests:**
- Upload controller: Success 201, missing file 400, validation errors 400
- Product image controller: CRUD operations return correct status codes, error handling

**Validator Tests:**
- File type validation: Allowed types pass, disallowed types fail
- File size validation: Under limit pass, over limit fail
- URL validation: Valid URLs pass, invalid URLs fail
- LocalizedText validation: Spanish required, max length enforced

#### Mocking Strategy
- **Cloudinary SDK:** Mock `cloudinary.uploader.upload_stream` and `destroy` methods in CloudinaryAdapter tests
- **Prisma Client:** Mock all Prisma queries in service tests
- **StorageService:** Mock in uploadService tests to isolate business logic from infrastructure
- **Services:** Mock in controller tests to test HTTP handling in isolation
- **Multer:** Mock `req.file` in upload controller tests

#### Coverage Requirements
- All new files must have 90% coverage (branches, functions, lines, statements)
- Integration tests not required for MVP (focus on unit tests)

### Key Patterns

#### Storage Abstraction Pattern
Follow Dependency Inversion Principle (DIP):
- Define `StorageService` interface in infrastructure layer
- `CloudinaryAdapter` implements interface
- `uploadService` depends on abstraction, not concrete implementation
- Future: Swap for `S3Adapter` or `LocalAdapter` without changing service code

#### Prisma Transaction Pattern (isPrimary Logic)
Reuse pattern from `productService.updateProduct()`:
```typescript
if (isPrimary) {
  return await prisma.$transaction(async (tx) => {
    // Unset existing primary
    await tx.productImage.updateMany({
      where: { productId, isPrimary: true },
      data: { isPrimary: false }
    });
    // Create/update with isPrimary: true
    return await tx.productImage.create({ data: {...} });
  });
}
```

#### Error Handling Pattern
Follow `productController.ts` pattern:
- Create private `handleProductImageError()` helper
- Map domain errors to HTTP status codes
- Use structured error response: `{ success: false, error: { message, code, field? } }`

#### Validation Pattern
Follow `productValidator.ts` pattern:
- Separate validation functions for each field
- `throwError` callback for custom error types
- Reuse shared validators (`validateUUID`, `validateSlug`)
- Return validated, typed objects

#### Multer Memory Storage Pattern
- Use `multer.memoryStorage()` (no disk I/O)
- File buffer stored in `req.file.buffer`
- Pass buffer directly to Cloudinary `upload_stream`
- No temp files, no cleanup needed

#### Controller Pattern
Follow existing controller pattern:
- Async handlers with try-catch
- Extract params/body
- Call service layer
- Use response helpers (`success`, `created`, `noContent`)
- Catch domain errors in private error handler
- Unknown errors passed to `next(error)` for global error handler

### Important Notes

#### Environment Variables
- `CLOUDINARY_CLOUD_NAME`, `CLOUDINARY_API_KEY`, `CLOUDINARY_API_SECRET` must be set in `.env` (already in `.env.example`)
- `MAX_FILE_SIZE_MB` (default: 5) and `ALLOWED_FILE_TYPES` (default: jpeg, png, webp) are configurable

#### Cloudinary Folder Structure
- Use `memestore/{folder}/` prefix for all uploads
- Folder param from request: `products`, `memes`, etc.
- Default folder: `misc`
- Example full path: `memestore/products/abc-123-456.jpg`

#### Product Validation
- Always verify product exists and is not soft-deleted before adding/updating images
- Use `getProductById(productId, false)` from productService

#### isPrimary Constraint
- When setting a new primary image, unset the existing primary in the same transaction
- Prisma transaction ensures atomicity (both operations succeed or both fail)

#### Idempotent Delete
- Cloudinary delete should be idempotent (ignore not-found errors)
- ProductImage delete throws ProductImageNotFoundError if image doesn't exist

#### File Upload Flow
1. Multer middleware parses multipart/form-data and populates `req.file`
2. Upload controller validates file exists
3. Upload service validates file type and size
4. CloudinaryAdapter uploads to Cloudinary
5. Return CDN URL to client
6. Client uses URL in `POST /products/:productId/images` to create image metadata

#### Cloudinary Cleanup on Delete
- When deleting a ProductImage record, also delete the file from Cloudinary
- Extract the `publicId` from the Cloudinary URL to call `storageService.delete(publicId)`
- Best-effort: if Cloudinary delete fails, log the error but do NOT throw (the DB record is already deleted)
- This prevents orphaned files in Cloudinary

#### Testing Cloudinary
- In tests, mock Cloudinary SDK methods
- No real Cloudinary calls in unit tests
- Integration tests with real Cloudinary are out of scope for MVP

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Unit tests written and passing (Cloudinary SDK mocked in tests)
- [ ] Code follows project standards (DDD layers, type safety, no `any`)
- [ ] No linting errors
- [ ] Build succeeds
- [ ] Storage abstraction allows future migration to S3 or local

---

*Ticket created: 2026-02-12*
