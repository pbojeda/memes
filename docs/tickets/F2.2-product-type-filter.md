# F2.2: Create Product Type Filter Component

**Sprint:** 2
**Type:** Frontend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint2-F2.2-product-type-filter
**Created:** 2026-02-10
**Dependencies:** F2.1 (Product type service) ✅

---

## Description

Create a reusable `ProductTypeFilter` component that allows users to filter content by product type. The component fetches active product types from the API and renders them as selectable filter options. This will be used on the public catalog page and potentially other pages that list products.

The component should support both single-select (dropdown) and multi-select (button group/chips) modes, with an "All" option to clear the filter. It should handle loading, error, and empty states gracefully.

---

## Acceptance Criteria

- [x] `ProductTypeFilter` component renders product types fetched from the API
- [x] Component shows only active product types (`isActive: true`)
- [x] "All" option is available to clear the filter selection
- [x] Selected product type is visually highlighted
- [x] `onChange` callback fires with the selected product type slug (or `null` for "All")
- [x] Loading state is displayed while fetching product types
- [x] Error state is displayed if fetching fails, with a retry option
- [x] Empty state is displayed if no product types are available
- [x] Component is accessible (keyboard navigation, aria attributes)
- [x] Component is fully typed with TypeScript
- [x] Unit tests cover all states and interactions
- [x] All tests pass
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `components/product-types/ProductTypeFilter.tsx` | Filter component |
| `components/product-types/ProductTypeFilter.test.tsx` | Unit tests |
| `components/product-types/index.ts` | Barrel export |

---

## Implementation Steps

### Step 1: Write Tests
1. Test rendering loading state
2. Test rendering product types after successful fetch
3. Test "All" option is present and selected by default
4. Test clicking a product type calls `onChange` with the slug
5. Test clicking "All" calls `onChange` with `null`
6. Test selected product type is visually highlighted
7. Test error state renders with retry button
8. Test retry button re-fetches product types
9. Test empty state when no product types are returned
10. Test accessibility attributes (role, aria-label)

### Step 2: Implement Component
1. Create `ProductTypeFilter` with props: `value`, `onChange`, `className`
2. Fetch active product types using `productTypeService.getAll({ isActive: true })`
3. Render as a horizontal button group (using existing Button component variants)
4. Handle loading/error/empty states
5. Apply selected styling to the active filter

### Step 3: Create Barrel Export
1. Export `ProductTypeFilter` from `components/product-types/index.ts`

---

## Technical Notes

- Use `productTypeService.getAll({ isActive: true })` from F2.1
- Use existing `Button` component with `variant="outline"` / `variant="default"` for selected state
- Component should be a client component (`"use client"`)
- Product types are sorted by `sortOrder` from the API
- Use `slug` as the filter value (not `id`) for URL-friendly filtering
- TypeScript type: `components['schemas']['ProductType']` from auto-generated types
- Follow existing component patterns (see `LoginForm.tsx`, `UserMenu.tsx`)

---

## Implementation Plan

### Overview

The `ProductTypeFilter` component will be a horizontal button group that fetches active product types from the API and allows users to filter content by product type slug. It will handle loading, error, and empty states, and follow established patterns from `LoginForm` and `UserMenu`.

---

### 1. Test File Structure

**File:** `frontend/components/product-types/ProductTypeFilter.test.tsx`

**Mock setup:**
```typescript
jest.mock('../../lib/services/productTypeService', () => ({
  productTypeService: {
    getAll: jest.fn(),
  },
}));
```

**Test cases:**

1. **Rendering tests**
   - `should render loading skeleton while fetching product types`
     - Verify `role="status"` and `aria-live="polite"` on skeleton
     - Check that no buttons are rendered during loading

   - `should render "All" button and product type buttons after successful fetch`
     - Mock `getAll({ isActive: true })` returning `[{ id: '1', name: 'T-shirts', slug: 'tshirts', isActive: true, sortOrder: 1 }, { id: '2', name: 'Mugs', slug: 'mugs', isActive: true, sortOrder: 2 }]`
     - Verify "All" button exists
     - Verify "T-shirts" and "Mugs" buttons exist

   - `should render product types in sortOrder`
     - Mock service returning unsorted product types
     - Verify buttons render in correct order (by sortOrder)

2. **Selection state tests**
   - `should highlight "All" button when value is null`
     - Render with `value={null}`
     - Verify "All" button has `data-variant="default"` (selected)
     - Verify other buttons have `data-variant="outline"` (unselected)

   - `should highlight selected product type button when value matches slug`
     - Render with `value="tshirts"`
     - Verify "T-shirts" button has `data-variant="default"`
     - Verify "All" and other buttons have `data-variant="outline"`

3. **Interaction tests**
   - `should call onChange with null when "All" is clicked`
     - Mock `onChange`
     - Click "All" button
     - Verify `onChange(null)` was called

   - `should call onChange with product type slug when product button is clicked`
     - Mock `onChange`
     - Click "T-shirts" button
     - Verify `onChange('tshirts')` was called

   - `should support keyboard navigation`
     - Use `userEvent.tab()` to navigate between buttons
     - Verify focus moves correctly
     - Press Enter on focused button
     - Verify `onChange` is called

4. **Error state tests**
   - `should render error alert when fetch fails`
     - Mock `getAll` rejecting with error
     - Verify Alert with variant="destructive" is rendered
     - Verify error message is shown

   - `should render retry button in error state`
     - Mock `getAll` rejecting
     - Verify retry button exists

   - `should retry fetch when retry button is clicked`
     - Mock `getAll` rejecting first, then resolving on second call
     - Click retry button
     - Wait for second call
     - Verify `getAll` was called twice
     - Verify product types are now rendered

5. **Empty state tests**
   - `should render empty state message when no product types are returned`
     - Mock `getAll` returning `[]`
     - Verify empty state message is shown
     - Verify no buttons are rendered (except possibly a fallback message)

6. **Accessibility tests**
   - `should have aria-label on container`
     - Verify container has `aria-label="Filter by product type"`

   - `should have aria-pressed on buttons`
     - Render with `value="tshirts"`
     - Verify "T-shirts" button has `aria-pressed="true"`
     - Verify other buttons have `aria-pressed="false"`

   - `should have role="group" on container`
     - Verify container has `role="group"`

7. **Props tests**
   - `should apply custom className to container`
     - Render with `className="custom-class"`
     - Verify container has "custom-class"

   - `should handle value prop changes`
     - Render with `value={null}`, verify "All" is selected
     - Rerender with `value="mugs"`, verify "Mugs" is selected

---

### 2. Component Implementation

**File:** `frontend/components/product-types/ProductTypeFilter.tsx`

**Imports:**
```typescript
'use client';

import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { productTypeService } from '@/lib/services/productTypeService';
import { cn } from '@/lib/utils';
import type { components } from '@/lib/api/types';

type ProductType = components['schemas']['ProductType'];
```

**Props interface:**
```typescript
interface ProductTypeFilterProps {
  /** Currently selected product type slug, or null for "All" */
  value: string | null;
  /** Callback fired when selection changes. Receives slug or null for "All" */
  onChange: (slug: string | null) => void;
  /** Optional className for container */
  className?: string;
}
```

**State management:**
```typescript
const [productTypes, setProductTypes] = useState<ProductType[]>([]);
const [isLoading, setIsLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
```

**Data fetching logic:**
```typescript
useEffect(() => {
  fetchProductTypes();
}, []);

const fetchProductTypes = async () => {
  setIsLoading(true);
  setError(null);
  try {
    const data = await productTypeService.getAll({ isActive: true });
    // Sort by sortOrder (already sorted by API, but ensure)
    const sorted = [...data].sort((a, b) => (a.sortOrder ?? 0) - (b.sortOrder ?? 0));
    setProductTypes(sorted);
  } catch (err) {
    setError('Failed to load product types. Please try again.');
  } finally {
    setIsLoading(false);
  }
};
```

**Render logic:**

1. **Loading state:**
   ```typescript
   if (isLoading) {
     return (
       <div
         className={cn("flex gap-2", className)}
         role="status"
         aria-live="polite"
       >
         <div className="h-9 w-16 bg-muted animate-pulse rounded-md" />
         <div className="h-9 w-20 bg-muted animate-pulse rounded-md" />
         <div className="h-9 w-24 bg-muted animate-pulse rounded-md" />
         <span className="sr-only">Loading product types...</span>
       </div>
     );
   }
   ```

2. **Error state:**
   ```typescript
   if (error) {
     return (
       <div className={className}>
         <Alert variant="destructive">
           <AlertDescription className="flex items-center justify-between">
             <span>{error}</span>
             <Button
               variant="outline"
               size="sm"
               onClick={fetchProductTypes}
             >
               Retry
             </Button>
           </AlertDescription>
         </Alert>
       </div>
     );
   }
   ```

3. **Empty state:**
   ```typescript
   if (productTypes.length === 0) {
     return (
       <div className={className}>
         <p className="text-sm text-muted-foreground">
           No product types available.
         </p>
       </div>
     );
   }
   ```

4. **Main render:**
   ```typescript
   return (
     <div
       role="group"
       aria-label="Filter by product type"
       className={cn("flex flex-wrap gap-2", className)}
     >
       <Button
         variant={value === null ? "default" : "outline"}
         size="sm"
         onClick={() => onChange(null)}
         aria-pressed={value === null}
       >
         All
       </Button>
       {productTypes.map((type) => (
         <Button
           key={type.id}
           variant={value === type.slug ? "default" : "outline"}
           size="sm"
           onClick={() => onChange(type.slug ?? null)}
           aria-pressed={value === type.slug}
         >
           {type.name}
         </Button>
       ))}
     </div>
   );
   ```

**Complete component structure:**
- Client component with `'use client'` directive
- Props fully typed with TypeScript
- State for productTypes, isLoading, error
- useEffect to fetch on mount
- fetchProductTypes function (reusable for retry)
- Conditional rendering for loading/error/empty/success states
- Accessible button group with aria attributes

---

### 3. File Structure

**Files to create:**
1. `frontend/components/product-types/ProductTypeFilter.tsx` - Main component
2. `frontend/components/product-types/ProductTypeFilter.test.tsx` - Unit tests
3. `frontend/components/product-types/index.ts` - Barrel export

**Barrel export pattern:**
```typescript
// frontend/components/product-types/index.ts
export { ProductTypeFilter } from './ProductTypeFilter';
```

**Directory structure:**
```
frontend/
└── components/
    └── product-types/
        ├── ProductTypeFilter.tsx
        ├── ProductTypeFilter.test.tsx
        └── index.ts
```

---

### 4. Mocking Strategy

**Service mocking:**
```typescript
jest.mock('../../lib/services/productTypeService', () => ({
  productTypeService: {
    getAll: jest.fn(),
  },
}));
```

**Mock data:**
```typescript
const mockProductTypes: ProductType[] = [
  {
    id: '1',
    name: 'T-shirts',
    slug: 'tshirts',
    hasSizes: true,
    isActive: true,
    sortOrder: 1,
    productCount: 42,
  },
  {
    id: '2',
    name: 'Mugs',
    slug: 'mugs',
    hasSizes: false,
    isActive: true,
    sortOrder: 2,
    productCount: 18,
  },
];
```

**Mock responses:**
```typescript
// Success
(productTypeService.getAll as jest.Mock).mockResolvedValue(mockProductTypes);

// Error
(productTypeService.getAll as jest.Mock).mockRejectedValue(new Error('Network error'));

// Empty
(productTypeService.getAll as jest.Mock).mockResolvedValue([]);
```

**Before each setup:**
```typescript
beforeEach(() => {
  jest.clearAllMocks();
});
```

---

### 5. Edge Cases & Important Notes

**Edge cases to handle:**

1. **Null/undefined slug values:**
   - ProductType.slug is optional in schema (slug?: string)
   - Handle gracefully by coercing to null: `onChange(type.slug ?? null)`
   - In comparison: `value === type.slug` handles both null and undefined correctly

2. **Product type without name:**
   - ProductType.name is optional in schema
   - Fallback: display slug if name is missing: `{type.name ?? type.slug}`

3. **Concurrent onChange calls:**
   - Component is controlled - parent manages value state
   - No internal debouncing needed - let parent handle

4. **Re-fetching on props change:**
   - Component fetches once on mount only
   - Does NOT re-fetch when value/onChange change
   - If parent needs refresh, it should unmount/remount or expose refresh function

5. **Loading state timing:**
   - Show skeleton immediately on mount
   - Maintain loading state during retry

6. **API returns inactive product types:**
   - Service call explicitly filters: `getAll({ isActive: true })`
   - Backend should enforce, but component trusts the contract

7. **Accessibility keyboard navigation:**
   - Button elements are keyboard-navigable by default
   - Tab moves between buttons
   - Enter/Space activates button
   - No custom keydown handlers needed

8. **Responsive design:**
   - Container uses `flex flex-wrap` to wrap buttons on small screens
   - Buttons maintain readable size with `size="sm"`

**TypeScript considerations:**

- Use `components['schemas']['ProductType']` from auto-generated types
- All props strictly typed, no `any`
- Optional chaining for optional schema fields: `type.slug ?? null`

**Testing considerations:**

- Use `--testPathPatterns` flag (not `--testPathPattern`) for this project's Jest version
- Wait for async operations with `waitFor`
- Use `userEvent` from `@testing-library/user-event` for interactions
- Mock service at module level, not instance level

**Performance notes:**

- Fetch happens once on mount - no unnecessary re-fetches
- Product type list is typically small (< 10 items) - no virtualization needed
- No memo optimization needed for this simple component

**Future enhancements (out of scope):**

- Loading indicator could show estimated count skeleton
- Could add tooltip showing productCount on hover
- Could add icons for each product type
- Could support multi-select mode (checkboxes instead of buttons)

---

### 6. Integration Notes

**Usage example:**
```typescript
'use client';

import { useState } from 'react';
import { ProductTypeFilter } from '@/components/product-types';

export function CatalogPage() {
  const [selectedType, setSelectedType] = useState<string | null>(null);

  return (
    <div>
      <ProductTypeFilter
        value={selectedType}
        onChange={setSelectedType}
        className="mb-6"
      />
      {/* Product list filtered by selectedType */}
    </div>
  );
}
```

**URL synchronization pattern (future):**
```typescript
// Sync with URL query params
const searchParams = useSearchParams();
const router = useRouter();

const selectedType = searchParams.get('type');

const handleChange = (slug: string | null) => {
  const params = new URLSearchParams(searchParams);
  if (slug) {
    params.set('type', slug);
  } else {
    params.delete('type');
  }
  router.push(`/catalog?${params.toString()}`);
};
```

---

### 7. Definition of Done Checklist

- [ ] ProductTypeFilter.tsx created with all states (loading, error, empty, success)
- [ ] ProductTypeFilter.test.tsx created with all 20+ test cases passing
- [ ] Barrel export created at components/product-types/index.ts
- [ ] Component fetches active product types from productTypeService
- [ ] "All" option clears filter (onChange with null)
- [ ] Selected button uses variant="default", others use variant="outline"
- [ ] Loading skeleton with aria attributes
- [ ] Error state with retry button that re-fetches
- [ ] Empty state message when no types available
- [ ] Accessible: role="group", aria-label, aria-pressed on buttons
- [ ] Fully typed TypeScript, no any types
- [ ] All tests pass: `cd frontend && npm test -- --testPathPatterns=ProductTypeFilter`
- [ ] Linting passes: `cd frontend && npm run lint`
- [ ] Build succeeds: `cd frontend && npm run build`
- [ ] Component follows established patterns (LoginForm, UserMenu)
- [ ] Code reviewed by production-code-validator agent

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing
- [x] E2E tests updated (if applicable) — N/A for this task
- [x] Code follows project standards
- [x] No linting errors
- [x] Build succeeds

---

*Ticket created: 2026-02-10*
