# F3.14: Add file upload support to ProductImageManager

**Sprint:** 3
**Type:** Frontend - Bugfix
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint3-F3.14-file-upload-image-manager
**Created:** 2026-02-17
**Dependencies:** B3.7 (upload endpoint), F3.9 (ProductImageManager)

---

## Description

The `ProductImageManager` component currently only supports adding images by pasting a URL. It lacks a file picker / file upload capability. The backend already has a working Cloudinary upload endpoint at `POST /api/v1/upload/image` (multer + Cloudinary, returns `{ url, filename, size, mimeType }`). This task adds an `<input type="file">` option that uploads the selected file to the backend, gets back the Cloudinary URL, and then calls `addImage()` to associate it with the product.

**Backend endpoint details:**
- `POST /api/v1/upload/image` — multipart/form-data with `file` field
- Auth: Bearer token (MANAGER/ADMIN)
- Returns: `{ data: { url, filename, size, mimeType } }` (201)
- Max file size: 5 MB (configurable via `MAX_FILE_SIZE_MB`)
- Accepted types: validated in `uploadValidator`

---

## Acceptance Criteria

- [x] `adminProductService` has an `uploadImage(file: File)` method that sends multipart/form-data to `POST /upload/image`
- [x] `ProductImageManager` shows a "Upload File" button alongside the existing "Add Image" (URL) button
- [x] Clicking "Upload File" opens a native file picker (accepts image types)
- [x] After file selection, the component uploads the file via `adminProductService.uploadImage()`
- [x] On upload success, calls `adminProductService.addImage()` with the returned Cloudinary URL
- [x] Shows loading state during upload
- [x] Shows error message if upload fails
- [x] Existing URL-based image adding still works unchanged
- [x] Unit tests for new `uploadImage` service method
- [x] Unit tests for file upload UI interaction
- [x] All tests pass
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `frontend/lib/services/adminProductService.ts` | Add `uploadImage(file: File)` method |
| `frontend/components/admin/products/ProductImageManager.tsx` | Add file upload button + handler |
| `frontend/components/admin/products/ProductImageManager.test.tsx` | Tests for file upload flow |

---

## Implementation Steps

### Step 1: Add `uploadImage` to adminProductService
1. Add method that sends `FormData` with the file to `POST /upload/image`
2. Uses `Content-Type: multipart/form-data` (let axios set it automatically by passing FormData)
3. Returns the upload response data (url, filename, size, mimeType)

### Step 2: Add file upload UI to ProductImageManager
1. Add a hidden `<input type="file" accept="image/*">` ref
2. Add "Upload File" button next to existing "Add Image" button
3. On file selection: upload via `adminProductService.uploadImage()` → then `addImage()` with returned URL
4. Show loading state during the two-step process
5. Show error on failure

### Step 3: Write Tests
1. Test `uploadImage` service method (FormData construction, correct endpoint)
2. Test file upload button appears
3. Test file selection triggers upload + addImage flow
4. Test loading state during upload
5. Test error display on upload failure

---

## Technical Notes

- The axios client sets `Content-Type: application/json` by default. For file uploads, pass `FormData` and let axios auto-detect the content type (or explicitly set `Content-Type: multipart/form-data`).
- The upload endpoint returns `{ data: { url, filename, size, mimeType } }` — we only need the `url` to pass to `addImage()`.
- The file input should use `accept="image/*"` to filter the picker to image files.
- Use a `ref` for the hidden file input triggered by the upload button click.

---

## Implementation Plan

### Existing Code to Reuse

- **`adminProductService`** (`frontend/lib/services/adminProductService.ts`) — extend with `uploadImage(file: File)` method using the same `apiClient` pattern already in use for all other methods.
- **`apiClient`** (`frontend/lib/api/client.ts`) — handles Bearer token injection via the request interceptor automatically; no extra auth headers needed. The default `Content-Type: application/json` header will be overridden automatically by axios when a `FormData` body is passed (axios sets `multipart/form-data` with the correct boundary). Do **not** set `Content-Type` manually in the service method.
- **`components['schemas']['UploadResponse']`** from `frontend/lib/api/types.ts` — the auto-generated type already exists: `{ data?: { url?: string; filename?: string; size?: number; mimeType?: string } }`. Import and use it for the return type.
- **`Button`**, **`Alert`**, **`AlertDescription`** shadcn/ui primitives — already imported and in use in `ProductImageManager.tsx`. No new UI primitives required.
- **`actionLoadingId`** pattern — already implemented in `ProductImageManager` for delete/set-primary. Reuse the same `actionLoadingId` state to cover upload loading (use a sentinel string like `'uploading'`).
- **`apiError`** state — already in `ProductImageManager`. Reuse it for upload errors.
- **`createProductImage` / `createProductImages` fixtures** (`frontend/components/product/testing/fixtures.ts`) — reuse in new tests.
- **Existing mock** `jest.mock('../../../lib/services/adminProductService', ...)` in `ProductImageManager.test.tsx` — extend the mock object to include `uploadImage: jest.fn()`.

---

### Files to Create

None. All work fits within existing files.

---

### Files to Modify

#### 1. `frontend/lib/services/adminProductService.ts`

Add one new method `uploadImage` to the `adminProductService` object.

Key details:
- Import `UploadResponse` type from `../api/types` using `components['schemas']['UploadResponse']`.
- Create a `FormData` instance, call `formData.append('file', file)` where `file` is the `File` argument.
- Call `apiClient.post<UploadResponse>('/upload/image', formData)`. Do **not** set `Content-Type` manually — axios detects `FormData` and sets `multipart/form-data` with the correct boundary automatically.
- Return `response.data.data` (the inner data object with `url`, `filename`, `size`, `mimeType`). The return type is `NonNullable<UploadResponse['data']>` or an explicit inline type `{ url?: string; filename?: string; size?: number; mimeType?: string }`.
- The method signature: `async uploadImage(file: File): Promise<{ url?: string; filename?: string; size?: number; mimeType?: string }>`.

Note: The endpoint is `POST /upload/image` (not `/products/.../images`). The axios `baseURL` is already `http://localhost:3000/api/v1`, so the path `/upload/image` resolves correctly.

#### 2. `frontend/components/admin/products/ProductImageManager.tsx`

Add file upload capability alongside the existing URL-based flow.

State additions (inside the component, alongside existing `useState` calls):
- `isUploading: boolean` — tracks upload-in-progress to show spinner/disable button separately from `actionLoadingId` (which is per-row). Alternatively, use `actionLoadingId === 'uploading'` as the sentinel — this is consistent with the existing `'adding'` sentinel already used for the URL add flow. Prefer the existing `actionLoadingId` pattern with the `'uploading'` sentinel for consistency.

Ref addition:
- `const fileInputRef = useRef<HTMLInputElement>(null)` — ref to the hidden file input element.

New handler `handleUploadFile`:
- Accepts `event: React.ChangeEvent<HTMLInputElement>`.
- Reads `event.target.files?.[0]`. If no file, return early.
- Sets `actionLoadingId('uploading')` and clears `apiError`.
- Calls `adminProductService.uploadImage(file)` to get the Cloudinary URL.
- On success: calls `adminProductService.addImage(productId, { url: uploadedUrl, isPrimary: images.length === 0, sortOrder: images.length })` (identical to the URL flow).
- On success of `addImage`: calls `onImagesChange([...images, newImage])`.
- On any error: sets `apiError` with the error message.
- In `finally`: resets `actionLoadingId(null)` and resets `fileInputRef.current.value = ''` so the same file can be re-selected after an error.

UI changes (in the `return` JSX, in the bottom section where buttons are rendered):
- Add a hidden `<input>` element:
  ```
  <input
    type="file"
    accept="image/*"
    ref={fileInputRef}
    className="hidden"
    onChange={handleUploadFile}
    aria-label="Upload image file"
  />
  ```
- The existing "Add Image" button (URL flow) stays unchanged.
- Add a new "Upload File" button **next to** the existing "Add Image" button (both visible when `!isAdding`):
  ```
  <Button
    variant="outline"
    disabled={actionLoadingId === 'uploading'}
    onClick={() => fileInputRef.current?.click()}
  >
    {actionLoadingId === 'uploading' ? 'Uploading...' : 'Upload File'}
  </Button>
  ```
- The two buttons ("Add Image" and "Upload File") are both shown in the default state (when `!isAdding`). When `isAdding` is true (URL input is open), only the URL input row is shown — the "Upload File" button is hidden. This preserves the existing cancel/add flow cleanly.
- The upload button is disabled while `actionLoadingId === 'uploading'` to prevent double-submission.

`useRef` import: Add `useRef` to the existing React import. The file currently imports `{ useState }` from `'react'`; change to `{ useState, useRef }`.

---

#### 3. `frontend/components/admin/products/ProductImageManager.test.tsx`

Extend the existing mock and add new test cases.

Mock extension:
- In the existing `jest.mock(...)` block, add `uploadImage: jest.fn()` to the `adminProductService` mock object alongside `addImage`, `updateImage`, `deleteImage`.

New test cases to add (in the existing `describe('ProductImageManager', ...)` block):

1. **"should render an Upload File button"**
   - Renders with empty images array.
   - Asserts `screen.getByRole('button', { name: /upload file/i })` is in the document.

2. **"should open file picker when Upload File is clicked"**
   - Renders with empty images array.
   - Spies on `fileInputRef.current.click` — since refs are internal, test by checking the hidden input exists and clicking the button does not throw. Alternatively, assert the hidden `<input type="file">` is in the document using `document.querySelector('input[type="file"]')` or `screen.getByLabelText(/upload image file/i)`.
   - This test verifies the file input element is rendered with `accept="image/*"`.

3. **"should upload file and call addImage with the returned URL on file selection"**
   - Sets up `mockAdminProductService.uploadImage.mockResolvedValueOnce({ url: 'https://res.cloudinary.com/test/img.jpg' })`.
   - Sets up `mockAdminProductService.addImage.mockResolvedValueOnce(newImage)`.
   - Gets the hidden file input via `screen.getByLabelText(/upload image file/i)` (matched by `aria-label`).
   - Uses `userEvent.upload(fileInput, new File(['img'], 'photo.jpg', { type: 'image/jpeg' }))` to simulate file selection.
   - `await waitFor(...)` asserts `mockAdminProductService.uploadImage` was called with a `File` instance.
   - Asserts `mockAdminProductService.addImage` was called with `(productId, { url: 'https://res.cloudinary.com/test/img.jpg', isPrimary: true, sortOrder: 0 })`.
   - Asserts `mockOnImagesChange` was called with `[newImage]`.

4. **"should show loading state during file upload"**
   - Sets up `mockAdminProductService.uploadImage` to return a never-resolving promise: `jest.fn(() => new Promise(() => {}))`.
   - Simulates file selection.
   - Asserts the "Upload File" button text changes to "Uploading..." (or that it is disabled).

5. **"should show error message when file upload fails"**
   - Sets up `mockAdminProductService.uploadImage.mockRejectedValueOnce(new Error('File too large'))`.
   - Simulates file selection.
   - `await waitFor(...)` asserts `screen.getByRole('alert')` has text `'File too large'`.
   - Asserts `mockAdminProductService.addImage` was **not** called.

6. **"should show error message when addImage fails after successful upload"**
   - Sets up `mockAdminProductService.uploadImage.mockResolvedValueOnce({ url: 'https://res.cloudinary.com/test/img.jpg' })`.
   - Sets up `mockAdminProductService.addImage.mockRejectedValueOnce(new Error('Server error'))`.
   - Simulates file selection.
   - `await waitFor(...)` asserts `screen.getByRole('alert')` has text `'Server error'`.
   - Asserts `mockOnImagesChange` was **not** called.

---

### Implementation Order

1. **Modify `adminProductService.ts`** — add `uploadImage` method (no UI changes, can be tested in isolation).
2. **Write service-level tests** (test cases 3 and 5 above cover the service interaction indirectly; no separate service unit test file needed since the service is thin and the component tests cover it via mock verification).
3. **Modify `ProductImageManager.tsx`** — add `useRef`, hidden input, handler, and "Upload File" button.
4. **Extend `ProductImageManager.test.tsx`** — extend mock + add 6 new test cases.
5. **Run tests**: `cd /Users/pb/Developer/FiveGuays/memes/frontend && npm test -- --testPathPatterns ProductImageManager`.
6. **Run lint and build**: `npm run lint && npm run build` inside `frontend/`.

---

### Testing Strategy

- **No new test files** — extend the existing `ProductImageManager.test.tsx`.
- **No real HTTP calls** — `adminProductService` is fully mocked.
- **File simulation** — use `userEvent.upload(input, file)` from `@testing-library/user-event`. This dispatches a change event with `event.target.files` populated. The `File` constructor (`new File([content], name, { type })`) works in JSDOM.
- **Avoid testing implementation details** — do not assert on `fileInputRef.current.click()` internals. Test observable behavior: the button is disabled during upload, the error alert appears on failure, `addImage` is called with the right arguments.
- **File input accessibility** — use `aria-label="Upload image file"` on the `<input type="file">` so tests can locate it with `screen.getByLabelText(/upload image file/i)`.

---

### Key Patterns

- **Sentinel `actionLoadingId`**: Use `'uploading'` as the sentinel value for the upload loading state, consistent with `'adding'` already used for the URL-add flow. Both use the same `actionLoadingId` state variable.
- **axios + FormData**: Pass `FormData` directly to `apiClient.post()`. Axios automatically sets `Content-Type: multipart/form-data` with the correct multipart boundary when the body is a `FormData` instance. Setting the header manually would break the boundary.
- **Reset file input after use**: Set `fileInputRef.current.value = ''` in the `finally` block of `handleUploadFile`. Without this, selecting the same file again after an error would not fire the `onChange` event (browser deduplicates identical selections).
- **Two-step upload**: The file upload (`POST /upload/image`) and image association (`POST /products/:id/images`) are two separate API calls. The `actionLoadingId === 'uploading'` covers the entire two-step sequence — it is set before the upload starts and cleared in `finally` after `addImage` completes or fails.
- **Type safety**: Use `components['schemas']['UploadResponse']` from `lib/api/types.ts` as the return type of `uploadImage`. Access the URL via `response.data.data?.url`. Guard against undefined with a fallback empty string if needed before passing to `addImage`.
- **No API spec changes needed**: The `uploadImage` operation is already defined in `api-spec.yaml` and the generated `UploadResponse` type is already in `lib/api/types.ts`. Do **not** run `npm run generate:api`.

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing
- [x] Code follows project standards
- [x] No linting errors
- [x] Build succeeds

---

*Ticket created: 2026-02-17*
