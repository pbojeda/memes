# F1.6 + F1.10: JWT Interceptors with Token Refresh

**Sprint:** 1
**Type:** Frontend - API Infrastructure
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint1-F1.6-jwt-interceptors
**Created:** 2026-02-09
**Dependencies:** F1.5 (authService), F1.1 (authStore)

---

## Description

Configure axios interceptors to properly handle JWT authentication with automatic token refresh. This task merges F1.6 (interceptors) and F1.10 (refresh logic) as they are tightly coupled.

**Current Problem:**
- `apiClient.ts` reads token from `localStorage.getItem('accessToken')` directly
- `authStore` uses Zustand persist which stores under `'auth-storage'` key as JSON
- These are incompatible - the interceptor cannot find the token

**Solution:**
1. Fix request interceptor to read from authStore
2. Add response interceptor that handles 401 errors with automatic refresh
3. Implement request queuing during refresh to prevent race conditions
4. Redirect to login when refresh fails

---

## Acceptance Criteria

- [x] Request interceptor reads accessToken from authStore (not localStorage)
- [x] Response interceptor detects 401 errors
- [x] On 401, attempts token refresh using authService.refresh()
- [x] Original request is retried with new token on successful refresh
- [x] Requests are queued during refresh (no duplicate refresh calls)
- [x] Auth is cleared and user redirected to /login on refresh failure
- [x] Refresh endpoint itself is excluded from retry logic (prevents loops)
- [x] Unit tests cover all scenarios
- [x] All tests pass
- [x] Build succeeds
- [x] Lint passes

---

## Files to Create/Modify

| File | Action | Purpose |
|------|--------|---------|
| `frontend/lib/api/client.ts` | Modify | Add proper interceptors with refresh logic |
| `frontend/lib/api/client.test.ts` | Create | Unit tests for interceptors |

---

## Technical Design

### Request Interceptor

```typescript
// Read token from authStore, not localStorage
client.interceptors.request.use((config) => {
  if (typeof window !== 'undefined') {
    const { accessToken } = useAuthStore.getState();
    if (accessToken && config.headers) {
      config.headers.Authorization = `Bearer ${accessToken}`;
    }
  }
  return config;
});
```

### Response Interceptor with Refresh

```typescript
// State to manage refresh
let isRefreshing = false;
let failedQueue: Array<{
  resolve: (token: string) => void;
  reject: (error: Error) => void;
}> = [];

// Process queued requests after refresh
const processQueue = (error: Error | null, token: string | null) => {
  failedQueue.forEach((promise) => {
    if (error) {
      promise.reject(error);
    } else {
      promise.resolve(token!);
    }
  });
  failedQueue = [];
};

client.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    const originalRequest = error.config;

    // Skip if not 401, or if it's the refresh endpoint, or already retried
    if (
      error.response?.status !== 401 ||
      originalRequest?.url?.includes('/auth/refresh') ||
      originalRequest?._retry
    ) {
      return Promise.reject(transformError(error));
    }

    // If already refreshing, queue this request
    if (isRefreshing) {
      return new Promise((resolve, reject) => {
        failedQueue.push({ resolve, reject });
      }).then((token) => {
        originalRequest.headers.Authorization = `Bearer ${token}`;
        return client(originalRequest);
      });
    }

    originalRequest._retry = true;
    isRefreshing = true;

    try {
      await authService.refresh();
      const { accessToken } = useAuthStore.getState();
      processQueue(null, accessToken);
      originalRequest.headers.Authorization = `Bearer ${accessToken}`;
      return client(originalRequest);
    } catch (refreshError) {
      processQueue(refreshError, null);
      // Redirect to login
      if (typeof window !== 'undefined') {
        window.location.href = '/login';
      }
      return Promise.reject(refreshError);
    } finally {
      isRefreshing = false;
    }
  }
);
```

### Type Extension for Retry Flag

```typescript
// Extend AxiosRequestConfig to include _retry flag
declare module 'axios' {
  export interface InternalAxiosRequestConfig {
    _retry?: boolean;
  }
}
```

---

## Test Scenarios

### Request Interceptor Tests
1. Should add Authorization header when accessToken exists
2. Should not add header when no token
3. Should work correctly on server-side (no window)

### Response Interceptor Tests
1. Should pass through successful responses unchanged
2. Should attempt refresh on 401 error
3. Should retry original request with new token after successful refresh
4. Should queue multiple 401 requests during refresh
5. Should reject all queued requests on refresh failure
6. Should redirect to /login on refresh failure
7. Should not attempt refresh for /auth/refresh endpoint (prevent loop)
8. Should not retry already-retried requests

---

## Implementation Steps

### Step 1: Write Tests First (TDD)

Create `frontend/lib/api/client.test.ts` with all test scenarios.

### Step 2: Refactor Client Structure

Extract interceptor logic to make it testable:
- Create helper functions for token handling
- Make refresh state manageable for tests

### Step 3: Fix Request Interceptor

Update to read from authStore instead of localStorage.

### Step 4: Implement Response Interceptor

Add 401 handling with refresh and retry logic.

### Step 5: Verify and Clean Up

```bash
cd frontend && npm test -- client
cd frontend && npm run lint
cd frontend && npm run build
```

---

## Edge Cases

| Scenario | Expected Behavior |
|----------|-------------------|
| Token expired during request | 401 triggers refresh, request retried |
| Multiple concurrent 401s | Only one refresh, others queued |
| Refresh token also expired | Clear auth, redirect to login |
| Network error (not 401) | Normal error handling |
| Server-side rendering | Skip token logic gracefully |

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Request interceptor uses authStore
- [x] 401 triggers automatic refresh and retry
- [x] Request queuing prevents race conditions
- [x] Failed refresh redirects to login
- [x] Unit tests cover all scenarios
- [x] No linting errors
- [x] Build succeeds

---

*Ticket created: 2026-02-09*
