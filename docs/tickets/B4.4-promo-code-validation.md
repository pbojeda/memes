# B4.4: Implement Promo Code Validation

**Sprint:** 4
**Type:** Backend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint4-B4.4-promo-code-validation
**Created:** 2026-02-19
**Dependencies:** None

---

## Description

Implement the PromoCode Prisma model (including migration and `DiscountType` enum) and a public validation endpoint `POST /promo-codes/validate`. The endpoint accepts a promo code string and optional order total, then returns whether the code is valid along with discount details and a calculated discount amount.

The PromoCode model is already fully documented in `data-model.md` (section 3.8) and the API spec defines all promo code endpoints and schemas. B4.4 focuses on:
1. Adding the `DiscountType` enum and `PromoCode` model to `schema.prisma` + running migration
2. Implementing the **public validation endpoint** (`POST /promo-codes/validate`, `security: []`)
3. Domain errors, validator, service (discount calculation logic), controller, routes

Admin CRUD endpoints for promo codes (list, create, update, delete, stats) are **out of scope** for B4.4 — those will be handled in a future sprint.

---

## Acceptance Criteria

- [x] `DiscountType` enum added to `schema.prisma` (PERCENTAGE, FIXED_AMOUNT)
- [x] `PromoCode` model added to `schema.prisma` matching `data-model.md` section 3.8
- [x] Migration created and applied successfully
- [x] `POST /promo-codes/validate` endpoint accepts `{ code, orderTotal? }`
- [x] Validates code exists, is active, within valid date range, under max uses
- [x] Returns discount details: `discountType`, `discountValue`, `calculatedDiscount`
- [x] Percentage discount: calculates based on `orderTotal`, capped by `maxDiscountAmount`
- [x] Fixed amount discount: returns `discountValue` directly (capped at `orderTotal` if provided)
- [x] Minimum order amount check: returns invalid if `orderTotal < minOrderAmount`
- [x] Returns appropriate error messages for each failure reason
- [x] Input validation: code is required, non-empty string, trimmed; orderTotal >= 0 if provided
- [x] Domain errors: `PromoCodeError`, `InvalidPromoCodeDataError`, `PromoCodeNotFoundError`, `PromoCodeExpiredError`, `PromoCodeInactiveError`, `PromoCodeUsageLimitError`, `MinOrderAmountNotMetError`
- [x] Validator: `promoCodeValidator.ts` with `validatePromoCodeInput`
- [x] Service: `promoCodeService.ts` with `validatePromoCode`
- [x] Controller: `promoCodeController.ts` with `validatePromoCode` handler
- [x] Routes: `promoCodeRoutes.ts` mounted at `/promo-codes`
- [x] Unit tests for domain errors
- [x] Unit tests for validator
- [x] Unit tests for service (discount calculation, all failure scenarios)
- [x] Integration tests for route
- [x] All existing tests pass (1244 total)
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `prisma/schema.prisma` | Add `DiscountType` enum + `PromoCode` model |
| `prisma/migrations/*/migration.sql` | Auto-generated migration |
| `src/domain/errors/PromoCodeError.ts` | Promo code domain error classes |
| `src/domain/errors/PromoCodeError.test.ts` | Tests for error classes |
| `src/application/validators/promoCodeValidator.ts` | Input validation |
| `src/application/validators/promoCodeValidator.test.ts` | Tests for validator |
| `src/application/services/promoCodeService.ts` | Validation + discount calculation logic |
| `src/application/services/promoCodeService.test.ts` | Tests for service |
| `src/presentation/controllers/promoCodeController.ts` | HTTP handler |
| `src/presentation/controllers/promoCodeController.test.ts` | Tests for controller |
| `src/routes/promoCodeRoutes.ts` | Route definitions |
| `src/routes/promoCodeRoutes.integration.test.ts` | Integration tests |
| `src/routes/index.ts` | Register promo code routes |

---

## Technical Notes

### PromoCode Model (from data-model.md section 3.8)

Already defined in `data-model.md` with Prisma model syntax. Key fields:
- `code`: VARCHAR(50), UNIQUE — stored uppercase
- `discountType`: PERCENTAGE | FIXED_AMOUNT
- `discountValue`: Decimal — percentage (0-100) or fixed amount
- `minOrderAmount`: Decimal? — minimum order to apply
- `maxDiscountAmount`: Decimal? — cap for percentage discounts
- `maxUses`: Int? — null means unlimited
- `currentUses`: Int, default 0
- `validFrom`/`validUntil`: DateTime — date range
- `isActive`: Boolean, default true
- `createdByUserId`: FK → User

### Validation Endpoint (from API spec)

`POST /promo-codes/validate` — public (no auth), accepts:
```json
{ "code": "SUMMER20", "orderTotal": 79.99 }
```

Response (`PromoCodeValidationResponse`):
```json
{
  "data": {
    "valid": true,
    "code": "SUMMER20",
    "discountType": "PERCENTAGE",
    "discountValue": 20,
    "calculatedDiscount": 15.99,
    "message": "Promo code applied"
  }
}
```

Invalid response:
```json
{
  "data": {
    "valid": false,
    "code": "EXPIRED10",
    "message": "Promo code has expired"
  }
}
```

### Discount Calculation Logic

1. **PERCENTAGE**: `calculatedDiscount = orderTotal * (discountValue / 100)`, capped by `maxDiscountAmount` if set. If no `orderTotal` provided, `calculatedDiscount = null`.
2. **FIXED_AMOUNT**: `calculatedDiscount = discountValue`, capped at `orderTotal` if provided (can't discount more than the total).
3. Round to 2 decimal places.

### Validation Rules (service layer)

1. Code not found → invalid, "Promo code not found"
2. `!isActive` → invalid, "Promo code is not active"
3. `now < validFrom` → invalid, "Promo code is not yet valid"
4. `validUntil && now > validUntil` → invalid, "Promo code has expired"
5. `maxUses && currentUses >= maxUses` → invalid, "Promo code usage limit reached"
6. `minOrderAmount && orderTotal < minOrderAmount` → invalid, "Order total does not meet minimum amount of X"
7. All checks pass → valid, calculate discount

**Note:** `maxUsesPerUser` is NOT checked in validation (would need user context; deferred to checkout).

### Patterns to Follow

- **Errors:** Follow `AddressError.ts` pattern — base class + specific subclasses
- **Validator:** Follow `cartValidator.ts` pattern — input interfaces, private helpers, exported validate function
- **Service:** Follow `cartService.ts` pattern — Prisma query, typed result
- **Controller:** Follow `cartController.ts` pattern — thin handler, error mapping
- **Routes:** Follow `cartRoutes.ts` pattern — no auth middleware (public endpoint)
- **Code lookup:** Use `findUnique({ where: { code: normalizedCode } })` — code is unique index

---

## Implementation Plan

### Overview

The implementation follows the DDD layered architecture established by `cartService` / `cartController` / `cartRoutes`. The endpoint is public (`security: []`), returns HTTP 200 with a structured `{ valid, code, ... }` payload in all business-logic outcomes, and only returns HTTP 400 for input validation failures (malformed request). All steps follow the TDD Red-Green-Refactor cycle — tests are written first.

---

### Step 1: Prisma Schema + Migration

**File:** `backend/prisma/schema.prisma`

Add the `DiscountType` enum in the ENUMS section (after `UserRole`) and the `PromoCode` model in the MODELS section (at the end of the file, before or after `PriceHistory`).

**Enum to add (in the ENUMS section after `UserRole`):**

```prisma
enum DiscountType {
  PERCENTAGE
  FIXED_AMOUNT
}
```

**Model to add (at the end of MODELS section):**

```prisma
model PromoCode {
  id                String       @id @default(uuid())
  code              String       @unique @db.VarChar(50)
  description       String?
  discountType      DiscountType @map("discount_type")
  discountValue     Decimal      @map("discount_value") @db.Decimal(10, 2)
  minOrderAmount    Decimal?     @map("min_order_amount") @db.Decimal(10, 2)
  maxDiscountAmount Decimal?     @map("max_discount_amount") @db.Decimal(10, 2)
  maxUses           Int?         @map("max_uses")
  maxUsesPerUser    Int?         @map("max_uses_per_user")
  currentUses       Int          @default(0) @map("current_uses")
  validFrom         DateTime     @map("valid_from")
  validUntil        DateTime?    @map("valid_until")
  isActive          Boolean      @default(true) @map("is_active")
  createdByUserId   String       @map("created_by_user_id")
  createdAt         DateTime     @default(now()) @map("created_at")
  updatedAt         DateTime     @updatedAt @map("updated_at")

  // Relations
  createdBy User @relation("PromoCodeCreator", fields: [createdByUserId], references: [id])

  @@index([code])
  @@index([isActive])
  @@index([validUntil])
  @@map("promo_codes")
}
```

**Important notes:**
- The `User` model in `schema.prisma` currently has `createdProducts Product[] @relation("ProductCreator")`. You must also add the back-relation to `User`: `createdPromoCodes PromoCode[] @relation("PromoCodeCreator")`. Without this, Prisma will fail to generate the client.
- The `data-model.md` reference version includes `orders Order[]` on `PromoCode` — do NOT add this relation yet; the `Order` model is deferred to Sprint 5 and does not exist in `schema.prisma` yet.
- The `code` field is stored/looked up as uppercase (enforced at the application layer, not DB).

**Run migration and regenerate Prisma client:**

```bash
cd /Users/pb/Developer/FiveGuays/memes/backend && npx prisma migrate dev --name add-promo-code-model
```

**Checkpoint command:**

```bash
cd /Users/pb/Developer/FiveGuays/memes/backend && npx prisma validate && npx prisma generate
```

Expected: no errors from `prisma validate` and `prisma generate` completes successfully.

---

### Step 2: Domain Errors

**Files:**
- `backend/src/domain/errors/PromoCodeError.ts` (implementation)
- `backend/src/domain/errors/PromoCodeError.test.ts` (tests — write first)

#### Test file structure (`PromoCodeError.test.ts`)

Write tests that verify:

```
describe('PromoCodeError')
  describe('PromoCodeError (base)')
    - creates error with message and code
    - name is 'PromoCodeError'
    - instanceof Error
  describe('InvalidPromoCodeDataError')
    - message set, code is 'INVALID_PROMO_CODE_DATA'
    - name is 'InvalidPromoCodeDataError'
    - instanceof PromoCodeError
    - accepts optional field parameter
    - field is undefined when not provided
  describe('PromoCodeNotFoundError')
    - message is 'Promo code not found'
    - code is 'PROMO_CODE_NOT_FOUND'
    - name is 'PromoCodeNotFoundError'
    - instanceof PromoCodeError
  describe('PromoCodeExpiredError')
    - message is 'Promo code has expired'
    - code is 'PROMO_CODE_EXPIRED'
    - name is 'PromoCodeExpiredError'
    - instanceof PromoCodeError
  describe('PromoCodeInactiveError')
    - message is 'Promo code is not active'
    - code is 'PROMO_CODE_INACTIVE'
    - name is 'PromoCodeInactiveError'
    - instanceof PromoCodeError
  describe('PromoCodeUsageLimitError')
    - message is 'Promo code usage limit reached'
    - code is 'PROMO_CODE_USAGE_LIMIT'
    - name is 'PromoCodeUsageLimitError'
    - instanceof PromoCodeError
  describe('MinOrderAmountNotMetError')
    - constructor accepts minOrderAmount: number
    - message is 'Order total does not meet minimum amount of {minOrderAmount}'
    - code is 'MIN_ORDER_AMOUNT_NOT_MET'
    - name is 'MinOrderAmountNotMetError'
    - instanceof PromoCodeError
    - exposes minOrderAmount on the instance
  describe('PromoCodeNotYetValidError')
    - message is 'Promo code is not yet valid'
    - code is 'PROMO_CODE_NOT_YET_VALID'
    - name is 'PromoCodeNotYetValidError'
    - instanceof PromoCodeError
```

#### Implementation (`PromoCodeError.ts`)

Follow the exact same pattern as `AddressError.ts`. Each class:
1. Extends `PromoCodeError` (which extends `Error`)
2. Calls `super(message, code)` and sets `this.name`
3. Only `InvalidPromoCodeDataError` and `MinOrderAmountNotMetError` take constructor arguments

```typescript
export class PromoCodeError extends Error {
  constructor(message: string, public readonly code: string) {
    super(message);
    this.name = 'PromoCodeError';
  }
}

export class InvalidPromoCodeDataError extends PromoCodeError {
  constructor(message: string, public readonly field?: string) {
    super(message, 'INVALID_PROMO_CODE_DATA');
    this.name = 'InvalidPromoCodeDataError';
  }
}

export class PromoCodeNotFoundError extends PromoCodeError {
  constructor() {
    super('Promo code not found', 'PROMO_CODE_NOT_FOUND');
    this.name = 'PromoCodeNotFoundError';
  }
}

export class PromoCodeExpiredError extends PromoCodeError {
  constructor() {
    super('Promo code has expired', 'PROMO_CODE_EXPIRED');
    this.name = 'PromoCodeExpiredError';
  }
}

export class PromoCodeInactiveError extends PromoCodeError {
  constructor() {
    super('Promo code is not active', 'PROMO_CODE_INACTIVE');
    this.name = 'PromoCodeInactiveError';
  }
}

export class PromoCodeUsageLimitError extends PromoCodeError {
  constructor() {
    super('Promo code usage limit reached', 'PROMO_CODE_USAGE_LIMIT');
    this.name = 'PromoCodeUsageLimitError';
  }
}

export class MinOrderAmountNotMetError extends PromoCodeError {
  constructor(public readonly minOrderAmount: number) {
    super(
      `Order total does not meet minimum amount of ${minOrderAmount}`,
      'MIN_ORDER_AMOUNT_NOT_MET'
    );
    this.name = 'MinOrderAmountNotMetError';
  }
}

export class PromoCodeNotYetValidError extends PromoCodeError {
  constructor() {
    super('Promo code is not yet valid', 'PROMO_CODE_NOT_YET_VALID');
    this.name = 'PromoCodeNotYetValidError';
  }
}
```

**Note:** The domain errors are defined here for completeness in the domain layer, but the service does NOT throw these errors — instead the service returns a structured result (see Step 4). The errors may be useful in future admin endpoints.

**Checkpoint command:**

```bash
cd /Users/pb/Developer/FiveGuays/memes/backend && npx jest --testPathPatterns="PromoCodeError.test" --no-coverage
```

Expected: all tests pass.

---

### Step 3: Validator

**Files:**
- `backend/src/application/validators/promoCodeValidator.ts` (implementation)
- `backend/src/application/validators/promoCodeValidator.test.ts` (tests — write first)

#### Interfaces

```typescript
// Input (raw from req.body)
export interface PromoCodeValidationInput {
  code: unknown;
  orderTotal?: unknown;
}

// Validated output
export interface ValidatedPromoCodeInput {
  code: string;           // trimmed, uppercased
  orderTotal?: number;    // present only if provided; >= 0
}
```

#### Validation rules (enforced by `validatePromoCodeInput`)

1. `code` is required, must be a non-empty string after trim, max 50 characters. Normalize by `trim()` then `toUpperCase()`.
2. `orderTotal` is optional. If provided, must be a number (not NaN, not Infinity), and >= 0.
3. Throws `InvalidPromoCodeDataError` (with `field`) for any violation.

#### Constants

```typescript
const MAX_CODE_LENGTH = 50;
```

#### Private helpers

```typescript
function throwPromoCodeError(message: string, field: string): never
function validateCode(value: unknown): string       // returns trimmed + uppercased code
function validateOrderTotal(value: unknown): number  // returns number >= 0
```

#### Exported function signature

```typescript
export function validatePromoCodeInput(input: PromoCodeValidationInput): ValidatedPromoCodeInput
```

#### Test file structure (`promoCodeValidator.test.ts`)

```
describe('promoCodeValidator')
  describe('validatePromoCodeInput')
    describe('valid inputs')
      - accepts code as string, trims and uppercases it
      - accepts code without orderTotal
      - accepts code with valid orderTotal (positive number)
      - accepts orderTotal of 0 (edge case)
      - accepts orderTotal as decimal (e.g. 99.99)
      - does not include orderTotal in result when not provided
    describe('invalid code')
      - throws InvalidPromoCodeDataError when code is missing
      - throws with field='code' when code is missing
      - throws when code is null
      - throws when code is not a string
      - throws when code is empty string
      - throws when code is whitespace-only
      - throws when code exceeds 50 characters
    describe('invalid orderTotal')
      - throws when orderTotal is a string (not a number)
      - throws when orderTotal is negative
      - throws when orderTotal is NaN
      - throws with field='orderTotal'
```

**Checkpoint command:**

```bash
cd /Users/pb/Developer/FiveGuays/memes/backend && npx jest --testPathPatterns="promoCodeValidator.test" --no-coverage
```

Expected: all tests pass.

---

### Step 4: Service

**Files:**
- `backend/src/application/services/promoCodeService.ts` (implementation)
- `backend/src/application/services/promoCodeService.test.ts` (tests — write first)

#### Result type

The service returns a structured result (never throws for business logic failures, only throws for input validation errors via the validator):

```typescript
export interface PromoCodeValidationResult {
  valid: boolean;
  code: string;
  discountType?: 'PERCENTAGE' | 'FIXED_AMOUNT';
  discountValue?: number;
  calculatedDiscount?: number | null;   // null when valid but no orderTotal provided for PERCENTAGE
  message: string;
}
```

**Note:** `calculatedDiscount` is `null` (not omitted) when the code is valid and discount is PERCENTAGE but no `orderTotal` was provided. For FIXED_AMOUNT with no `orderTotal`, `calculatedDiscount` equals `discountValue` (no capping needed).

#### Exported function signature

```typescript
export async function validatePromoCode(
  input: PromoCodeValidationInput
): Promise<PromoCodeValidationResult>
```

Where `PromoCodeValidationInput` is imported from `promoCodeValidator.ts`.

#### Implementation details

1. Call `validatePromoCodeInput(input)` — throws `InvalidPromoCodeDataError` on invalid input (propagates to controller).
2. Look up code in DB: `prisma.promoCode.findUnique({ where: { code: validated.code } })`. The code is already uppercased by the validator, and DB stores it uppercase.
3. If not found: return `{ valid: false, code: validated.code, message: 'Promo code not found' }`.
4. Run the validation chain (each check returns early on failure):
   - `!promoCode.isActive` → `{ valid: false, code, message: 'Promo code is not active' }`
   - `now < promoCode.validFrom` → `{ valid: false, code, message: 'Promo code is not yet valid' }`
   - `promoCode.validUntil && now > promoCode.validUntil` → `{ valid: false, code, message: 'Promo code has expired' }`
   - `promoCode.maxUses !== null && promoCode.currentUses >= promoCode.maxUses` → `{ valid: false, code, message: 'Promo code usage limit reached' }`
   - `promoCode.minOrderAmount !== null && validated.orderTotal !== undefined && validated.orderTotal < Number(promoCode.minOrderAmount)` → `{ valid: false, code, message: \`Order total does not meet minimum amount of ${Number(promoCode.minOrderAmount)}\` }`
5. All checks pass → calculate discount and return success result.

#### Discount calculation

```
const discountValue = Number(promoCode.discountValue);
const maxDiscountAmount = promoCode.maxDiscountAmount ? Number(promoCode.maxDiscountAmount) : null;

if (promoCode.discountType === 'PERCENTAGE') {
  if (validated.orderTotal === undefined) {
    calculatedDiscount = null;
  } else {
    let calc = validated.orderTotal * (discountValue / 100);
    if (maxDiscountAmount !== null && calc > maxDiscountAmount) {
      calc = maxDiscountAmount;
    }
    calculatedDiscount = Math.round(calc * 100) / 100;
  }
} else {
  // FIXED_AMOUNT
  let calc = discountValue;
  if (validated.orderTotal !== undefined && calc > validated.orderTotal) {
    calc = validated.orderTotal;
  }
  calculatedDiscount = Math.round(calc * 100) / 100;
}
```

Return on success:
```typescript
{
  valid: true,
  code: promoCode.code,
  discountType: promoCode.discountType,
  discountValue: Number(promoCode.discountValue),
  calculatedDiscount,
  message: 'Promo code applied',
}
```

#### Test file structure (`promoCodeService.test.ts`)

Mock Prisma at the `promoCode.findUnique` level (same pattern as `cartService.test.ts` mocking `prisma.product.findMany`):

```typescript
jest.mock('../../lib/prisma', () => ({
  __esModule: true,
  default: {
    promoCode: {
      findUnique: jest.fn(),
    },
  },
}));
```

Use a `makePromoCode(overrides)` factory function for DRY test setup:

```typescript
function makePromoCode(overrides: Partial<...> = {}) {
  return {
    id: 'pc-uuid-1',
    code: 'SUMMER20',
    description: null,
    discountType: 'PERCENTAGE',
    discountValue: new Decimal('20.00'),
    minOrderAmount: null,
    maxDiscountAmount: null,
    maxUses: null,
    maxUsesPerUser: null,
    currentUses: 0,
    validFrom: new Date('2026-01-01'),
    validUntil: null,
    isActive: true,
    createdByUserId: 'user-uuid-1',
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides,
  };
}
```

**Note:** Prisma returns `Decimal` objects for `Decimal` fields. Use `new Decimal('20.00')` from `@prisma/client/runtime/library` or the generated Prisma client. Alternatively, use plain numbers in the mock and cast — check how `cartService.test.ts` handles `price: 29.99` (it uses plain numbers). Do the same: use plain numbers/strings for Decimal fields in mocks and call `Number(field)` in the service.

Test groups:

```
describe('promoCodeService')
  describe('validatePromoCode')
    describe('input validation failures')
      - throws InvalidPromoCodeDataError when code is missing
      - throws InvalidPromoCodeDataError when code is empty string
      - throws InvalidPromoCodeDataError when orderTotal is negative
      (these test that the validator is called and errors propagate)

    describe('code not found')
      - findUnique returns null → valid=false, message='Promo code not found'
      - does not include discountType/discountValue in result
      - findUnique called with { where: { code: 'SUMMER20' } } (uppercase)

    describe('code inactive')
      - isActive=false → valid=false, message='Promo code is not active'

    describe('not yet valid')
      - validFrom in the future → valid=false, message='Promo code is not yet valid'

    describe('expired')
      - validUntil in the past → valid=false, message='Promo code has expired'
      - validUntil=null → not expired (passes this check)

    describe('usage limit reached')
      - maxUses=10, currentUses=10 → valid=false, message='Promo code usage limit reached'
      - maxUses=10, currentUses=9 → passes this check
      - maxUses=null → passes (unlimited)

    describe('minimum order amount not met')
      - minOrderAmount=50, orderTotal=30 → valid=false, message='Order total does not meet minimum amount of 50'
      - minOrderAmount=50, orderTotal=50 → passes (equal is OK, check is strict less-than)
      - minOrderAmount=50, orderTotal not provided → passes (no orderTotal = skip this check)
      - minOrderAmount=null → passes regardless of orderTotal

    describe('PERCENTAGE discount calculation')
      - 20% off 100.00 = 20.00 calculatedDiscount
      - 20% off 79.99 = 15.998 → rounds to 16.00
      - 20% off 100.00 with maxDiscountAmount=15 → calculatedDiscount=15 (capped)
      - no orderTotal → calculatedDiscount=null
      - returns valid=true with correct discountType, discountValue, message='Promo code applied'

    describe('FIXED_AMOUNT discount calculation')
      - fixed 10.00, orderTotal=50 → calculatedDiscount=10.00
      - fixed 10.00, no orderTotal → calculatedDiscount=10.00 (no capping)
      - fixed 10.00, orderTotal=5 → calculatedDiscount=5.00 (capped at orderTotal)
      - returns valid=true with correct discountType, discountValue

    describe('case normalization')
      - lowercase input 'summer20' → findUnique called with 'SUMMER20'
      - returned code in result matches DB code (not the input case)
```

**Checkpoint command:**

```bash
cd /Users/pb/Developer/FiveGuays/memes/backend && npx jest --testPathPatterns="promoCodeService.test" --no-coverage
```

Expected: all tests pass.

---

### Step 5: Controller

**Files:**
- `backend/src/presentation/controllers/promoCodeController.ts` (implementation)
- `backend/src/presentation/controllers/promoCodeController.test.ts` (tests — write first)

#### Implementation

Follows `cartController.ts` exactly. Thin handler that:
1. Calls `promoCodeService.validatePromoCode(req.body)`
2. On success: `success(res, result)` → HTTP 200 with `{ success: true, data: { valid, code, ... } }`
3. On `InvalidPromoCodeDataError`: HTTP 400 with `{ success: false, error: { message, code, field? } }`
4. On any other error: `next(error)`

```typescript
import { Request, Response, NextFunction } from 'express';
import * as promoCodeService from '../../application/services/promoCodeService';
import { InvalidPromoCodeDataError } from '../../domain/errors/PromoCodeError';
import { success } from '../../utils/responseHelpers';

export async function validatePromoCode(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    const result = await promoCodeService.validatePromoCode(req.body);
    success(res, result);
  } catch (error) {
    handlePromoCodeError(error, res, next);
  }
}

function handlePromoCodeError(error: unknown, res: Response, next: NextFunction): void {
  if (error instanceof InvalidPromoCodeDataError) {
    res.status(400).json({
      success: false,
      error: {
        message: error.message,
        code: error.code,
        field: error.field,
      },
    });
    return;
  }
  next(error);
}
```

#### Test file structure (`promoCodeController.test.ts`)

Mock the service module:

```typescript
jest.mock('../../application/services/promoCodeService');
const mockPromoCodeService = promoCodeService as jest.Mocked<typeof promoCodeService>;
```

Mock request/response/next using the same pattern as `cartController.test.ts`.

```
describe('promoCodeController')
  describe('validatePromoCode')
    - returns 200 with success=true and result when code is valid
    - returns 200 with success=true and valid=false when code is invalid (business rule)
    - calls promoCodeService.validatePromoCode with req.body
    - returns 400 when InvalidPromoCodeDataError is thrown (code is 'INVALID_PROMO_CODE_DATA')
    - returns 400 with field when InvalidPromoCodeDataError has field
    - returns 400 with undefined field when InvalidPromoCodeDataError has no field
    - calls next(error) for unexpected errors
    - does not call statusMock when unexpected error occurs
```

**Checkpoint command:**

```bash
cd /Users/pb/Developer/FiveGuays/memes/backend && npx jest --testPathPatterns="promoCodeController.test" --no-coverage
```

Expected: all tests pass.

---

### Step 6: Routes + Registration

#### Route file

**File:** `backend/src/routes/promoCodeRoutes.ts`

```typescript
import { Router } from 'express';
import { validatePromoCode } from '../presentation/controllers/promoCodeController';

const router = Router();

// Public endpoint — no authMiddleware required
router.post('/validate', validatePromoCode);

export default router;
```

#### Modify `index.ts`

**File:** `backend/src/routes/index.ts`

Add the import and mount:

```typescript
import promoCodeRoutes from './promoCodeRoutes';
// ...
router.use('/promo-codes', promoCodeRoutes);
```

Place the `promo-codes` route after the `cart` route registration for consistency.

No separate checkpoint needed for this step — it will be verified in Step 7 integration tests.

---

### Step 7: Integration Tests

**File:** `backend/src/routes/promoCodeRoutes.integration.test.ts`

#### Mock strategy

Unlike `cartRoutes.integration.test.ts` which mocks Prisma directly (because `cartService` calls Prisma), this integration test should also mock Prisma directly at the `promoCode.findUnique` level — consistent with the cart integration test pattern. This tests the full stack from HTTP request down to the Prisma boundary.

```typescript
jest.mock('../lib/prisma', () => ({
  __esModule: true,
  default: {
    promoCode: {
      findUnique: jest.fn(),
    },
  },
}));

jest.mock('../application/services/tokenService', () => ({
  generateAccessToken: jest.fn(),
  generateRefreshToken: jest.fn(),
  verifyAccessToken: jest.fn(),
  refreshTokens: jest.fn(),
}));
```

Use `createTestApp()` pattern identical to `cartRoutes.integration.test.ts`, using `require('./index').default` to load all routes.

Use a `makePromoCode(overrides?)` factory (same as in service tests, with plain numbers for Decimal fields).

#### Test groups

```
describe('Promo Code Routes Integration')
  describe('POST /promo-codes/validate')
    describe('success — valid code')
      - returns 200 with valid=true and discountType/discountValue for valid PERCENTAGE code
      - returns 200 with valid=true for valid FIXED_AMOUNT code
      - returns calculatedDiscount when orderTotal is provided
      - returns calculatedDiscount=null for PERCENTAGE when no orderTotal
      - is accessible without Authorization header (public endpoint)

    describe('success — invalid code (business rules, still HTTP 200)')
      - returns 200 with valid=false when findUnique returns null (not found)
      - returns 200 with valid=false when code is inactive
      - returns 200 with valid=false when code is expired (validUntil in past)
      - returns 200 with valid=false when code not yet valid (validFrom in future)
      - returns 200 with valid=false when usage limit reached
      - returns 200 with valid=false when order total below minimum

    describe('input validation — returns 400')
      - returns 400 when code is missing from body
      - returns 400 when code is empty string
      - returns 400 when code is not a string (e.g. number)
      - returns 400 when orderTotal is negative
      - returns 400 with error.code='INVALID_PROMO_CODE_DATA'
      - returns 400 with error.field='code' when code is invalid

    describe('response shape')
      - valid response includes: valid, code, discountType, discountValue, calculatedDiscount, message
      - invalid response includes: valid=false, code, message (no discountType/discountValue)
```

**Note on response shape for invalid codes:** The ticket specifies the invalid response as `{ valid: false, code, message }` without `discountType`/`discountValue`. The service implementation should NOT include those fields in the returned object when `valid: false`. Use early returns in the service to ensure this.

**Checkpoint command:**

```bash
cd /Users/pb/Developer/FiveGuays/memes/backend && npx jest --testPathPatterns="promoCodeRoutes.integration" --no-coverage
```

Expected: all tests pass.

---

### Step 8: Final Verification

Run the full test suite, lint, and build to confirm no regressions:

```bash
cd /Users/pb/Developer/FiveGuays/memes/backend && npx jest --no-coverage
```

```bash
cd /Users/pb/Developer/FiveGuays/memes/backend && npm run lint
```

```bash
cd /Users/pb/Developer/FiveGuays/memes/backend && npm run build
```

Expected: all tests pass, no lint errors, build succeeds.

---

### File Summary

| File | Action | Purpose |
|------|--------|---------|
| `backend/prisma/schema.prisma` | Modify | Add `DiscountType` enum, `PromoCode` model, `createdPromoCodes` back-relation on `User` |
| `backend/prisma/migrations/*/migration.sql` | Auto-generated | Migration SQL for `promo_codes` table |
| `backend/src/domain/errors/PromoCodeError.ts` | Create | 8 error classes: base + 7 specific |
| `backend/src/domain/errors/PromoCodeError.test.ts` | Create | Unit tests for all error classes |
| `backend/src/application/validators/promoCodeValidator.ts` | Create | `validatePromoCodeInput` — trims/uppercases code, validates orderTotal |
| `backend/src/application/validators/promoCodeValidator.test.ts` | Create | Unit tests for validator |
| `backend/src/application/services/promoCodeService.ts` | Create | `validatePromoCode` — DB lookup, 6 validation rules, discount calculation |
| `backend/src/application/services/promoCodeService.test.ts` | Create | Unit tests with mocked `prisma.promoCode.findUnique` |
| `backend/src/presentation/controllers/promoCodeController.ts` | Create | Thin handler: calls service, maps `InvalidPromoCodeDataError` → 400 |
| `backend/src/presentation/controllers/promoCodeController.test.ts` | Create | Unit tests with mocked service |
| `backend/src/routes/promoCodeRoutes.ts` | Create | `POST /validate` route, no auth middleware |
| `backend/src/routes/promoCodeRoutes.integration.test.ts` | Create | Integration tests with mocked Prisma |
| `backend/src/routes/index.ts` | Modify | Register `promoCodeRoutes` at `/promo-codes` |

### Key Implementation Notes

1. **No `Order[]` relation on `PromoCode`** — the `Order` model does not exist in `schema.prisma` yet (deferred to Sprint 5). Only add the `createdBy User` relation and the corresponding `createdPromoCodes PromoCode[]` back-relation on `User`.

2. **Service returns structured result, never throws for business failures** — this is the same pattern as `cartService.validateCart`. The controller only needs to handle `InvalidPromoCodeDataError` (from the validator) and unexpected errors.

3. **Code normalization** — the validator must `trim()` and `toUpperCase()` the code before returning. This ensures the DB lookup (`findUnique({ where: { code } })`) always uses the canonical form.

4. **`calculatedDiscount` for PERCENTAGE without `orderTotal`** — return `null` (not `undefined`) so the field appears in the JSON response. For FIXED_AMOUNT without `orderTotal`, return the raw `discountValue` (no capping needed since there is no total to cap against).

5. **Decimal fields from Prisma** — Prisma returns `Decimal` objects for `Decimal` fields. Always call `Number(promoCode.discountValue)`, `Number(promoCode.minOrderAmount)`, etc. before arithmetic.

6. **`minOrderAmount` check ordering** — the check only fires when BOTH `minOrderAmount` is set AND `orderTotal` is provided. If no `orderTotal` is provided, skip the minimum amount check (the caller cannot know the final total at validation time).

7. **HTTP 200 for all business-logic invalid outcomes** — consistent with `POST /cart/validate`. The endpoint always returns 200 unless the request itself is malformed (400). The `valid` flag in the response body distinguishes success from failure.

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing
- [x] Integration tests written and passing
- [x] Code follows project standards (DDD layers, TypeScript strict, English only)
- [x] No linting errors
- [x] Build succeeds
- [x] Migration created and applied

---

*Ticket created: 2026-02-19*
