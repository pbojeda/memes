# F3.7: Implement Reviews Display Component

**Sprint:** 3
**Type:** Frontend - Feature
**Priority:** Medium
**Status:** In Progress
**Branch:** feature/sprint3-F3.7-reviews-display
**Created:** 2026-02-16
**Dependencies:** None (unblocks F3.5 — product detail page)

---

## Description

Implement a reusable reviews display component for the product detail page. The component fetches and displays product reviews with star ratings, author info, date formatting, and pagination. It also shows a summary section with average rating, rating distribution (bar chart), and total review count.

This is a **client component** (`'use client'`) since it manages its own data fetching and pagination state.

The component will be used by F3.5 (product detail page) which passes a `productId` to fetch reviews from `GET /products/{productId}/reviews`.

---

## Acceptance Criteria

- [x] `ReviewSummary` sub-component displays average rating (large number + stars), total review count, and rating distribution bar chart (5→1)
- [x] `ReviewCard` sub-component displays author name, star rating (filled/empty stars), comment text, and relative date (e.g., "2 days ago")
- [x] `ReviewList` main component fetches reviews via `reviewService.list(productId, params)` and renders `ReviewSummary` + paginated `ReviewCard` list
- [x] Pagination uses the existing `Pagination` UI component, updates page state
- [x] Empty state shown when no reviews exist (e.g., "No reviews yet")
- [x] Loading state with skeleton placeholders while fetching
- [x] `reviewService` created in `lib/services/reviewService.ts` following existing service pattern
- [x] Test fixtures: `createReview`, `createReviews`, `createReviewListResponse` added to `components/product/testing/fixtures.ts`
- [x] Unit tests for all components and service
- [x] All tests pass (407 total)
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `components/product/ReviewCard.tsx` | Single review display (author, stars, comment, date) |
| `components/product/ReviewCard.test.tsx` | Tests for ReviewCard |
| `components/product/ReviewSummary.tsx` | Average rating, distribution bars, total count |
| `components/product/ReviewSummary.test.tsx` | Tests for ReviewSummary |
| `components/product/ReviewList.tsx` | Main component: fetches reviews, renders summary + paginated cards |
| `components/product/ReviewList.test.tsx` | Tests for ReviewList |
| `components/product/index.ts` | Export new components |
| `lib/services/reviewService.ts` | API service for fetching reviews |
| `lib/services/reviewService.test.ts` | Tests for reviewService |
| `lib/services/index.ts` | Export reviewService |
| `components/product/testing/fixtures.ts` | Add review test fixtures |

---

## Technical Notes

### API Schema (from `api-spec.yaml`)

**Endpoint:** `GET /products/{productId}/reviews?page=&limit=`

**Review type:**
```typescript
type Review = {
  id?: string;          // uuid
  authorName?: string;
  rating?: number;      // 1-5
  comment?: string;
  isAiGenerated?: boolean;
  isVisible?: boolean;
  createdAt?: string;   // ISO date-time
};
```

**ReviewListResponse:**
```typescript
type ReviewListResponse = {
  data?: Review[];
  meta?: PaginationMeta & {
    averageRating?: number;
    ratingDistribution?: { 1?: number; 2?: number; 3?: number; 4?: number; 5?: number };
  };
};
```

### Patterns to Follow

- **Types:** `import type { components } from '@/lib/api/types'`
- **Stars:** Reuse `Star` icon from `lucide-react` (already used in `ProductCard`)
- **Date formatting:** Use `Intl.RelativeTimeFormat` or a simple relative date utility
- **Service pattern:** Follow `productService.ts` — `apiClient.get<T>()`, strip undefined params
- **Test mocks:** Mock `@/lib/api/client` for service tests; mock service for component tests
- **Component location:** `components/product/` directory per established convention
- **Skeleton:** Use simple `div` with `animate-pulse bg-muted` (Tailwind) for loading states

### Design Details

- **ReviewSummary:** Average rating as large number (e.g., "4.5") with filled stars, total count text, 5 horizontal bars for rating distribution (percentage width), each labeled "5★", "4★", etc.
- **ReviewCard:** Author name bold, star row, comment text, relative date in muted text
- **ReviewList:** Summary on top, then review cards in a list, pagination at bottom

---

## Implementation Plan

### Existing Code to Reuse

**Components & UI:**
- `Star` icon from `lucide-react` (already used in ProductCard for rating display)
- `Card`, `CardContent` from `@/components/ui/card` (product card pattern)
- `Alert`, `AlertTitle`, `AlertDescription` from `@/components/ui/alert` (error states)
- `Pagination` from `@/components/ui/pagination` (page navigation, already handles totalPages <= 1)
- `cn()` from `@/lib/utils` (className merging)
- Mock patterns for `next/link`, `next/image`, `lucide-react` from ProductCard.test.tsx
- Skeleton pattern: `animate-pulse bg-muted` (from ProductGrid)

**Services & Types:**
- `apiClient.get<T>()` from `@/lib/api/client`
- Type imports: `import type { components, operations } from '@/lib/api/types'`
- Service pattern from `productService.ts`: strip undefined params with `Object.fromEntries(Object.entries(params).filter(([, v]) => v !== undefined))`
- Service test mocking: `jest.mock('@/lib/api/client')` with `mockApiClient.get.mockResolvedValueOnce()`

**Test Fixtures:**
- Fixture factory pattern from `components/product/testing/fixtures.ts`: `createX(overrides)`, `createXs(count)`

### Files to Create

| File | Type | Description |
|------|------|-------------|
| `frontend/lib/services/reviewService.ts` | Service | API client for fetching reviews from `GET /products/{productId}/reviews` |
| `frontend/lib/services/reviewService.test.ts` | Test | Unit tests for reviewService (5-6 test cases) |
| `frontend/components/product/ReviewCard.tsx` | Component | Presentational component for single review (author, stars, comment, date) |
| `frontend/components/product/ReviewCard.test.tsx` | Test | Unit tests for ReviewCard (8-10 test cases) |
| `frontend/components/product/ReviewSummary.tsx` | Component | Presentational component for aggregate stats (avg rating, distribution bars, count) |
| `frontend/components/product/ReviewSummary.test.tsx` | Test | Unit tests for ReviewSummary (7-9 test cases) |
| `frontend/components/product/ReviewList.tsx` | Component | Client component that fetches reviews and renders summary + paginated cards |
| `frontend/components/product/ReviewList.test.tsx` | Test | Unit tests for ReviewList (7-9 test cases) |

### Files to Modify

| File | Changes |
|------|---------|
| `frontend/components/product/testing/fixtures.ts` | Add `createReview()`, `createReviews()`, `createReviewListResponse()` fixtures |
| `frontend/components/product/index.ts` | Export `ReviewCard`, `ReviewSummary`, `ReviewList` |
| `frontend/lib/services/index.ts` | Export `reviewService` |

### Implementation Order (TDD Bottom-Up)

#### Step 1: Test Fixtures (Validation via later tests)

**File:** `frontend/components/product/testing/fixtures.ts`

**Add type imports:**
```typescript
type Review = components['schemas']['Review'];
type ReviewListResponse = components['schemas']['ReviewListResponse'];
```

**Add three factory functions:**

1. **`createReview(overrides?: Partial<Review>): Review`**
   - Default values:
     - `id`: `'rev-1'`
     - `authorName`: `'John Doe'`
     - `rating`: `4`
     - `comment`: `'Great product! Very satisfied with my purchase.'`
     - `isAiGenerated`: `false`
     - `isVisible`: `true`
     - `createdAt`: `'2026-02-10T12:00:00Z'` (6 days ago from 2026-02-16)
   - Merge `overrides` (same pattern as `createProduct`)

2. **`createReviews(count: number): Review[]`**
   - Generate `count` reviews with unique data:
     - `id`: `rev-${i+1}`
     - `authorName`: `User ${i+1}`
     - `rating`: Cycle through 5,4,3,2,1 using `(5 - (i % 5))`
     - `comment`: `Comment from user ${i+1}`
     - `createdAt`: Decrement by 1 day per review (e.g., `2026-02-10`, `2026-02-09`, ...)
   - Use `Array.from({ length: count }, (_, i) => ...)`

3. **`createReviewListResponse(overrides?: Partial<ReviewListResponse>): ReviewListResponse`**
   - Default structure:
     - `data`: `createReviews(3)` (3 reviews: ratings 5,4,3)
     - `meta`:
       - Pagination: `{ total: 3, page: 1, limit: 10, totalPages: 1 }`
       - `averageRating`: `4.0` (calculated from 5+4+3 / 3)
       - `ratingDistribution`: `{ 5: 1, 4: 1, 3: 1, 2: 0, 1: 0 }`
   - Merge `overrides`

**Validation:** These fixtures will be validated when used in component/service tests.

---

#### Step 2: reviewService + Tests (TDD)

**Files:** `frontend/lib/services/reviewService.test.ts` → `reviewService.ts`

**Test file structure:**
```typescript
import { reviewService } from './reviewService';
import { apiClient } from '../api/client';
import { ApiException } from '../api/exceptions';
import { createReview, createReviewListResponse } from '@/components/product/testing/fixtures';

jest.mock('../api/client', () => ({
  apiClient: {
    get: jest.fn(),
  },
}));

const mockApiClient = apiClient as jest.Mocked<typeof apiClient>;

describe('reviewService', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('list', () => {
    // Test cases below
  });
});
```

**Test cases (describe 'list'):**

1. **"should call GET /products/{productId}/reviews with empty params when none provided"**
   - Setup: `mockApiClient.get.mockResolvedValueOnce({ data: createReviewListResponse() })`
   - Call: `await reviewService.list('prod-123')`
   - Assert: `mockApiClient.get` called with `('/products/prod-123/reviews', { params: {} })`
   - Assert: Result matches fixture

2. **"should pass page and limit params as query parameters"**
   - Setup: Mock with `{ page: 2, limit: 5 }` in params
   - Call: `await reviewService.list('prod-123', { page: 2, limit: 5 })`
   - Assert: Called with `('/products/prod-123/reviews', { params: { page: 2, limit: 5 } })`

3. **"should return empty data with meta when no reviews"**
   - Setup: Mock returns `{ data: [], meta: { total: 0, page: 1, limit: 10, totalPages: 0, averageRating: 0, ratingDistribution: {...} } }`
   - Call: `await reviewService.list('prod-456')`
   - Assert: `result.data === []`, `result.meta.total === 0`

4. **"should propagate errors on network failure"**
   - Setup: `mockApiClient.get.mockRejectedValueOnce(new ApiException('NETWORK_ERROR', 'Unable to connect', 0))`
   - Assert: `await expect(reviewService.list('prod-123')).rejects.toThrow(ApiException)`

5. **"should omit undefined params from the request"**
   - Setup: Call with `{ page: 2, limit: undefined }`
   - Assert: `mockApiClient.get` called with `{ params: { page: 2 } }` (no `limit`)

6. **"should include averageRating and ratingDistribution in meta"**
   - Setup: Mock returns meta with `averageRating: 4.5`, `ratingDistribution: { 5: 10, 4: 5, ... }`
   - Call: `await reviewService.list('prod-123')`
   - Assert: `result.meta?.averageRating === 4.5`, distribution exists

**Implementation file (`reviewService.ts`):**
```typescript
import { apiClient } from '../api/client';
import type { components, operations } from '../api/types';

type ReviewListResponse = components['schemas']['ReviewListResponse'];
type ListReviewsParams = operations['listProductReviews']['parameters']['query'];

export const reviewService = {
  async list(productId: string, params?: ListReviewsParams): Promise<ReviewListResponse> {
    const cleanParams = params
      ? Object.fromEntries(Object.entries(params).filter(([, v]) => v !== undefined))
      : {};

    const response = await apiClient.get<ReviewListResponse>(
      `/products/${productId}/reviews`,
      { params: cleanParams }
    );

    return response.data;
  },
};
```

---

#### Step 3: ReviewCard + Tests (TDD)

**Files:** `frontend/components/product/ReviewCard.test.tsx` → `ReviewCard.tsx`

**Props interface:**
```typescript
interface ReviewCardProps {
  review: Review;
  className?: string;
}
```

**Key rendering logic:**
- **Author:** `<p className="font-semibold">{review.authorName}</p>`
- **Stars:** Render 5 `<Star />` icons, fill based on `rating` (e.g., rating=3 → fill first 3, outline last 2)
  - Use `className="h-4 w-4"` + conditional `fill-yellow-400 text-yellow-400` vs `text-muted-foreground`
- **Comment:** `<p className="text-sm text-muted-foreground">{review.comment}</p>`
- **Date:** `<p className="text-xs text-muted-foreground">{formatRelativeDate(review.createdAt)}</p>`
- **Wrapper:** Use `Card` or simple `div` with border/padding

**Date formatting helper (co-located in ReviewCard.tsx):**
```typescript
function formatRelativeDate(isoDate?: string): string {
  if (!isoDate) return '';

  const date = new Date(isoDate);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

  const rtf = new Intl.RelativeTimeFormat('en', { numeric: 'auto' });

  if (diffDays === 0) return rtf.format(0, 'day'); // "today"
  if (diffDays < 30) return rtf.format(-diffDays, 'day'); // "5 days ago"

  const diffMonths = Math.floor(diffDays / 30);
  if (diffMonths < 12) return rtf.format(-diffMonths, 'month'); // "2 months ago"

  const diffYears = Math.floor(diffMonths / 12);
  return rtf.format(-diffYears, 'year'); // "1 year ago"
}
```

**Test cases:**

1. **"should render author name"**
   - Render: `<ReviewCard review={createReview({ authorName: 'Jane Smith' })} />`
   - Assert: `screen.getByText('Jane Smith')` exists

2. **"should render 5 filled stars when rating is 5"**
   - Render: `<ReviewCard review={createReview({ rating: 5 })} />`
   - Assert: `screen.getAllByTestId('star-icon')` has length 5, all have `fill-yellow-400`

3. **"should render 3 filled and 2 empty stars when rating is 3"**
   - Render: `<ReviewCard review={createReview({ rating: 3 })} />`
   - Assert: First 3 stars have `fill-yellow-400`, last 2 don't

4. **"should render 0 filled stars when rating is 0 or undefined"**
   - Render: `<ReviewCard review={createReview({ rating: 0 })} />`
   - Assert: All 5 stars have `text-muted-foreground`, none have `fill-yellow-400`

5. **"should render comment text"**
   - Render: `<ReviewCard review={createReview({ comment: 'Amazing quality!' })} />`
   - Assert: `screen.getByText('Amazing quality!')` exists

6. **"should render relative date (e.g., '6 days ago')"**
   - Mock `Date.now()` to return `2026-02-16T00:00:00Z`
   - Render: `<ReviewCard review={createReview({ createdAt: '2026-02-10T12:00:00Z' })} />`
   - Assert: `screen.getByText(/6 days ago/i)` exists

7. **"should handle undefined createdAt gracefully (show empty string)"**
   - Render: `<ReviewCard review={createReview({ createdAt: undefined })} />`
   - Assert: Date element is empty or not rendered

8. **"should handle undefined comment gracefully"**
   - Render: `<ReviewCard review={createReview({ comment: undefined })} />`
   - Assert: Comment section is empty or not rendered

9. **"should apply custom className to root element"**
   - Render: `<ReviewCard review={createReview()} className="custom-class" />`
   - Assert: Root element has `custom-class`

**Mock setup (same as ProductCard.test.tsx):**
```typescript
jest.mock('lucide-react', () => ({
  Star: (props: Record<string, unknown>) => <svg data-testid="star-icon" {...props} />,
}));
```

---

#### Step 4: ReviewSummary + Tests (TDD)

**Files:** `frontend/components/product/ReviewSummary.test.tsx` → `ReviewSummary.tsx`

**Props interface:**
```typescript
interface ReviewSummaryProps {
  averageRating: number;
  totalReviews: number;
  ratingDistribution: Record<number, number>; // { 1: 0, 2: 1, 3: 0, 4: 1, 5: 1 }
  className?: string;
}
```

**Key rendering logic:**

1. **Average rating section:**
   - Large number: `<span className="text-4xl font-bold">{averageRating.toFixed(1)}</span>`
   - Star row: Render 5 stars, filled based on `Math.round(averageRating)` (e.g., 4.5 → 5 filled, 4.3 → 4 filled)

2. **Total count:**
   - `<p className="text-sm text-muted-foreground">Based on {totalReviews} review{totalReviews !== 1 ? 's' : ''}</p>`

3. **Distribution bars (5 → 1 order):**
   - For each rating 5, 4, 3, 2, 1:
     - Label: `<span className="text-sm">{rating}★</span>`
     - Bar: `<div className="flex-1 h-2 bg-muted"><div className="h-full bg-yellow-400" style={{ width: `${percentage}%` }} /></div>`
     - Count: `<span className="text-xs text-muted-foreground">{count}</span>`
   - Calculate percentage: `(count / totalReviews) * 100` (handle totalReviews=0 case)

**Test cases:**

1. **"should display average rating as fixed decimal (e.g., '4.5')"**
   - Render: `<ReviewSummary averageRating={4.5} totalReviews={10} ratingDistribution={{5:5, 4:5, 3:0, 2:0, 1:0}} />`
   - Assert: `screen.getByText('4.5')` exists

2. **"should render 5 filled stars when average is 5.0"**
   - Render: `<ReviewSummary averageRating={5.0} ... />`
   - Assert: 5 stars with `fill-yellow-400`

3. **"should render 4 filled stars when average is 4.3 (rounded)"**
   - Render: `<ReviewSummary averageRating={4.3} ... />`
   - Assert: 4 filled stars (based on `Math.round(4.3) = 4`)

4. **"should display singular 'review' when totalReviews is 1"**
   - Render: `<ReviewSummary averageRating={5} totalReviews={1} ... />`
   - Assert: `screen.getByText(/1 review[^s]/)` (not "reviews")

5. **"should display plural 'reviews' when totalReviews > 1"**
   - Render: `<ReviewSummary totalReviews={12} ... />`
   - Assert: `screen.getByText(/12 reviews/)` exists

6. **"should render 5 distribution bars in descending order (5★ to 1★)"**
   - Render with distribution `{5:10, 4:5, 3:2, 2:1, 1:0}`
   - Assert: 5 rows with labels "5★", "4★", "3★", "2★", "1★" in that order

7. **"should calculate bar widths proportional to counts (e.g., 50% for 5/10)"**
   - Render: `totalReviews={10}`, `ratingDistribution={{5:5, 4:3, 3:2, 2:0, 1:0}}`
   - Assert: 5★ bar has `width: 50%`, 4★ has `width: 30%`, 3★ has `width: 20%`

8. **"should handle zero totalReviews without division by zero"**
   - Render: `totalReviews={0}`, `ratingDistribution={{5:0, 4:0, 3:0, 2:0, 1:0}}`
   - Assert: All bars have `width: 0%`, displays "0 reviews"

9. **"should handle missing distribution keys with default 0"**
   - Render: `ratingDistribution={{5:1}}` (missing 4,3,2,1)
   - Assert: Bars for 4★-1★ show count=0, width=0%

10. **"should apply custom className to root element"**
    - Assert: Root div has `custom-class`

---

#### Step 5: ReviewList + Tests (Client Component, TDD)

**Files:** `frontend/components/product/ReviewList.test.tsx` → `ReviewList.tsx`

**Props interface:**
```typescript
interface ReviewListProps {
  productId: string;
  className?: string;
}
```

**Component structure:**
```typescript
'use client';

import { useState, useEffect } from 'react';
import { reviewService } from '@/lib/services/reviewService';
import { ReviewSummary } from './ReviewSummary';
import { ReviewCard } from './ReviewCard';
import { Pagination } from '@/components/ui/pagination';
import { Alert, AlertTitle, AlertDescription } from '@/components/ui/alert';
import { cn } from '@/lib/utils';

export function ReviewList({ productId, className }: ReviewListProps) {
  const [page, setPage] = useState(1);
  const [reviewData, setReviewData] = useState<ReviewListResponse | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    // Fetch reviews
    const fetchReviews = async () => {
      setLoading(true);
      setError(null);
      try {
        const data = await reviewService.list(productId, { page, limit: 5 });
        setReviewData(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load reviews');
      } finally {
        setLoading(false);
      }
    };
    fetchReviews();
  }, [productId, page]);

  // Render states: loading, error, empty, populated
}
```

**Render states:**

1. **Loading:** 3 skeleton cards with `animate-pulse bg-muted`, `role="status"`, sr-only text "Loading reviews..."
2. **Error:** `<Alert variant="destructive"><AlertTitle>Error</AlertTitle><AlertDescription>{error}</AlertDescription></Alert>`
3. **Empty:** `<div className="text-center text-muted-foreground">No reviews yet</div>`
4. **Populated:**
   - `<ReviewSummary averageRating={meta.averageRating} totalReviews={meta.total} ratingDistribution={meta.ratingDistribution} />`
   - Map `reviewData.data` to `<ReviewCard key={review.id} review={review} />`
   - `<Pagination currentPage={page} totalPages={meta.totalPages} onPageChange={setPage} />` (only if totalPages > 1)

**Test cases:**

**Mock setup:**
```typescript
import { reviewService } from '@/lib/services/reviewService';
import { createReviewListResponse, createReview } from './testing/fixtures';

jest.mock('@/lib/services/reviewService', () => ({
  reviewService: {
    list: jest.fn(),
  },
}));

const mockReviewService = reviewService as jest.Mocked<typeof reviewService>;
```

1. **"should show loading skeleton initially"**
   - Setup: `mockReviewService.list.mockImplementation(() => new Promise(() => {}))` (never resolves)
   - Render: `<ReviewList productId="prod-123" />`
   - Assert: `screen.getByRole('status')` exists, `screen.getByText(/loading reviews/i)` (sr-only)

2. **"should display empty state when no reviews"**
   - Setup: `mockReviewService.list.mockResolvedValueOnce({ data: [], meta: { total: 0, page: 1, limit: 5, totalPages: 0, averageRating: 0, ratingDistribution: {...} } })`
   - Render, wait for load
   - Assert: `screen.getByText(/no reviews yet/i)` exists

3. **"should render ReviewSummary with correct props when reviews exist"**
   - Setup: `mockReviewService.list.mockResolvedValueOnce(createReviewListResponse())`
   - Render, wait
   - Assert: Summary displays average "4.0", "3 reviews", distribution bars

4. **"should render ReviewCard for each review"**
   - Setup: Mock returns 3 reviews
   - Assert: 3 ReviewCards rendered with correct author names

5. **"should call reviewService.list with productId and pagination params"**
   - Setup: Mock resolves with fixture
   - Render: `<ReviewList productId="prod-456" />`
   - Assert: `reviewService.list` called with `('prod-456', { page: 1, limit: 5 })`

6. **"should show Pagination when totalPages > 1"**
   - Setup: Mock returns `meta: { totalPages: 3, page: 1, ... }`
   - Assert: Pagination component exists

7. **"should hide Pagination when totalPages <= 1"**
   - Setup: Mock returns `meta: { totalPages: 1, ... }`
   - Assert: Pagination component not rendered

8. **"should update page state and refetch when pagination clicked"**
   - Setup: Mock returns page 1 data
   - Render, wait
   - User clicks page 2 button
   - Assert: `reviewService.list` called with `{ page: 2, limit: 5 }`

9. **"should display error Alert when API call fails"**
   - Setup: `mockReviewService.list.mockRejectedValueOnce(new Error('Network error'))`
   - Render, wait
   - Assert: `screen.getByRole('alert')` with text "Network error"

10. **"should apply custom className to root container"**
    - Assert: Root element has `custom-class`

---

#### Step 6: Export Updates (No tests)

**File:** `frontend/components/product/index.ts`

Add exports:
```typescript
export { ReviewCard } from './ReviewCard';
export { ReviewSummary } from './ReviewSummary';
export { ReviewList } from './ReviewList';
```

**File:** `frontend/lib/services/index.ts`

Add export:
```typescript
export { reviewService } from './reviewService';
```

---

### Testing Strategy

**Test files (8 total):**
1. `reviewService.test.ts` (6 test cases)
2. `ReviewCard.test.tsx` (9 test cases)
3. `ReviewSummary.test.tsx` (10 test cases)
4. `ReviewList.test.tsx` (10 test cases)

**Mocking approach:**
- **Service tests:** Mock `@/lib/api/client` (apiClient.get)
- **Component tests:** Mock service layer (`@/lib/services/reviewService`)
- **Icon mocks:** Reuse pattern from ProductCard.test.tsx for `lucide-react` Star icon

**Key test scenarios:**
- ✅ Empty states (no reviews, 0 rating)
- ✅ Populated states (multiple reviews, various ratings)
- ✅ Loading states (skeleton placeholders)
- ✅ Error states (API failures)
- ✅ Pagination (page changes, totalPages edge cases)
- ✅ Undefined field handling (missing authorName, comment, createdAt)
- ✅ Edge cases (division by zero, missing distribution keys)
- ✅ Accessibility (aria-labels, role attributes)

---

### Key Patterns

**From ProductCard.tsx:**
- Star icon usage: `<Star className="h-4 w-4 fill-yellow-400 text-yellow-400" />`
- Image placeholder pattern with `ImageOff` icon
- Price formatting with `Intl.NumberFormat` → **Similar:** Date formatting with `Intl.RelativeTimeFormat`
- Card wrapper with `Card`, `CardContent`, `CardFooter`

**From productService.ts:**
- Clean params: `Object.fromEntries(Object.entries(params).filter(([, v]) => v !== undefined))`
- Type imports: `type X = components['schemas']['X']`, `type Y = operations['opName']['parameters']['query']`

**From ProductGrid:**
- Loading skeleton: `<div className="animate-pulse bg-muted h-64 rounded-lg" role="status"><span className="sr-only">Loading...</span></div>`
- Empty state: `<div className="text-center text-muted-foreground"><PackageOpen className="h-16 w-16 mx-auto mb-4" /><p>No products found</p></div>`

**From Pagination component:**
- Auto-hides when `totalPages <= 1`
- `aria-current="page"` for current page button
- `onPageChange` callback pattern

**From ImageGallery:**
- `'use client'` directive for client components with state
- `useMemo` for sorted/derived data
- Bounds checking: `Math.min(selectedIndex, array.length - 1)` → **Use for safe array access**

---

### Gotchas & Constraints

1. **Client vs Server Components:**
   - `ReviewList` MUST have `'use client'` (uses useState, useEffect)
   - `ReviewCard` and `ReviewSummary` are presentational (no directive, can be server components if needed)

2. **Type safety:**
   - All API types auto-generated from `api-spec.yaml`
   - Never use `any` — use `components['schemas']['Review']`, etc.
   - Optional chaining for all API fields (`review.authorName ?? ''`)

3. **Date formatting:**
   - Backend returns ISO 8601 strings (`createdAt: "2026-02-10T12:00:00Z"`)
   - Use `Intl.RelativeTimeFormat('en')` for "X days ago" formatting
   - Handle `undefined` createdAt gracefully

4. **Rating distribution:**
   - Backend returns `{ 1?: number, 2?: number, ... }` (all keys optional)
   - Must default missing keys to `0` with `?? 0`
   - Calculate percentages: `(count / total) * 100`, handle `total === 0` case

5. **Pagination:**
   - Reuse existing `Pagination` component (already handles `totalPages <= 1`)
   - Limit: 5 reviews per page (hardcoded in `reviewService.list` call)
   - Page state resets to 1 if `productId` changes

6. **Star rating display:**
   - Render exactly 5 stars always
   - Filled stars: `fill-yellow-400 text-yellow-400`
   - Empty stars: `text-muted-foreground`
   - Use `Math.round()` for summary stars (4.5 → 5), exact count for ReviewCard

7. **Testing:**
   - Use `waitFor` from RTL for async state updates
   - Mock `Date.now()` for relative date tests: `jest.spyOn(Date, 'now').mockReturnValue(new Date('2026-02-16').getTime())`
   - Use `createReviewListResponse()` fixture for consistent test data

8. **Error handling:**
   - Show user-friendly error messages in Alert component
   - Catch all errors in ReviewList's useEffect
   - Don't expose technical error details (e.g., "Network error" not "ECONNREFUSED")

9. **Accessibility:**
   - Loading state: `role="status"` + sr-only text
   - Alert: automatically has `role="alert"`
   - Stars: Decorative (no aria-label needed, rating shown as text)
   - Pagination: Already has `aria-label="Pagination"`, `aria-current="page"`

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing (35 new tests, 407 total)
- [x] Code follows project standards
- [x] No linting errors
- [x] Build succeeds

---

*Ticket created: 2026-02-16*
