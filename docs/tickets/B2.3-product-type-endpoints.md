# B2.3: Create product type endpoints (CRUD)

**Sprint:** 2
**Type:** Backend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint2-B2.3-product-type-endpoints
**Created:** 2026-02-10
**Dependencies:** B2.1 (model), B2.2 (service + validator)

---

## Description

Create the REST API controller and routes for product type CRUD operations. The service layer (B2.2) and domain errors are already implemented. This task wires them up to Express endpoints following the existing authController pattern.

**Endpoints from api-spec.yaml:**
- `GET /api/product-types` — List product types (public, role-aware filtering)
- `POST /api/product-types` — Create product type (ADMIN only)
- `PATCH /api/product-types/:id` — Update product type (ADMIN only)
- `DELETE /api/product-types/:id` — Delete product type (ADMIN only)

**Key behaviors:**
- GET list is public (no auth required) but role-aware: public/TARGET see only active; ADMIN/MANAGER/MARKETING can filter by `isActive`
- POST/PATCH/DELETE require authentication + ADMIN role
- GET list extracts caller role from `req.user` (if authenticated) or defaults to `'PUBLIC'`
- Uses existing `authMiddleware` and `requireRole` middleware
- Uses existing `responseHelpers` (`success`, `created`, `noContent`)
- Maps domain errors to HTTP status codes following authController pattern

---

## Acceptance Criteria

- [x] `GET /api/product-types` returns list of product types (200)
- [x] `GET /api/product-types` without auth returns only active product types
- [x] `GET /api/product-types` with ADMIN auth respects `isActive` query param
- [x] `POST /api/product-types` creates a product type (201) — ADMIN only
- [x] `POST /api/product-types` returns 400 for invalid data
- [x] `POST /api/product-types` returns 409 for duplicate slug
- [x] `PATCH /api/product-types/:id` updates a product type (200) — ADMIN only
- [x] `PATCH /api/product-types/:id` returns 404 for non-existent ID
- [x] `DELETE /api/product-types/:id` deletes a product type (204) — ADMIN only
- [x] `DELETE /api/product-types/:id` returns 404 for non-existent ID
- [x] Unauthenticated POST/PATCH/DELETE returns 401
- [x] Non-ADMIN POST/PATCH/DELETE returns 403
- [x] Routes registered at `/api/product-types` in router index
- [x] Unit tests for controller (all endpoints + error mapping)
- [x] All existing tests still pass
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `src/presentation/controllers/productTypeController.ts` | Controller functions for CRUD operations |
| `src/presentation/controllers/productTypeController.test.ts` | Unit tests for controller |
| `src/routes/productTypeRoutes.ts` | Route definitions with middleware |
| `src/routes/index.ts` | Register product-type routes |

---

## Implementation Steps

### Step 1: Create productTypeController

Controller functions following authController pattern:
- `listProductTypes` — calls `productTypeService.getAllProductTypes()` with role-aware input
- `createProductType` — calls `productTypeService.createProductType()` with request body
- `updateProductType` — calls `productTypeService.updateProductType()` with ID + body
- `deleteProductType` — calls `productTypeService.deleteProductType()` with ID

Error mapping:
- `InvalidProductTypeDataError` → 400
- `ProductTypeNotFoundError` → 404
- `ProductTypeSlugAlreadyExistsError` → 409
- Unknown errors → `next(error)` (to global error handler)

### Step 2: Create productTypeRoutes

```
GET    /                → listProductTypes (no auth required)
POST   /                → authMiddleware + requireRole(ADMIN) + createProductType
PATCH  /:id             → authMiddleware + requireRole(ADMIN) + updateProductType
DELETE /:id             → authMiddleware + requireRole(ADMIN) + deleteProductType
```

### Step 3: Register routes in index

Add `router.use('/product-types', productTypeRoutes)` to `src/routes/index.ts`.

### Step 4: Write unit tests

Test each controller function with mocked service:
- Happy path for each endpoint
- Error mapping for each domain error type
- Role extraction for GET list (authenticated vs unauthenticated)
- Request parameter extraction (body, params, query)

---

## Technical Notes

- Follow the exact controller pattern from `authController.ts` (try/catch, error instanceof checks, next(error))
- Use `responseHelpers` (`success`, `created`, `noContent`) for consistent responses
- For GET list: extract `req.user?.role` and default to `'PUBLIC'` for unauthenticated requests
- For GET list: parse `req.query.isActive` string to boolean if present
- The `requireRole` middleware from `roleMiddleware.ts` handles 401/403 for protected routes
- Service functions are already tested in B2.2 — controller tests should mock the service layer

---

## Implementation Plan

### 1. Existing Code to Reuse

| File | What to Reuse |
|------|--------------|
| `src/presentation/controllers/authController.ts` | Controller pattern: exported async functions with `(req, res, next)`, try/catch, instanceof error checks, `next(error)` fallthrough |
| `src/presentation/controllers/authController.test.ts` | Test structure: `jest.mock()` at module level, `Partial<Request>`, `Partial<Response>`, `jest.MockedFunction<NextFunction>`, `statusMock`/`jsonMock` in `beforeEach` |
| `src/application/services/productTypeService.ts` | Service functions: `createProductType(input)`, `getAllProductTypes(input)`, `updateProductType(id, input)`, `deleteProductType(id)` |
| `src/application/validators/productTypeValidator.ts` | Types: `CreateProductTypeInput`, `UpdateProductTypeInput`, `GetAllProductTypesInput` |
| `src/domain/errors/ProductTypeError.ts` | Error classes: `InvalidProductTypeDataError` (has `field`), `ProductTypeNotFoundError`, `ProductTypeSlugAlreadyExistsError` |
| `src/utils/responseHelpers.ts` | Response helpers: `success(res, data)`, `created(res, data)`, `noContent(res)` |
| `src/middleware/authMiddleware.ts` | `authMiddleware` for protected routes + pattern for `optionalAuthMiddleware` |
| `src/middleware/roleMiddleware.ts` | `requireRole(UserRole.ADMIN)` for POST/PATCH/DELETE routes |

### 2. Files to Create/Modify

| File | Action | Purpose |
|------|--------|---------|
| `src/middleware/optionalAuthMiddleware.ts` | **CREATE** | Middleware to silently populate `req.user` from Bearer token (no-op if missing/invalid) |
| `src/middleware/optionalAuthMiddleware.test.ts` | **CREATE** | Unit tests for optionalAuthMiddleware |
| `src/presentation/controllers/productTypeController.ts` | **CREATE** | Controller with 4 functions: `listProductTypes`, `createProductType`, `updateProductType`, `deleteProductType` |
| `src/presentation/controllers/productTypeController.test.ts` | **CREATE** | Unit tests for all controller functions |
| `src/routes/productTypeRoutes.ts` | **CREATE** | Route definitions with middleware wiring |
| `src/routes/index.ts` | **MODIFY** | Add `router.use('/product-types', productTypeRoutes)` |

### 3. Implementation Order (TDD)

#### Step 1: Create `optionalAuthMiddleware` (TDD)

**Why:** GET `/product-types` is public (`security: []`) but role-aware. Needs `req.user?.role` when token IS present, silent pass-through when absent/invalid.

**Test cases:**
```
describe('optionalAuthMiddleware')
  it('should call next() without setting req.user when no Authorization header')
  it('should call next() without setting req.user when Authorization header is empty')
  it('should call next() without setting req.user when token is invalid')
  it('should call next() without setting req.user when token is expired')
  it('should set req.user and call next() when valid token is provided')
  it('should call next() without setting req.user when Authorization format is not Bearer')
```

**Implementation:** Try to decode Bearer token, set `req.user` if successful, call `next()` regardless.

#### Step 2: Create `productTypeController` tests (RED phase)

**Mock setup:** `jest.mock('../../application/services/productTypeService')` at module level. Do NOT mock the validator (service calls it internally).

**Test cases:**
```
describe('productTypeController')

  describe('listProductTypes')
    it('should return 200 with product types for unauthenticated request')
    it('should pass callerRole from req.user.role for authenticated request')
    it('should parse isActive query param as boolean true')
    it('should parse isActive query param as boolean false')
    it('should not pass isActive when query param is not present')
    it('should call next(error) for unexpected errors')

  describe('createProductType')
    it('should return 201 with created product type')
    it('should return 400 when InvalidProductTypeDataError is thrown')
    it('should return 409 when ProductTypeSlugAlreadyExistsError is thrown')
    it('should call next(error) for unexpected errors')

  describe('updateProductType')
    it('should return 200 with updated product type')
    it('should return 400 when InvalidProductTypeDataError is thrown')
    it('should return 404 when ProductTypeNotFoundError is thrown')
    it('should return 409 when ProductTypeSlugAlreadyExistsError is thrown')
    it('should call next(error) for unexpected errors')

  describe('deleteProductType')
    it('should return 204 with no content')
    it('should return 400 when InvalidProductTypeDataError is thrown')
    it('should return 404 when ProductTypeNotFoundError is thrown')
    it('should call next(error) for unexpected errors')
```

#### Step 3: Implement `productTypeController` (GREEN phase)

- `listProductTypes`: extract `req.user?.role ?? 'PUBLIC'`, parse `isActive` query, call `getAllProductTypes`, use `success(res, data)`
- `createProductType`: pass `req.body` to service, use `created(res, data)`
- `updateProductType`: extract `req.params.id`, pass with `req.body` to service, use `success(res, data)`
- `deleteProductType`: extract `req.params.id`, call service, use `noContent(res)`
- Private `handleProductTypeError` helper to DRY error mapping across all 4 functions

**Error mapping:**
- `InvalidProductTypeDataError` → 400 (include `field`)
- `ProductTypeNotFoundError` → 404
- `ProductTypeSlugAlreadyExistsError` → 409
- Unknown → `next(error)`

#### Step 4: Create routes and register

- `productTypeRoutes.ts`: GET with `optionalAuthMiddleware`, POST/PATCH/DELETE with `authMiddleware` + `requireRole(ADMIN)`
- `routes/index.ts`: add `router.use('/product-types', productTypeRoutes)`

#### Step 5: Run all tests and verify build

```bash
cd backend && npm test && npm run lint && npm run build
```

### 4. Testing Strategy

- **Mock the service module** (`jest.mock`), NOT the validator
- **Mock `verifyAccessToken`** in optionalAuthMiddleware tests
- **Follow authController.test.ts pattern exactly:** `Partial<Request>`, `statusMock.mockReturnValue({ json: jsonMock, send: sendMock })`, `jest.clearAllMocks()` in `beforeEach`
- **Response helper assertions:** verify `statusMock` and `jsonMock`/`sendMock` calls
- **Error assertions:** verify `{ success: false, error: { message, code, field? } }` format

### 5. Key Patterns

1. **Controller functions:** `async (req, res, next) => Promise<void>`, exported as named functions
2. **Error handling:** `instanceof` checks in catch block, `next(error)` as fallthrough
3. **Response format:** Errors = `{ success: false, error: { message, code, field? } }`, success uses `responseHelpers`
4. **Route middleware chain:** `authMiddleware` → `requireRole(ADMIN)` for protected; `optionalAuthMiddleware` for public
5. **Query string parsing:** `req.query.isActive` is `string | undefined`; parse `'true'`→`true`, `'false'`→`false`, else `undefined`
6. **Module-level mocking + `beforeEach(jest.clearAllMocks)`** for test isolation

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing
- [x] Code follows project standards
- [x] No linting errors
- [x] Build succeeds

---

*Ticket created: 2026-02-10*
