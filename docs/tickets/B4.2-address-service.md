# B4.2: Implement address service (CRUD for users)

**Sprint:** 4
**Type:** Backend - Service + Controller
**Priority:** High
**Status:** Pending
**Branch:** feature/sprint4-B4.2-address-service
**Created:** 2026-02-18
**Dependencies:** B4.1 (Address model)

---

## Description

Implement CRUD operations for user addresses. Addresses belong to authenticated users. The service supports listing, creating, getting, updating, and deleting addresses. Includes a "default address" feature where setting one address as default automatically unsets the previous default.

API endpoints (already defined in api-spec.yaml):
- `GET /users/me/addresses` — List user's addresses
- `POST /users/me/addresses` — Create new address
- `GET /users/me/addresses/:addressId` — Get address by ID
- `PATCH /users/me/addresses/:addressId` — Update address
- `DELETE /users/me/addresses/:addressId` — Delete address

---

## Acceptance Criteria

- [x] Address service with list, create, getById, update, delete methods
- [x] Address validator (plain TS, matching existing pattern) for create and update requests
- [x] Only authenticated users can manage their own addresses
- [x] Setting `isDefault: true` unsets previous default address atomically
- [x] Cannot delete a default address (must set another as default first, or allow if it is the only address)
- [x] Maximum 10 addresses per user (throws AddressLimitExceededError)
- [x] Address controller and routes registered
- [x] Unit tests for service (TDD)
- [x] Unit tests for validator
- [x] All tests pass, build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `backend/src/application/services/addressService.ts` | Address CRUD service |
| `backend/src/application/services/addressService.test.ts` | Service tests |
| `backend/src/application/validators/addressValidator.ts` | Zod validation |
| `backend/src/application/validators/addressValidator.test.ts` | Validator tests |
| `backend/src/presentation/controllers/addressController.ts` | Express controller |
| `backend/src/routes/addressRoutes.ts` | Route definitions |
| `backend/src/routes/index.ts` | Register address routes |

---

## Technical Notes

- Follow existing service patterns (productService, productTypeService)
- All endpoints require authentication — use `authenticateToken` middleware
- Scope all Prisma queries to `userId` from the authenticated user's token (never allow cross-user access)
- The "unset previous default" operation must be done in a Prisma transaction to avoid race conditions:
  1. `UPDATE addresses SET isDefault = false WHERE userId = ? AND isDefault = true`
  2. `UPDATE addresses SET isDefault = true WHERE id = ?`
- `DefaultAddressCannotBeDeletedError` is thrown when deleting the default address and the user has more than one address
- If the user has exactly one address and it is the default, allow deletion
- Use existing DDD patterns for error handling (throw domain errors, map to HTTP status in controller)
- List endpoint should return addresses ordered by `createdAt` ascending

---

## Implementation Plan

### Overview

Implement address CRUD following the exact DDD layered pattern established by `productTypeService`. No new utilities or shared helpers are needed — the existing `validateUUID` from `shared.ts`, domain errors from `AddressError.ts`, `authMiddleware` from `authMiddleware.ts`, and response helpers from `responseHelpers.ts` are all reused.

The implementation order follows TDD: write failing tests first, then implement to make them pass.

---

### Existing Code to Reuse

| Component | File | Usage |
|-----------|------|-------|
| `validateUUID` | `backend/src/application/validators/shared.ts` | Validate addressId and userId params |
| `AddressNotFoundError`, `AddressLimitExceededError`, `InvalidAddressDataError`, `DefaultAddressCannotBeDeletedError` | `backend/src/domain/errors/AddressError.ts` | All domain errors already exist |
| `authMiddleware` | `backend/src/middleware/authMiddleware.ts` | Protect all address routes |
| `success`, `created`, `noContent` | `backend/src/utils/responseHelpers.ts` | Controller responses |
| `prisma` | `backend/src/lib/prisma.ts` | ORM client |
| `req.user` (type: `TokenPayload`) | `backend/src/types/express.d.ts` | `req.user!.userId` gives the authenticated user's ID |

Note: The ticket refers to `authenticateToken` but the actual middleware export is `authMiddleware` (from `authMiddleware.ts`). Use `authMiddleware` to match the existing codebase.

Note: The validator in this task does NOT use Zod — the existing pattern (productTypeValidator, productValidator) uses plain TypeScript with manual validation and throws domain errors directly. Follow that pattern, not Zod.

---

### Phase 1: Validator (TDD)

#### 1a. Write tests first: `backend/src/application/validators/addressValidator.test.ts`

Test structure mirrors `productTypeValidator.test.ts`:

```
describe('addressValidator')
  describe('validateCreateAddressInput')
    describe('valid inputs')
      it('should accept minimum required fields')
      it('should accept all optional fields')
      it('should trim whitespace from string fields')
      it('should default isDefault to false when not provided')
    describe('invalid inputs - required fields')
      it('should throw InvalidAddressDataError when firstName is missing')
      it('should throw InvalidAddressDataError when lastName is missing')
      it('should throw InvalidAddressDataError when streetLine1 is missing')
      it('should throw InvalidAddressDataError when city is missing')
      it('should throw InvalidAddressDataError when postalCode is missing')
      it('should throw InvalidAddressDataError when countryCode is missing')
    describe('invalid inputs - field constraints')
      it('should throw InvalidAddressDataError when firstName is empty string')
      it('should throw InvalidAddressDataError when firstName exceeds 100 chars')
      it('should throw InvalidAddressDataError when lastName exceeds 100 chars')
      it('should throw InvalidAddressDataError when streetLine1 exceeds 255 chars')
      it('should throw InvalidAddressDataError when streetLine2 exceeds 255 chars')
      it('should throw InvalidAddressDataError when city exceeds 100 chars')
      it('should throw InvalidAddressDataError when state exceeds 100 chars')
      it('should throw InvalidAddressDataError when postalCode exceeds 20 chars')
      it('should throw InvalidAddressDataError when countryCode is not exactly 2 chars')
      it('should throw InvalidAddressDataError when label exceeds 50 chars')
      it('should throw InvalidAddressDataError when phone exceeds 20 chars')
      it('should throw InvalidAddressDataError when isDefault is not boolean')

  describe('validateUpdateAddressInput')
    describe('valid inputs')
      it('should return empty object for empty input')
      it('should accept partial update with only firstName')
      it('should accept update setting isDefault to true')
      it('should trim whitespace from provided string fields')
    describe('invalid inputs')
      it('should throw InvalidAddressDataError when firstName is empty string')
      it('should throw InvalidAddressDataError when countryCode is not 2 chars')
      it('should throw InvalidAddressDataError when isDefault is not boolean')

  describe('validateAddressId')
    it('should return validated UUID string for valid UUID')
    it('should throw InvalidAddressDataError when ID is invalid UUID')
    it('should throw InvalidAddressDataError when ID is empty')
```

#### 1b. Implement: `backend/src/application/validators/addressValidator.ts`

Exports and interfaces:

```typescript
// Interfaces
export interface CreateAddressInput {
  label?: string;
  firstName: string;
  lastName: string;
  streetLine1: string;
  streetLine2?: string;
  city: string;
  state?: string;
  postalCode: string;
  countryCode: string;
  phone?: string;
  isDefault?: boolean;
}

export interface ValidatedCreateAddressInput {
  label?: string;
  firstName: string;
  lastName: string;
  streetLine1: string;
  streetLine2?: string;
  city: string;
  state?: string;
  postalCode: string;
  countryCode: string;
  phone?: string;
  isDefault: boolean;  // always present after validation (defaults to false)
}

export interface UpdateAddressInput {
  label?: string;
  firstName?: string;
  lastName?: string;
  streetLine1?: string;
  streetLine2?: string;
  city?: string;
  state?: string;
  postalCode?: string;
  countryCode?: string;
  phone?: string;
  isDefault?: boolean;
}

export interface ValidatedUpdateAddressInput {
  label?: string;
  firstName?: string;
  lastName?: string;
  streetLine1?: string;
  streetLine2?: string;
  city?: string;
  state?: string;
  postalCode?: string;
  countryCode?: string;
  phone?: string;
  isDefault?: boolean;
}
```

Exported functions:
- `validateCreateAddressInput(input: CreateAddressInput): ValidatedCreateAddressInput`
- `validateUpdateAddressInput(input: UpdateAddressInput): ValidatedUpdateAddressInput`
- `validateAddressId(id: string): string`

Internal helpers (private, not exported):
- `throwAddressError(message: string, field: string): never` — throws `InvalidAddressDataError`
- `validateUUID(id: unknown, fieldName: string): string` — delegates to `sharedValidateUUID` with `throwAddressError`
- `validateRequiredString(value: unknown, fieldName: string, maxLength: number): string` — trims, checks empty, checks max length
- `validateOptionalString(value: unknown, fieldName: string, maxLength: number): string | undefined` — same but allows undefined
- `validateCountryCode(value: unknown, fieldName: string): string` — must be string of exactly 2 chars (trim → check length === 2)
- `validateBoolean(value: unknown, fieldName: string): boolean` — pattern from productTypeValidator

Field constraints (matching Prisma schema VarChar limits):
- `label`: optional, max 50 chars
- `firstName`: required, max 100 chars
- `lastName`: required, max 100 chars
- `streetLine1`: required, max 255 chars
- `streetLine2`: optional, max 255 chars
- `city`: required, max 100 chars
- `state`: optional, max 100 chars
- `postalCode`: required, max 20 chars
- `countryCode`: required, exactly 2 chars (ISO 3166-1 alpha-2)
- `phone`: optional, max 20 chars
- `isDefault`: optional boolean, defaults to `false` in create

---

### Phase 2: Service (TDD)

#### 2a. Write tests first: `backend/src/application/services/addressService.test.ts`

Mock setup (same pattern as `productTypeService.test.ts`):

```typescript
jest.mock('../../lib/prisma', () => ({
  __esModule: true,
  default: {
    address: {
      findMany: jest.fn(),
      findFirst: jest.fn(),
      count: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
    $transaction: jest.fn(),
  },
}));
```

Test cases:

```
describe('addressService')
  // Setup: const USER_ID = '123e4567-e89b-12d3-a456-426614174000'
  // Setup: const ADDRESS_ID = '223e4567-e89b-12d3-a456-426614174001'
  // Setup: mockAddress = { id: ADDRESS_ID, userId: USER_ID, firstName: 'John', ... }

  describe('listAddresses')
    it('should return addresses ordered by createdAt ascending')
      // expects findMany called with { where: { userId }, orderBy: { createdAt: 'asc' } }
    it('should return empty array when user has no addresses')
    it('should only return addresses belonging to userId')
      // verifies where clause includes userId

  describe('createAddress')
    it('should create address with valid input and isDefault false')
      // count returns 3; create resolves; verify create called with userId + validated data
    it('should create address with isDefault false by default')
    it('should create address with isDefault true and call transaction to unset previous default')
      // When isDefault = true: $transaction receives two updateMany calls
    it('should throw AddressLimitExceededError when user already has 10 addresses')
      // count returns 10; expect AddressLimitExceededError; expect create NOT called
    it('should throw InvalidAddressDataError when input is invalid')
      // missing required field; expect error before count is called
    it('should create first address as default automatically even if isDefault not set')
      // NOTE: see business rule below — when count = 0, force isDefault = true

  describe('getAddressById')
    it('should return address when found and belongs to userId')
      // findFirst with { where: { id: addressId, userId } }
    it('should throw AddressNotFoundError when address not found')
      // findFirst returns null
    it('should throw AddressNotFoundError when address exists but belongs to different user')
      // using userId scoping in where clause handles this automatically
    it('should throw InvalidAddressDataError when addressId is invalid UUID')

  describe('updateAddress')
    it('should update address fields with valid input')
      // findFirst returns existing; update returns updated
    it('should throw AddressNotFoundError when address not found')
    it('should update isDefault and call transaction when isDefault is set to true')
      // expects $transaction called with updateMany (unset previous default) + update
    it('should throw InvalidAddressDataError when addressId is invalid UUID')
    it('should throw InvalidAddressDataError when input is invalid')
    it('should allow empty update (no fields changed)')

  describe('deleteAddress')
    it('should delete address when it is not the default')
      // findFirst returns address with isDefault: false; delete called
    it('should delete address when it is the only address (even if default)')
      // findFirst returns isDefault: true; count returns 1; delete called
    it('should throw DefaultAddressCannotBeDeletedError when address is default and user has more than one address')
      // findFirst returns isDefault: true; count returns 2; error thrown; delete NOT called
    it('should throw AddressNotFoundError when address not found')
    it('should throw InvalidAddressDataError when addressId is invalid UUID')
```

**Business rule note — auto-default first address:** When a user has 0 existing addresses and creates a new one, force `isDefault = true` regardless of input. This ensures the first address is always the default. This simplifies the user experience.

#### 2b. Implement: `backend/src/application/services/addressService.ts`

```typescript
import prisma from '../../lib/prisma';
import {
  validateCreateAddressInput,
  validateUpdateAddressInput,
  validateAddressId,
  type CreateAddressInput,
  type UpdateAddressInput,
} from '../validators/addressValidator';
import {
  AddressNotFoundError,
  AddressLimitExceededError,
  DefaultAddressCannotBeDeletedError,
} from '../../domain/errors/AddressError';
import type { Address } from '../../generated/prisma/client';

const MAX_ADDRESSES_PER_USER = 10;

export async function listAddresses(userId: string): Promise<Address[]>
export async function createAddress(userId: string, input: CreateAddressInput): Promise<Address>
export async function getAddressById(userId: string, addressId: string): Promise<Address>
export async function updateAddress(userId: string, addressId: string, input: UpdateAddressInput): Promise<Address>
export async function deleteAddress(userId: string, addressId: string): Promise<void>
```

Key implementation details for each function:

**`listAddresses(userId)`:**
```
return prisma.address.findMany({
  where: { userId },
  orderBy: { createdAt: 'asc' },
});
```

**`createAddress(userId, input)`:**
1. `const validated = validateCreateAddressInput(input)` — throws `InvalidAddressDataError` on failure
2. `const count = await prisma.address.count({ where: { userId } })`
3. If `count >= MAX_ADDRESSES_PER_USER`, throw `AddressLimitExceededError`
4. Determine `isDefault`: if `count === 0` force `true`; else use `validated.isDefault`
5. If `isDefault === true` AND `count > 0`: use `$transaction` to unset previous default then create:
   ```
   prisma.$transaction([
     prisma.address.updateMany({ where: { userId, isDefault: true }, data: { isDefault: false } }),
     prisma.address.create({ data: { userId, ...validated, isDefault: true } }),
   ])
   ```
   Return the created address from transaction result (index 1).
6. Else (isDefault false or count === 0 with forced true but no previous default to unset):
   When count === 0: `prisma.address.create({ data: { userId, ...validated, isDefault: true } })`
   When count > 0 and isDefault false: `prisma.address.create({ data: { userId, ...validated } })`

Note: For the transaction case, `prisma.$transaction` returns `[updateManyResult, createdAddress]`. The function returns the `Address` at index 1.

**`getAddressById(userId, addressId)`:**
1. `validateAddressId(addressId)` — throws `InvalidAddressDataError` on failure
2. `const address = await prisma.address.findFirst({ where: { id: addressId, userId } })`
3. If null, throw `AddressNotFoundError`
4. Return address

Note: Using `findFirst` with `{ id, userId }` instead of `findUnique` scopes the query to the user automatically, so a different user's address returns null (not found) rather than needing a separate ownership check.

**`updateAddress(userId, addressId, input)`:**
1. `validateAddressId(addressId)` — throws `InvalidAddressDataError` on failure
2. `const validated = validateUpdateAddressInput(input)` — throws `InvalidAddressDataError` on failure
3. `const existing = await prisma.address.findFirst({ where: { id: addressId, userId } })`
4. If null, throw `AddressNotFoundError`
5. If `validated.isDefault === true`:
   Use `$transaction`:
   ```
   const [, updated] = await prisma.$transaction([
     prisma.address.updateMany({ where: { userId, isDefault: true }, data: { isDefault: false } }),
     prisma.address.update({ where: { id: addressId }, data: validated }),
   ]);
   return updated;
   ```
6. Else:
   ```
   return prisma.address.update({ where: { id: addressId }, data: validated });
   ```

**`deleteAddress(userId, addressId)`:**
1. `validateAddressId(addressId)` — throws `InvalidAddressDataError` on failure
2. `const existing = await prisma.address.findFirst({ where: { id: addressId, userId } })`
3. If null, throw `AddressNotFoundError`
4. If `existing.isDefault === true`:
   - `const count = await prisma.address.count({ where: { userId } })`
   - If `count > 1`, throw `DefaultAddressCannotBeDeletedError`
5. `await prisma.address.delete({ where: { id: addressId } })`

---

### Phase 3: Controller (TDD)

#### 3a. Write tests first — integration route tests: `backend/src/routes/addressRoutes.integration.test.ts`

Follow the same pattern as `productTypeRoutes.integration.test.ts`:

Mock setup:
```typescript
jest.mock('../lib/prisma', () => ({
  __esModule: true,
  default: {
    address: {
      findMany: jest.fn(),
      findFirst: jest.fn(),
      count: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
    },
    $transaction: jest.fn(),
  },
}));

jest.mock('../application/services/tokenService', () => ({
  verifyAccessToken: jest.fn(),
}));
```

`setupAuth()` helper (all address routes belong to a single authenticated user):
```typescript
const setupAuth = () => {
  (mockTokenService.verifyAccessToken as jest.Mock).mockReturnValue({
    userId: 'user-uuid-123',
    email: 'user@example.com',
    role: UserRole.TARGET,
  });
};
```

Test cases:

```
describe('Address Routes Integration')

  describe('GET /users/me/addresses')
    it('should return 401 without authentication token')
    it('should return 200 with list of addresses for authenticated user')
      // findMany resolves with 2 addresses; verify response.body.data.length === 2
    it('should return 200 with empty array when user has no addresses')

  describe('POST /users/me/addresses')
    it('should return 401 without authentication token')
    it('should return 201 with created address for valid input')
      // count returns 0 (first address); create resolves
    it('should return 400 for missing required fields (no firstName)')
    it('should return 409 when user has 10 addresses')
      // count returns 10; expect 409 response with code ADDRESS_LIMIT_EXCEEDED

  describe('GET /users/me/addresses/:addressId')
    it('should return 401 without authentication token')
    it('should return 200 with address when found')
    it('should return 404 when address not found')
    it('should return 400 for invalid addressId format')

  describe('PATCH /users/me/addresses/:addressId')
    it('should return 401 without authentication token')
    it('should return 200 with updated address')
    it('should return 404 when address not found')
    it('should return 400 for invalid input')

  describe('DELETE /users/me/addresses/:addressId')
    it('should return 401 without authentication token')
    it('should return 204 when address deleted')
    it('should return 404 when address not found')
    it('should return 409 when trying to delete default address with multiple addresses')
      // expect 409 with code DEFAULT_ADDRESS_CANNOT_BE_DELETED
```

Note: The integration tests mock at the Prisma layer (not service layer), consistent with the `productTypeRoutes.integration.test.ts` pattern. The address routes file mounts under `/users/me/addresses` in the router, so requests go to `/users/me/addresses`.

#### 3b. Implement: `backend/src/presentation/controllers/addressController.ts`

```typescript
import { Request, Response, NextFunction } from 'express';
import * as addressService from '../../application/services/addressService';
import {
  InvalidAddressDataError,
  AddressNotFoundError,
  AddressLimitExceededError,
  DefaultAddressCannotBeDeletedError,
} from '../../domain/errors/AddressError';
import { success, created, noContent } from '../../utils/responseHelpers';

export async function listAddresses(req: Request, res: Response, next: NextFunction): Promise<void>
export async function createAddress(req: Request, res: Response, next: NextFunction): Promise<void>
export async function getAddressById(req: Request, res: Response, next: NextFunction): Promise<void>
export async function updateAddress(req: Request, res: Response, next: NextFunction): Promise<void>
export async function deleteAddress(req: Request, res: Response, next: NextFunction): Promise<void>

// Private helper
function handleAddressError(error: unknown, res: Response, next: NextFunction): void
```

Each controller function:
- Extracts `userId` from `req.user!.userId` (always present because `authMiddleware` runs first and populates it)
- Extracts `addressId` from `req.params.addressId`
- Delegates to service
- Uses response helpers for success responses
- Delegates errors to `handleAddressError`

Error mapping in `handleAddressError`:

| Domain Error | HTTP Status | Response body |
|---|---|---|
| `InvalidAddressDataError` | 400 | `{ success: false, error: { message, code, field } }` |
| `AddressNotFoundError` | 404 | `{ success: false, error: { message, code } }` |
| `AddressLimitExceededError` | 409 | `{ success: false, error: { message, code } }` |
| `DefaultAddressCannotBeDeletedError` | 409 | `{ success: false, error: { message, code } }` |
| anything else | forward to `next(error)` | |

Note: Both `AddressLimitExceededError` and `DefaultAddressCannotBeDeletedError` map to 409 (Conflict), consistent with how `ProductTypeSlugAlreadyExistsError` maps to 409 in `productTypeController`.

---

### Phase 4: Routes and Registration

#### 4a. Create: `backend/src/routes/addressRoutes.ts`

```typescript
import { Router } from 'express';
import {
  listAddresses,
  createAddress,
  getAddressById,
  updateAddress,
  deleteAddress,
} from '../presentation/controllers/addressController';
import { authMiddleware } from '../middleware/authMiddleware';

const router = Router();

// All address routes require authentication
router.get('/', authMiddleware, listAddresses);
router.post('/', authMiddleware, createAddress);
router.get('/:addressId', authMiddleware, getAddressById);
router.patch('/:addressId', authMiddleware, updateAddress);
router.delete('/:addressId', authMiddleware, deleteAddress);

export default router;
```

Note: No `requireRole` middleware — all authenticated users (TARGET, MANAGER, ADMIN, MARKETING) can manage their own addresses.

Note: Express 5 + path-to-regexp v8 constraint (ADR-006): no inline regex in route params. Using plain `:addressId` is correct.

#### 4b. Modify: `backend/src/routes/index.ts`

Add the following import and route registration:

```typescript
import addressRoutes from './addressRoutes';
// ...
router.use('/users/me/addresses', addressRoutes);
```

The route prefix `/users/me/addresses` matches the API spec paths (`GET /users/me/addresses`, etc.).

---

### Phase 5: Verification

After all phases are implemented:

1. Run `cd /Users/pb/Developer/FiveGuays/memes/backend && npm test` — all tests must pass
2. Run `cd /Users/pb/Developer/FiveGuays/memes/backend && npm run lint` — no lint errors
3. Run `cd /Users/pb/Developer/FiveGuays/memes/backend && npm run build` — TypeScript compilation succeeds
4. Run `production-code-validator` agent before committing

---

### Summary: Files to Create/Modify

| File | Action | Notes |
|------|--------|-------|
| `backend/src/application/validators/addressValidator.ts` | Create | Plain TS validation, no Zod |
| `backend/src/application/validators/addressValidator.test.ts` | Create | Write BEFORE validator implementation |
| `backend/src/application/services/addressService.ts` | Create | Prisma client, domain errors |
| `backend/src/application/services/addressService.test.ts` | Create | Write BEFORE service implementation |
| `backend/src/presentation/controllers/addressController.ts` | Create | Thin controller, error mapping |
| `backend/src/routes/addressRoutes.ts` | Create | All routes protected by authMiddleware |
| `backend/src/routes/addressRoutes.integration.test.ts` | Create | Write BEFORE controller implementation |
| `backend/src/routes/index.ts` | Modify | Add `router.use('/users/me/addresses', addressRoutes)` |

No changes needed to `api-spec.yaml` — address schemas and endpoints are already defined.

---

### Important Notes

1. **Middleware name**: The ticket mentions `authenticateToken` but the actual export is `authMiddleware` from `backend/src/middleware/authMiddleware.ts`. Use `authMiddleware`.

2. **No Zod**: Existing validators do NOT use Zod — they use plain TypeScript with manual validation. The ticket mentions "Address validator (Zod)" but the existing pattern is plain TS. Follow the established pattern to keep consistency.

3. **`$transaction` return type for create**: `prisma.$transaction([updateMany, create])` returns `[BatchPayload, Address]`. The service must return `result[1]` for the create case.

4. **`$transaction` return type for update**: `prisma.$transaction([updateMany, update])` returns `[BatchPayload, Address]`. The service must return `result[1]` for the update case.

5. **`findFirst` vs `findUnique`**: Use `findFirst` with `{ id: addressId, userId }` to scope queries to the authenticated user. This correctly handles the case where the address exists but belongs to another user (returns null → `AddressNotFoundError`).

6. **Auto-default first address**: When the user creates their first address (count = 0), force `isDefault = true` even if the input provides `isDefault: false`. This business rule must be covered by a test.

7. **Integration test mock level**: Follow `productTypeRoutes.integration.test.ts` and mock at the Prisma layer (not service layer). The address routes file will use `prisma` directly through the service, so mock `prisma.address.*` and `prisma.$transaction`.

8. **Test file for integration**: Name it `addressRoutes.integration.test.ts` to match the existing naming convention for route integration tests.
