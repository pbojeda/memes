# B3.4: Implement product listing with filters

**Sprint:** 3
**Type:** Backend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint3-B3.4-product-listing-filters
**Created:** 2026-02-12
**Dependencies:** B3.3 (Product service CRUD) ✅

---

## Description

Add a `listProducts` service function that supports paginated product listing with filtering and sorting. This is a service-layer feature (no HTTP controller/routes yet — those come in B3.9). The function queries products with support for:

- **Pagination**: page + limit with configurable defaults (page=1, limit=20, max=100)
- **Filtering**: by productTypeId, isActive, isHot, price range (minPrice/maxPrice), search text (title)
- **Sorting**: by price, createdAt, salesCount (asc/desc), default: createdAt desc
- **Soft delete exclusion**: excludes deleted products by default, with `includeSoftDeleted` option for admin use

The function returns a paginated result with data array + pagination metadata (total, totalPages, hasNext, hasPrev).

---

## Acceptance Criteria

- [x] `ListProductsInput` interface with all filter/sort/pagination params defined
- [x] `ListProductsResult` interface with `data: Product[]` and `pagination: PaginationMeta`
- [x] Input validation for pagination params (page >= 1, limit 1-100)
- [x] Input validation for filter params (valid UUID for productTypeId, valid price range)
- [x] Input validation for sort params (whitelist of allowed fields + directions)
- [x] `listProducts` function in productService builds dynamic Prisma `where` clause
- [x] Filter by `productTypeId` (exact match)
- [x] Filter by `isActive` (boolean)
- [x] Filter by `isHot` (boolean)
- [x] Filter by price range (`minPrice` <= price <= `maxPrice`)
- [x] Search by title text (case-insensitive, matches `es` or `en` keys in JSONB)
- [x] Sort by `price`, `createdAt`, `salesCount` with `asc`/`desc` direction
- [x] Default sort: `createdAt desc`
- [x] Excludes soft-deleted products by default (`deletedAt: null`)
- [x] `includeSoftDeleted` option bypasses soft-delete filter
- [x] Returns correct pagination metadata (total count, totalPages, hasNext, hasPrev)
- [x] Handles empty results gracefully (returns empty array with pagination showing 0)
- [x] Unit tests for all filter combinations
- [x] Unit tests for pagination edge cases (page beyond results, limit=1, etc.)
- [x] Unit tests for sort options
- [x] Unit tests for input validation errors
- [x] All tests pass
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `backend/src/application/validators/productValidator.ts` | Add `validateListProductsInput` + `ListProductsInput` interface |
| `backend/src/application/services/productService.ts` | Add `listProducts` function |
| `backend/src/application/services/__tests__/productService.listProducts.test.ts` | Unit tests for listProducts |
| `backend/src/application/validators/__tests__/productValidator.listProducts.test.ts` | Unit tests for list input validation |

---

## Technical Notes

- **Prisma JSON filtering**: For text search on JSONB `title` field, use `Prisma.JsonFilter` with `path` + `string_contains`. PostgreSQL JSONB supports this via Prisma's `Json` filter.
- **Pagination pattern**: Follow the `paginated()` response helper pattern from `utils/responseHelpers.ts` — `PaginationMeta` already defines the shape.
- **Sort whitelist**: Only allow `price`, `createdAt`, `salesCount` — reject anything else to prevent injection.
- **Existing indexes**: `isActive`, `isHot`, `createdAt`, `salesCount`, `productTypeId` are all indexed (see schema.prisma).
- **Decimal price**: Price is `Decimal(10,2)` in Prisma — filter comparisons must use `Prisma.Decimal` or number-compatible values.
- **Reuse shared validators**: Use `validateUUID` from `shared.ts` for `productTypeId` validation.

---

## Implementation Plan

### Existing Code to Reuse

**Domain Errors:**
- `InvalidProductDataError` from `backend/src/domain/errors/ProductError.ts` - for validation failures
- `ProductNotFoundError` from `backend/src/domain/errors/ProductError.ts` - if needed for edge cases

**Validators:**
- `validateUUID()` from `backend/src/application/validators/shared.ts` - for validating `productTypeId` parameter
- Existing validation patterns from `productValidator.ts` - for consistent error handling approach

**Utilities:**
- `PaginationMeta` interface from `backend/src/utils/responseHelpers.ts` - defines pagination metadata structure
- `PaginatedResponse<T>` interface from `backend/src/utils/responseHelpers.ts` - defines paginated response shape

**Database Client:**
- `prisma` from `backend/src/lib/prisma` - already used in `productService.ts`

**Testing Patterns:**
- Mock setup pattern from `backend/src/application/services/productService.test.ts` - for Prisma mocking
- AAA test structure from existing tests - Arrange-Act-Assert pattern
- Validator test patterns from `backend/src/application/validators/productValidator.test.ts` and `shared.test.ts`

### Files to Create

None - all functionality will be added to existing files.

### Files to Modify

| File | Changes |
|------|---------|
| `backend/src/application/validators/productValidator.ts` | Add `ListProductsInput` interface, `ValidatedListProductsInput` interface, and `validateListProductsInput()` function with validation for pagination (page, limit), filters (productTypeId, isActive, isHot, minPrice, maxPrice, search), and sort (sortBy, sortDirection) |
| `backend/src/application/services/productService.ts` | Add `ListProductsResult` type and `listProducts()` function that builds dynamic Prisma `where` clause based on filters, handles pagination, sorting, and returns paginated results with metadata |
| `backend/src/application/validators/__tests__/productValidator.listProducts.test.ts` | Create test file with comprehensive unit tests for `validateListProductsInput()` covering: valid inputs with defaults, pagination validation (page >= 1, limit 1-100), filter validation (UUID format, boolean types, price range logic, search text), sort validation (whitelist enforcement), and edge cases (empty input, boundary values) |
| `backend/src/application/services/__tests__/productService.listProducts.test.ts` | Create test file with comprehensive unit tests for `listProducts()` covering: pagination (correct skip/take, edge cases like page beyond results), filtering (each filter individually and combinations), sorting (all allowed fields with asc/desc), soft-delete exclusion (default and includeSoftDeleted option), empty results handling, and Prisma query construction verification |

### Implementation Order

1. **Validators (Input Validation Layer)**
   - Add interfaces (`ListProductsInput`, `ValidatedListProductsInput`) to `productValidator.ts`
   - Add `validateListProductsInput()` function to `productValidator.ts` with:
     - Pagination validation (page >= 1, limit between 1-100 with defaults: page=1, limit=20)
     - Filter validation (productTypeId as UUID, booleans for isActive/isHot, numbers for minPrice/maxPrice with minPrice <= maxPrice check, string for search)
     - Sort validation (whitelist `['price', 'createdAt', 'salesCount']` for sortBy, enum `['asc', 'desc']` for sortDirection, defaults: sortBy='createdAt', sortDirection='desc')
     - Optional `includeSoftDeleted` boolean (default: false)

2. **Service Layer (Business Logic)**
   - Add `ListProductsResult` type to `productService.ts` with shape: `{ data: Product[], pagination: PaginationMeta }`
   - Add `listProducts()` function to `productService.ts` with:
     - Input validation via `validateListProductsInput()`
     - Dynamic `Prisma.ProductWhereInput` construction based on filters:
       - `productTypeId` → exact match if provided
       - `isActive` → boolean filter if provided
       - `isHot` → boolean filter if provided
       - `minPrice`/`maxPrice` → Decimal range using `gte`/`lte` if provided
       - `search` → JSONB text search on `title.es` and `title.en` using `path` and `string_contains` (case-insensitive via PostgreSQL)
       - `deletedAt: null` by default (unless `includeSoftDeleted: true`)
     - Pagination: `skip: (page - 1) * limit`, `take: limit`
     - Sorting: `orderBy: { [sortBy]: sortDirection }`
     - Execute `prisma.product.findMany()` with constructed query
     - Execute `prisma.product.count()` with same `where` clause for total count
     - Return `{ data, pagination }` with calculated metadata (total, totalPages, hasNext, hasPrev)

3. **Tests (Validator)**
   - Create `productValidator.listProducts.test.ts` with test suites:
     - **Valid inputs:** defaults applied, all parameters provided, optional parameters omitted
     - **Pagination errors:** page < 1, page as string, limit < 1, limit > 100, limit as string
     - **Filter errors:** productTypeId not UUID, isActive not boolean, minPrice > maxPrice, minPrice/maxPrice as strings
     - **Sort errors:** sortBy not in whitelist, sortDirection not asc/desc
     - **Edge cases:** empty object input, all filters with edge boundary values

4. **Tests (Service)**
   - Create `productService.listProducts.test.ts` with test suites:
     - **Pagination:** correct skip/take, page=1, page beyond results, limit=1, limit=100
     - **Filtering:** each filter individually (productTypeId, isActive, isHot, minPrice, maxPrice, search), multiple filters combined, search matches Spanish and English
     - **Sorting:** price asc/desc, createdAt asc/desc, salesCount asc/desc
     - **Soft-delete:** excludes deleted by default, includes deleted when `includeSoftDeleted: true`
     - **Empty results:** returns empty array with pagination showing total=0
     - **Metadata accuracy:** total count matches, totalPages calculated correctly, hasNext/hasPrev flags correct

### Testing Strategy

**Validator Tests (`productValidator.listProducts.test.ts`):**
- **Focus:** Input validation rules in isolation
- **Mocking:** None - pure validation logic
- **Coverage:**
  - Happy path: valid inputs with all combinations of optional parameters
  - Pagination validation: page (>= 1, integer), limit (1-100, integer), defaults applied
  - Filter validation: productTypeId (UUID format), isActive/isHot (boolean), minPrice/maxPrice (positive Decimal, logical range), search (string)
  - Sort validation: sortBy (whitelist), sortDirection (enum)
  - Edge cases: missing fields, wrong types, boundary values (limit=1, limit=100, page=1, minPrice=maxPrice)

**Service Tests (`productService.listProducts.test.ts`):**
- **Focus:** Business logic and Prisma query construction
- **Mocking:** Mock `prisma.product.findMany()` and `prisma.product.count()`
- **Coverage:**
  - Pagination logic: verify correct `skip` and `take` values for various page/limit combinations
  - Filter construction: verify `where` clause structure for each filter individually and combined
  - JSONB search: verify `title` filter uses `path` and `string_contains` for both `es` and `en` keys
  - Sorting: verify `orderBy` clause for all allowed fields and directions
  - Soft-delete: verify `deletedAt: null` in `where` by default, absent when `includeSoftDeleted: true`
  - Empty results: mock `findMany` returning `[]` and `count` returning `0`, verify pagination metadata
  - Metadata calculation: verify `total`, `totalPages`, `hasNext`, `hasPrev` correctness for edge cases (page 1 of 1, page 2 of 2, page beyond results)

**Integration Testing:**
- No integration tests required for this task (service-layer only, no HTTP endpoints)
- Integration tests will be added in B3.9 when HTTP controller/routes are implemented

### Key Patterns

**Validation Pattern (from `productValidator.ts`):**
- Validate all inputs before processing
- Apply defaults for optional parameters (page=1, limit=20, sortBy='createdAt', sortDirection='desc')
- Use shared validators (`validateUUID`) for consistency
- Throw `InvalidProductDataError` with descriptive messages and field names
- Return validated interface with all defaults applied (`ValidatedListProductsInput`)

**Service Pattern (from `productService.ts`):**
- Call validator first: `const validated = validateListProductsInput(input);`
- Build dynamic Prisma queries using conditional logic (only add filters if present)
- Use Prisma's type-safe query builders (`Prisma.ProductWhereInput`, `Prisma.ProductOrderByWithRelationInput`)
- Execute count and data queries separately (not using `_count` due to performance)
- Calculate pagination metadata manually (totalPages, hasNext, hasPrev)
- Return structured result: `{ data, pagination }`

**Pagination Pattern (from `responseHelpers.ts`):**
- `page`: 1-indexed (page 1 is first page)
- `skip`: `(page - 1) * limit` for Prisma
- `totalPages`: `Math.ceil(total / limit)`
- `hasNext`: `page < totalPages`
- `hasPrev`: `page > 1`

**JSONB Search Pattern (PostgreSQL + Prisma):**
```typescript
// For search text in title.es or title.en
{
  OR: [
    { title: { path: ['es'], string_contains: searchText, mode: 'insensitive' } },
    { title: { path: ['en'], string_contains: searchText, mode: 'insensitive' } }
  ]
}
```
- Use `Prisma.JsonFilter` with `path` to target specific JSONB keys
- Use `string_contains` for partial matching (LIKE '%text%')
- Use `mode: 'insensitive'` for case-insensitive search (PostgreSQL ILIKE)

**Decimal Handling (from `productService.ts`):**
- Price is `Decimal(10,2)` in Prisma schema
- Prisma accepts `number` for Decimal fields in `where` clauses (auto-converts)
- Returns `Prisma.Decimal` instances in results
- Use `gte` (>=) and `lte` (<=) for range filters

**Sort Whitelist Pattern:**
- Only allow specific fields: `['price', 'createdAt', 'salesCount']`
- Reject any other field to prevent SQL injection or invalid columns
- Direction must be `'asc' | 'desc'` (enforce as literal type)

**Test Mocking Pattern (from existing tests):**
```typescript
jest.mock('../../lib/prisma', () => ({
  __esModule: true,
  default: {
    product: {
      findMany: jest.fn(),
      count: jest.fn(),
    },
  },
}));

const mockPrisma = prisma as jest.Mocked<typeof prisma>;

beforeEach(() => {
  jest.clearAllMocks();
});
```

**Important Constraints:**
- **Max limit:** 100 items per page (prevent abuse)
- **Default limit:** 20 items per page
- **Default page:** 1
- **Default sort:** `createdAt desc` (newest first)
- **Soft-delete:** Exclude `deletedAt IS NOT NULL` by default (admin can override with `includeSoftDeleted: true`)
- **Search scope:** Only search `title.es` and `title.en` (not description)
- **Price range validation:** If both provided, `minPrice <= maxPrice` (validator enforces this)

**Performance Notes:**
- All filter fields are indexed in schema (`isActive`, `isHot`, `createdAt`, `salesCount`, `productTypeId`)
- Pagination uses `skip`/`take` (offset pagination) - acceptable for this use case
- Count query runs separately from data query (Prisma pattern for paginated results)
- JSONB search on `title` uses GIN index on `title` column (PostgreSQL default for JSONB)

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Unit tests written and passing
- [ ] Code follows project standards (DDD layers, TypeScript strict)
- [ ] No linting errors
- [ ] Build succeeds

---

*Ticket created: 2026-02-12*
