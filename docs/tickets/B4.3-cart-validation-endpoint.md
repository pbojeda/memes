# B4.3: Create Cart Validation Endpoint

**Sprint:** 4
**Type:** Backend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint4-B4.3-cart-validation
**Created:** 2026-02-18
**Dependencies:** None (independent)

---

## Description

Implement a cart validation endpoint that verifies cart items are valid before checkout. The cart in this system is **client-side** (frontend Zustand store with localStorage persistence). The backend receives a list of cart items and validates each product exists, is active, has the requested size (if applicable), and returns current pricing. This is the backend counterpart to the frontend's `cartStore` (F4.1).

The endpoint is public (`security: []` in the API spec) since both guest and authenticated users can have carts. It accepts a list of `{ productId, quantity, size? }` items and returns validated cart data with current prices, identifying any items that have issues (product removed, deactivated, size unavailable, price changed).

---

## Acceptance Criteria

- [x] `POST /cart/validate` endpoint accepts an array of cart items
- [x] Validates each item: productId exists, product is active (not soft-deleted), quantity >= 1
- [x] Validates size: if product has `availableSizes`, size must be provided and be in the list
- [x] Returns current pricing for each valid item (uses product's current `price`)
- [x] Returns per-item errors for invalid items (product not found, inactive, invalid size)
- [x] Returns cart totals: subtotal, itemCount
- [x] Input validation: array must be non-empty, max 50 items, valid UUIDs for productIds
- [x] Domain errors: `CartError`, `InvalidCartDataError`
- [x] Validator: `cartValidator.ts` with `validateCartInput`
- [x] Service: `cartService.ts` with `validateCart`
- [x] Controller: `cartController.ts` with `validateCart` handler
- [x] Routes: `cartRoutes.ts` mounted at `/cart`
- [x] Unit tests for validator (27 tests)
- [x] Unit tests for service (21 tests)
- [x] Integration tests for route (18 tests)
- [x] All existing tests pass (1137 total)
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `src/domain/errors/cartError.ts` | Cart domain error classes |
| `src/application/validators/cartValidator.ts` | Cart input validation |
| `src/application/services/cartService.ts` | Cart validation business logic |
| `src/presentation/controllers/cartController.ts` | HTTP handler for cart validation |
| `src/routes/cartRoutes.ts` | Cart route definitions |
| `src/routes/index.ts` | Register cart routes |
| `src/domain/errors/cartError.test.ts` | Tests for error classes |
| `src/application/validators/cartValidator.test.ts` | Tests for validator |
| `src/application/services/cartService.test.ts` | Tests for service |
| `src/routes/cartRoutes.integration.test.ts` | Integration tests |

---

## Technical Notes

### API Design

The API spec defines full cart CRUD endpoints (`/cart`, `/cart/items`, etc.), but those are for server-side cart management (future sprint). B4.3 focuses on a **validation endpoint** that the frontend calls before checkout to verify its client-side cart is still valid.

**Endpoint:** `POST /cart/validate` (not yet in api-spec.yaml — needs to be added)

**Request:**
```json
{
  "items": [
    { "productId": "uuid", "quantity": 2, "size": "M" },
    { "productId": "uuid", "quantity": 1 }
  ]
}
```

**Response (200):**
```json
{
  "success": true,
  "data": {
    "valid": true,
    "items": [
      {
        "productId": "uuid",
        "quantity": 2,
        "size": "M",
        "unitPrice": 29.99,
        "subtotal": 59.98,
        "product": { "title": {...}, "slug": "...", "primaryImage": {...} },
        "status": "valid"
      },
      {
        "productId": "uuid",
        "quantity": 1,
        "size": null,
        "unitPrice": 19.99,
        "subtotal": 19.99,
        "product": { "title": {...}, "slug": "...", "primaryImage": {...} },
        "status": "valid"
      }
    ],
    "summary": {
      "subtotal": 79.97,
      "itemCount": 3
    },
    "errors": []
  }
}
```

**Response with errors (200 — partial success):**
```json
{
  "success": true,
  "data": {
    "valid": false,
    "items": [...],
    "summary": { "subtotal": 29.99, "itemCount": 1 },
    "errors": [
      { "productId": "uuid", "code": "PRODUCT_NOT_FOUND", "message": "Product not found" },
      { "productId": "uuid", "code": "PRODUCT_INACTIVE", "message": "Product is no longer available" },
      { "productId": "uuid", "code": "INVALID_SIZE", "message": "Size XL is not available for this product" }
    ]
  }
}
```

Note: Returns 200 even with item errors (the request itself is valid). Returns 400 only for malformed input (missing items array, invalid UUIDs, etc.).

### Patterns to Follow

- **Validator:** Follow `addressValidator.ts` pattern — input/validated interfaces, private helpers, exported validator function
- **Service:** Follow `productService.ts` pattern — Prisma queries with explicit includes, typed return values
- **Controller:** Follow `addressController.ts` pattern — thin handler, error mapping
- **Routes:** Follow `addressRoutes.ts` pattern — no auth middleware (public endpoint)
- **Errors:** Follow `addressError.ts` pattern — base class with code, specific subclasses
- **Shared validators:** Reuse `validateUUID` from `shared.ts`

### Product Query Strategy

Batch-load all products in a single query using `findMany({ where: { id: { in: productIds } } })` rather than individual queries per item. Include `productType` (for `hasSizes`) and primary image.

### Size Validation

Products with `productType.hasSizes === true` require a size. The size must be in the product's `availableSizes` JSON array. Products without sizes must NOT have a size specified.

---

## Implementation Plan

### Step 1: Domain Errors

**Create:** `src/domain/errors/cartError.ts` + `cartError.test.ts`

**Tests first:**
- `CartError` base class has message, code, name
- `InvalidCartDataError` has code `INVALID_CART_DATA`, accepts optional `field`

**Implementation:** Following `addressError.ts` pattern:
- `CartError extends Error` with `code: string`
- `InvalidCartDataError extends CartError` with optional `field: string`

**Checkpoint:** `npm test -- --testPathPatterns cartError`

---

### Step 2: Validator

**Create:** `src/application/validators/cartValidator.ts` + `cartValidator.test.ts`

**Interfaces:**
```typescript
export interface CartItemInput { productId: string; quantity: number; size?: string; }
export interface CartValidationInput { items: CartItemInput[]; }
export interface ValidatedCartItem { productId: string; quantity: number; size?: string; }
export interface ValidatedCartInput { items: ValidatedCartItem[]; }
```

**Tests first (groups):**
- **Valid inputs:** single item without size, with size, multiple items (up to 50), trim size whitespace
- **Invalid items array:** missing, not array, empty, exceeds 50
- **Invalid item fields:** productId missing/invalid UUID, quantity missing/not number/< 1/not integer, size not string/empty after trim

**Implementation:** Following `addressValidator.ts` pattern:
- Private `throwCartError(message, field)` helper
- Reuse `validateUUID` from `shared.ts` (pass `throwCartError` as the error thrower)
- Private helpers for quantity (integer >= 1), optional size (non-empty string)
- Exported `validateCartInput(input): ValidatedCartInput`

**Checkpoint:** `npm test -- --testPathPatterns cartValidator`

---

### Step 3: Service

**Create:** `src/application/services/cartService.ts` + `cartService.test.ts`

**Types:**
```typescript
type CartItemErrorCode = 'PRODUCT_NOT_FOUND' | 'PRODUCT_INACTIVE' | 'INVALID_SIZE' | 'SIZE_REQUIRED' | 'SIZE_NOT_ALLOWED';
interface CartItemError { productId: string; code: CartItemErrorCode; message: string; }
interface ValidatedCartItemResult {
  productId: string; quantity: number; size: string | null;
  unitPrice: number; subtotal: number;
  product: { title: unknown; slug: string; primaryImage: ProductImage | null; };
  status: 'valid';
}
interface CartValidationResult {
  valid: boolean; items: ValidatedCartItemResult[];
  summary: { subtotal: number; itemCount: number; };
  errors: CartItemError[];
}
```

**Tests first (mock Prisma `product.findMany`):**
- **All items valid:** correct items/prices/summary for products with and without sizes
- **Batch loading:** single `findMany` call with all unique productIds, includes `productType` + primary image
- **Duplicate productIds:** same product different sizes handled correctly
- **Error cases:** `PRODUCT_NOT_FOUND` (not in DB), `PRODUCT_INACTIVE` (isActive=false), `PRODUCT_INACTIVE` (deletedAt != null), `SIZE_REQUIRED` (hasSizes but no size), `INVALID_SIZE` (size not in availableSizes), `SIZE_NOT_ALLOWED` (no sizes but size provided)
- **Mixed items:** valid=false, valid items still in items array, summary only from valid items

**Implementation:**
1. Validate input via `validateCartInput(input)` (throws on bad input)
2. Extract unique productIds → `findMany({ where: { id: { in: ids } }, include: { productType: true, images: { where: { isPrimary: true }, take: 1 } } })`
3. Build `Map<id, product>`, iterate items:
   - Not in map → `PRODUCT_NOT_FOUND`
   - `!isActive || deletedAt` → `PRODUCT_INACTIVE`
   - `hasSizes && !size` → `SIZE_REQUIRED`
   - `!hasSizes && size` → `SIZE_NOT_ALLOWED`
   - `hasSizes && size not in availableSizes` → `INVALID_SIZE`
   - Otherwise → valid item with `unitPrice = Number(product.price)`, `subtotal = unitPrice * quantity`
4. Summary from valid items only, round subtotal to 2 decimals
5. Return `{ valid: errors.length === 0, items, summary, errors }`

**Key:** Query without `isActive`/`deletedAt` filter so we can distinguish `NOT_FOUND` vs `INACTIVE`.

**Checkpoint:** `npm test -- --testPathPatterns cartService`

---

### Step 4: Controller

**Create:** `src/presentation/controllers/cartController.ts` + `cartController.test.ts`

**Tests first (mock `cartService`):**
- Returns 200 with `success(res, result)` on valid input
- Returns 200 with errors array on partial success
- Returns 400 with error details when `InvalidCartDataError` is thrown
- Calls `next(error)` for unexpected errors

**Implementation:** Following `addressController.ts` pattern:
- `validateCart(req, res, next)` — calls `cartService.validateCart(req.body)`, uses `success()` helper
- Private `handleCartError()` — maps `InvalidCartDataError` → 400 JSON, else `next(error)`

**Checkpoint:** `npm test -- --testPathPatterns cartController`

---

### Step 5: Routes

**Create:** `src/routes/cartRoutes.ts`
**Modify:** `src/routes/index.ts`

```typescript
// cartRoutes.ts
const router = Router();
router.post('/validate', validateCart);  // No authMiddleware — public endpoint
export default router;

// index.ts — add:
import cartRoutes from './cartRoutes';
router.use('/cart', cartRoutes);
```

---

### Step 6: Integration Tests

**Create:** `src/routes/cartRoutes.integration.test.ts`

Following `addressRoutes.integration.test.ts` pattern with `supertest`:
- **Success:** 200 with valid=true (all items valid), 200 with valid=false (some items invalid)
- **Public access:** 200 without Authorization header
- **Input validation:** 400 for missing items, empty array, invalid UUIDs, bad quantities
- **Response structure:** correct items/summary/errors shape, product includes title/slug/primaryImage, correct subtotal calculations

Mock: `jest.mock('../lib/prisma')` with `product.findMany`

**Checkpoint:** `npm test -- --testPathPatterns cartRoutes`

---

### Step 7: API Spec Update

**Modify:** `ai-specs/specs/api-spec.yaml`

Add `POST /cart/validate` path (after `/cart/shipping`) and new schemas:
- `CartValidationRequest` — `{ items: [{ productId, quantity, size? }] }`
- `CartValidationResult` — `{ valid, items, summary, errors }`
- `CartValidatedItem` — `{ productId, quantity, size, unitPrice, subtotal, product, status }`
- `CartValidationError` — `{ productId, code, message }`

Then run: `cd frontend && npm run generate:api`

---

### Step 8: Final Verification

1. `cd backend && npm test` — all tests pass
2. `cd backend && npm run lint` — no errors
3. `cd backend && npm run build` — succeeds
4. Run `production-code-validator` agent
5. Update ticket acceptance criteria `[x]`

---

### File Summary

| Step | File | Action |
|------|------|--------|
| 1 | `src/domain/errors/cartError.test.ts` | Create |
| 1 | `src/domain/errors/cartError.ts` | Create |
| 2 | `src/application/validators/cartValidator.test.ts` | Create |
| 2 | `src/application/validators/cartValidator.ts` | Create |
| 3 | `src/application/services/cartService.test.ts` | Create |
| 3 | `src/application/services/cartService.ts` | Create |
| 4 | `src/presentation/controllers/cartController.test.ts` | Create |
| 4 | `src/presentation/controllers/cartController.ts` | Create |
| 5 | `src/routes/cartRoutes.ts` | Create |
| 5 | `src/routes/index.ts` | Modify |
| 6 | `src/routes/cartRoutes.integration.test.ts` | Create |
| 7 | `ai-specs/specs/api-spec.yaml` | Modify |

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing
- [x] Integration tests written and passing
- [x] Code follows project standards (DDD layers, TypeScript strict, English only)
- [x] No linting errors
- [x] Build succeeds
- [x] api-spec.yaml updated with `/cart/validate` endpoint

---

*Ticket created: 2026-02-18*
