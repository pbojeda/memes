# F3.8: Create Admin Products List Page

**Sprint:** 3
**Type:** Frontend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint3-F3.8-admin-products-list
**Created:** 2026-02-17
**Dependencies:** None (F3.8 is independent; F3.9 is blocked by F3.8)

---

## Description

Implement an admin products list page at `/admin/products` that displays all products (including inactive and soft-deleted) in a table with filtering, pagination, and CRUD action buttons. The page follows the same patterns established in the admin Product Types page but with product-specific features: search, status filtering, and action buttons for activate/deactivate/delete/restore.

The backend `GET /products` endpoint already supports `isActive` filtering via `optionalAuth` — when an authenticated admin/manager user calls it, they can see inactive products and filter by `isActive`.

---

## Acceptance Criteria

- [x] Admin products page renders at `/admin/products`
- [x] Products are displayed in a table with columns: Image, Title, Type, Price, Status (Active/Inactive), Hot, Created At, Actions
- [x] Search input filters products by title/description (debounced, calls API with `search` param)
- [x] Status filter (All / Active / Inactive) sends `isActive` query param to API
- [x] Pagination works correctly using the existing Pagination component
- [x] Action buttons per row: Edit (navigates to F3.9 form — link only for now), Activate/Deactivate toggle, Delete (soft delete)
- [x] Activate/Deactivate calls `POST /products/{productId}/activate` or `/deactivate` and refreshes list
- [x] Delete calls `DELETE /products/{productId}` and refreshes list
- [x] Confirmation dialog before delete action
- [x] Loading skeleton state while fetching products
- [x] Error state with retry button on fetch failure
- [x] Empty state when no products match filters
- [x] "Products" link added to AdminSidebar navigation
- [x] `api-spec.yaml` updated to add `isActive` parameter to `listProducts` operation
- [x] API types regenerated after spec update
- [x] Admin product service (`adminProductService`) created with list, activate, deactivate, delete methods
- [x] Unit tests for AdminProductsTable component
- [x] Unit tests for AdminProductsPage
- [x] All tests pass
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `frontend/app/admin/products/page.tsx` | Admin products list page |
| `frontend/app/admin/products/page.test.tsx` | Page tests |
| `frontend/components/admin/products/AdminProductsTable.tsx` | Table component with loading/error/empty states |
| `frontend/components/admin/products/AdminProductsTable.test.tsx` | Table component tests |
| `frontend/components/admin/products/DeleteProductDialog.tsx` | Delete confirmation dialog |
| `frontend/components/admin/products/DeleteProductDialog.test.tsx` | Dialog tests |
| `frontend/lib/services/adminProductService.ts` | Admin product API service (list with isActive, activate, deactivate, delete) |
| `frontend/lib/services/adminProductService.test.ts` | Service tests |
| `frontend/components/admin/AdminSidebar.tsx` | Add "Products" nav item |
| `ai-specs/specs/api-spec.yaml` | Add `isActive` param to `listProducts` |
| `frontend/lib/api/types.ts` | Regenerated after spec update |

---

## Technical Notes

- **API endpoint**: `GET /products?page=&limit=&search=&isActive=&sort=` (same public endpoint, but admin gets extended filtering with auth token)
- **Admin actions**: `POST /products/{productId}/activate`, `POST /products/{productId}/deactivate`, `DELETE /products/{productId}` — all require Bearer auth with MANAGER/ADMIN role
- **Admin layout**: Already wraps with `ProtectedRoute allowedRoles={['ADMIN']}` — admin-only access is inherited
- **Pattern**: Follow ProductTypesPage pattern (page manages state, delegates rendering to table component)
- **api-spec update needed**: Add `isActive` boolean param to `listProducts` operation in api-spec.yaml, then run `cd frontend && npm run generate:api`
- **Product schema**: `Product` has `id`, `title`, `slug`, `price`, `isActive`, `isHot`, `productType.name`, `primaryImage`, `reviewsCount`, `averageRating`, `createdAt`
- **Date formatting**: Use `toLocaleDateString()` for created date display
- **Price formatting**: Use `formatPrice()` from `lib/utils`
- **Localized title**: Use `getLocalizedName()` for product title display
- **Edit link**: For now, link to `/admin/products/${productId}/edit` — this page will be created in F3.9
- **Debounced search**: Use `setTimeout`/`clearTimeout` pattern for search input (300ms debounce)
- **Radix Select**: For status filter, use the same pattern as ProductFilters (mock in tests with native `<select>`)

---

## Implementation Plan

### Overview

There are 8 sequential steps following TDD order. Steps 1–2 establish the spec and service layer. Steps 3–5 build the UI components with tests-first. Steps 6–7 build the page and sidebar. Step 8 runs the final quality checks.

---

### Step 1 — Update `api-spec.yaml` and regenerate types

**Why first:** The `adminProductService` must reference the `isActive` query param via the generated `operations['listProducts']['parameters']['query']` type. The type must exist before writing service code.

**File to modify:** `ai-specs/specs/api-spec.yaml`

In the `listProducts` operation (around line 542), the `parameters` block currently lists: `Page`, `Limit`, `AcceptLanguage`, `search`, `typeSlug`, `minPrice`, `maxPrice`, `isHot`, `sort`. Add the following new entry after the `isHot` parameter and before `sort`:

```yaml
        - name: isActive
          in: query
          description: Filter by active status (admin/staff only; ignored for unauthenticated requests)
          schema:
            type: boolean
```

**After editing the spec**, run this command to regenerate the frontend types:

```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npm run generate:api
```

**Verification:** Open `frontend/lib/api/types.ts` and confirm that `operations['listProducts']['parameters']['query']` now includes `isActive?: boolean`.

**Note:** Do NOT edit `frontend/lib/api/types.ts` directly — it is auto-generated and will be overwritten.

---

### Step 2 — Create `adminProductService` (TDD: test first)

#### Step 2a — Write the service test file first

**File to create:** `frontend/lib/services/adminProductService.test.ts`

**Pattern to follow:** `frontend/lib/services/productTypeService.test.ts` — mock `apiClient` at the module level, then test each method in a `describe` block.

**Mock setup** (identical to productTypeService.test.ts):

```typescript
import { adminProductService } from './adminProductService';
import { apiClient } from '../api/client';
import { ApiException } from '../api/exceptions';

jest.mock('../api/client', () => ({
  apiClient: {
    get: jest.fn(),
    post: jest.fn(),
    delete: jest.fn(),
  },
}));

const mockApiClient = apiClient as jest.Mocked<typeof apiClient>;
```

**Test fixture** — use a minimal `Product` object matching `components['schemas']['Product']`:

```typescript
import type { components } from '../api/types';
type Product = components['schemas']['Product'];

const mockProduct: Product = {
  id: 'prod-1',
  title: 'Test Product',
  slug: 'test-product',
  price: 24.99,
  isActive: true,
  isHot: false,
  createdAt: '2026-01-01T00:00:00Z',
  productType: { id: 'type-1', name: 'T-Shirts', slug: 't-shirts' },
  primaryImage: undefined,
  reviewsCount: 0,
  averageRating: 0,
};
```

**Test cases to write:**

`describe('adminProductService.list')`:
- should call `GET /products` with no params when called with no arguments
- should call `GET /products` with `{ isActive: true }` when `isActive: true` is passed
- should call `GET /products` with `{ isActive: false }` when `isActive: false` is passed
- should call `GET /products` with `{ search: 'cat' }` when `search: 'cat'` is passed
- should call `GET /products` with combined params (page, limit, search, isActive)
- should strip `undefined` values from params (e.g., `{ search: undefined }` → no `search` key in request)
- should return the full `ProductListResponse` (not just `.data`)
- should propagate `ApiException` on error

`describe('adminProductService.activate')`:
- should call `POST /products/{productId}/activate` with the correct product ID
- should return the `Product` from response data
- should propagate `ApiException` on 401
- should propagate `ApiException` on 403
- should propagate `ApiException` on 404

`describe('adminProductService.deactivate')`:
- should call `POST /products/{productId}/deactivate` with the correct product ID
- should return the `Product` from response data
- should propagate `ApiException` on 401/403/404

`describe('adminProductService.delete')`:
- should call `DELETE /products/{productId}` with the correct product ID
- should return `void` (204 response has no body)
- should propagate `ApiException` on 401/403/404

#### Step 2b — Implement `adminProductService`

**File to create:** `frontend/lib/services/adminProductService.ts`

**Imports:**

```typescript
import { apiClient } from '../api/client';
import type { components, operations } from '../api/types';

type Product = components['schemas']['Product'];
type ProductListResponse = components['schemas']['ProductListResponse'];
type ListProductsParams = NonNullable<operations['listProducts']['parameters']['query']>;
```

**Service object:**

```typescript
export const adminProductService = {
  async list(params?: ListProductsParams): Promise<ProductListResponse> {
    const cleanParams = params
      ? Object.fromEntries(Object.entries(params).filter(([, v]) => v !== undefined))
      : {};
    const response = await apiClient.get<ProductListResponse>('/products', {
      params: cleanParams,
    });
    return response.data;
  },

  async activate(productId: string): Promise<Product> {
    const response = await apiClient.post<{ data?: Product }>(
      `/products/${productId}/activate`
    );
    return response.data.data!;
  },

  async deactivate(productId: string): Promise<Product> {
    const response = await apiClient.post<{ data?: Product }>(
      `/products/${productId}/deactivate`
    );
    return response.data.data!;
  },

  async delete(productId: string): Promise<void> {
    await apiClient.delete(`/products/${productId}`);
  },
};
```

**Key notes:**
- `list()` returns the full `ProductListResponse` (data + meta), not just `data`. This is different from `productService.list()` which also returns `ProductListResponse` — use the same pattern.
- `activate` and `deactivate` return `ProductResponse` from the API (shape: `{ data?: Product }`), so extract `.data.data`.
- `delete` is a 204 response with no body — return `void`.
- The `isActive` parameter works because it was added to the spec in Step 1 and is now in the generated `ListProductsParams` type.

**Run tests to confirm green:**
```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npx jest --testPathPatterns adminProductService.test
```

---

### Step 3 — Create `DeleteProductDialog` component (TDD: test first)

#### Step 3a — Write `DeleteProductDialog.test.tsx`

**File to create:** `frontend/components/admin/products/DeleteProductDialog.test.tsx`

**Pattern to follow:** `frontend/components/admin/product-types/DeleteProductTypeDialog.tsx` — same Dialog + ApiException error handling structure.

**Mock setup:**

```typescript
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { DeleteProductDialog } from './DeleteProductDialog';
import { adminProductService } from '../../../lib/services/adminProductService';
import type { components } from '../../../lib/api/types';

type Product = components['schemas']['Product'];

jest.mock('../../../lib/services/adminProductService', () => ({
  adminProductService: {
    delete: jest.fn(),
  },
}));
```

**Test fixture:**

```typescript
const mockProduct: Product = {
  id: 'prod-1',
  title: 'Test Product',
  slug: 'test-product',
  price: 24.99,
  isActive: true,
};
```

**Test cases:**
- should render nothing when `product` prop is null
- should render dialog title with product title when open=true and product is provided (e.g. "Delete Test Product")
- should render a warning that the action cannot be undone
- should call `adminProductService.delete` with the product ID when Delete button is clicked
- should call `onSuccess` callback after successful delete
- should call `onOpenChange(false)` after successful delete (dialog closes)
- should show loading text "Deleting..." while delete is in progress
- should show error message when delete fails (ApiException)
- should show generic error when a non-ApiException error is thrown
- should close dialog when Cancel button is clicked (calls `onOpenChange(false)`)
- should not call `adminProductService.delete` when Cancel is clicked

#### Step 3b — Implement `DeleteProductDialog`

**File to create:** `frontend/components/admin/products/DeleteProductDialog.tsx`

**Pattern:** Mirror `DeleteProductTypeDialog.tsx` exactly, but use `adminProductService.delete` and the `Product` type instead of `ProductType`.

**Key differences from DeleteProductTypeDialog:**
- No `hasProducts` check — products can always be deleted (soft delete)
- The Delete button should never be disabled (except during `isDeleting`)
- Title: `Delete {getLocalizedName(product.title)}` — note `product.title` not `product.name`
- Description: `"This action cannot be undone. The product will be soft-deleted and can be restored."` (soft delete is reversible, unlike product type delete)

**Imports needed:**

```typescript
'use client';

import { useState } from 'react';
import type { components } from '@/lib/api/types';
import { getLocalizedName } from '@/lib/utils';
import { adminProductService } from '@/lib/services/adminProductService';
import { ApiException } from '@/lib/api/exceptions';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
```

**Props interface:**

```typescript
interface DeleteProductDialogProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  product: components['schemas']['Product'] | null;
  onSuccess: () => void;
}
```

**Run tests:**
```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npx jest --testPathPatterns DeleteProductDialog.test
```

---

### Step 4 — Create `AdminProductsTable` component (TDD: test first)

#### Step 4a — Write `AdminProductsTable.test.tsx`

**File to create:** `frontend/components/admin/products/AdminProductsTable.test.tsx`

**Mocks needed:**

```typescript
// Mock lucide-react icons (same pattern as ProductFilters.test.tsx)
jest.mock('lucide-react', () => ({
  Pencil: (props: Record<string, unknown>) => <svg data-testid="pencil-icon" {...props} />,
  Trash2: (props: Record<string, unknown>) => <svg data-testid="trash2-icon" {...props} />,
  Plus: (props: Record<string, unknown>) => <svg data-testid="plus-icon" {...props} />,
  Power: (props: Record<string, unknown>) => <svg data-testid="power-icon" {...props} />,
}));

// Mock next/image
jest.mock('next/image', () => ({
  __esModule: true,
  default: ({ src, alt }: { src: string; alt: string }) => (
    <img src={src} alt={alt} />
  ),
}));

// Mock next/link
jest.mock('next/link', () => ({
  __esModule: true,
  default: ({ href, children }: { href: string; children: React.ReactNode }) => (
    <a href={href}>{children}</a>
  ),
}));

// Mock Radix UI Select (same pattern as ProductFilters.test.tsx — copy the full mock block)
jest.mock('radix-ui', () => { /* ... full mock from ProductFilters.test.tsx */ });
```

**Note on Radix Select mock:** Copy the complete mock from `ProductFilters.test.tsx` verbatim — it handles portals, options collection, and the `onValueChange` callback via a native `<select>` element. Do not simplify it.

**Test fixtures** — reuse existing factories from `frontend/components/product/testing/fixtures.ts`:

```typescript
import { createProduct, createProducts } from '../../product/testing/fixtures';
```

Create a few specific products for status testing:
```typescript
const activeProduct = createProduct({ id: 'prod-1', title: 'Active Product', isActive: true });
const inactiveProduct = createProduct({ id: 'prod-2', title: 'Inactive Product', isActive: false });
const hotProduct = createProduct({ id: 'prod-3', title: 'Hot Product', isHot: true });
```

**Test cases grouped by describe block:**

`describe('AdminProductsTable - Loading state')`:
- should render loading skeleton with `role="status"` when `isLoading` is true
- should render 5 skeleton rows when loading (5 `aria-hidden` divs)
- should not render table when loading

`describe('AdminProductsTable - Error state')`:
- should render `<Alert variant="destructive">` with error message when error is not null
- should render a Retry button in the error state
- should call `onRetry` when Retry button is clicked
- should not render table when error is shown

`describe('AdminProductsTable - Empty state')`:
- should render "No products found." text when products array is empty
- should not render table when products is empty

`describe('AdminProductsTable - Table rendering')`:
- should render table with correct column headers: Image, Title, Type, Price, Status, Hot, Created At, Actions
- should render one row per product
- should display product title using `getLocalizedName`
- should display product type name when `productType` is present
- should display formatted price using `formatPrice` (e.g., "24,99 €")
- should display "Active" badge with `variant="default"` for active products
- should display "Inactive" badge with `variant="secondary"` for inactive products
- should display "Hot" badge for products where `isHot` is true
- should not display "Hot" badge when `isHot` is false
- should render product image when `primaryImage` is present
- should render placeholder when `primaryImage` is null/undefined
- should display formatted creation date

`describe('AdminProductsTable - Action buttons')`:
- should render Edit link pointing to `/admin/products/{id}/edit`
- should render "Activate" button (aria-label `Activate {title}`) when product is inactive
- should render "Deactivate" button (aria-label `Deactivate {title}`) when product is active
- should call `onActivate` with the product when Activate button is clicked
- should call `onDeactivate` with the product when Deactivate button is clicked
- should call `onDelete` with the product when Delete button is clicked
- action buttons should be disabled when `actionLoadingId` matches the product ID
- action buttons should be enabled when `actionLoadingId` is null or a different product ID

`describe('AdminProductsTable - Search and status filter')`:
- should render a search input with placeholder "Search products..."
- should call `onSearchChange` when typing in the search input
- should render a status filter Select with options: All, Active, Inactive
- should call `onStatusChange` when status filter changes
- should display current search value in the input
- should display current status value in the filter

`describe('AdminProductsTable - Pagination')`:
- should render Pagination component when `totalPages` > 1
- should not render Pagination when `totalPages` is 1 or undefined
- should call `onPageChange` when a pagination button is clicked

#### Step 4b — Implement `AdminProductsTable`

**File to create:** `frontend/components/admin/products/AdminProductsTable.tsx`

**Imports:**

```typescript
'use client';

import Image from 'next/image';
import Link from 'next/link';
import { Pencil, Trash2, Power } from 'lucide-react';
import type { components } from '@/lib/api/types';
import { getLocalizedName, formatPrice } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Pagination } from '@/components/ui/pagination';
```

**Props interface:**

```typescript
type Product = components['schemas']['Product'];

interface AdminProductsTableProps {
  products: Product[];
  isLoading: boolean;
  error: string | null;
  onRetry: () => void;
  onActivate: (product: Product) => void;
  onDeactivate: (product: Product) => void;
  onDelete: (product: Product) => void;
  actionLoadingId: string | null;  // product ID currently being acted on (disables its buttons)
  // Filter/pagination props (managed by parent page)
  search: string;
  onSearchChange: (value: string) => void;
  statusFilter: 'all' | 'active' | 'inactive';
  onStatusChange: (value: 'all' | 'active' | 'inactive') => void;
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
}
```

**Status filter sentinel values:** Use `__all__` as the Radix Select sentinel for "all" (same pattern as `TYPE_ALL_SENTINEL` in `ProductFilters.tsx`). Map to `undefined` in the `onStatusChange` handler. Define:

```typescript
const STATUS_ALL_SENTINEL = '__all__';
const STATUS_ACTIVE = 'active';
const STATUS_INACTIVE = 'inactive';
```

**Loading state:** Return a `<div role="status" aria-live="polite">` with 5 `<div className="h-12 bg-muted animate-pulse rounded" aria-hidden="true" />` skeleton rows (same pattern as `ProductTypesTable`).

**Error state:** Return `<Alert variant="destructive">` with an `<AlertDescription>` containing the error text and a Retry button (same pattern as `ProductTypesTable`).

**Empty state:** Return a `<div className="text-center py-12">` with "No products found." text and no create button (admin creates products in F3.9).

**Image column:** Use `next/image` with explicit `width={40}` and `height={40}` (not `fill`). Show a gray placeholder `<div>` when `primaryImage` is null. The image URL comes from `product.primaryImage?.url`.

**Status badge:** `<Badge variant={product.isActive ? 'default' : 'secondary'}>{product.isActive ? 'Active' : 'Inactive'}</Badge>`

**Hot badge:** `{product.isHot && <Badge variant="outline">Hot</Badge>}` — only render when truthy.

**Edit action:** Use `<Link href={`/admin/products/${product.id}/edit`}><Button variant="ghost" size="sm" aria-label={`Edit ${getLocalizedName(product.title)}`}><Pencil className="h-4 w-4" /></Button></Link>`

**Activate/Deactivate toggle:** Render one button that changes based on `product.isActive`. When active, show "Deactivate" button (calls `onDeactivate`). When inactive, show "Activate" button (calls `onActivate`). Both use `<Power className="h-4 w-4" />` icon. Both are disabled when `actionLoadingId === product.id`.

**Delete button:** Uses `<Trash2 />` icon, calls `onDelete(product)`. Disabled when `actionLoadingId === product.id`.

**Date column:** `{product.createdAt ? new Date(product.createdAt).toLocaleDateString() : '—'}`

**Search + filter bar:** Render above the table. Search uses a standard controlled `<Input>` (no debounce in the component — debounce is handled in the parent page). Status filter uses shadcn/ui `Select` with sentinel value pattern.

**Pagination:** Render below the table, only when `totalPages > 1`. Use the existing `<Pagination>` component from `@/components/ui/pagination`.

**Run tests:**
```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npx jest --testPathPatterns AdminProductsTable.test
```

---

### Step 5 — Create `AdminProductsPage` (TDD: test first)

#### Step 5a — Write `page.test.tsx`

**File to create:** `frontend/app/admin/products/page.test.tsx`

**Pattern to follow:** `frontend/app/admin/product-types/page.test.tsx` exactly.

**Mock setup:**

```typescript
import { render, screen, waitFor, act } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import AdminProductsPage from './page';
import { adminProductService } from '../../../lib/services/adminProductService';
import type { components } from '../../../lib/api/types';

type Product = components['schemas']['Product'];
type ProductListResponse = components['schemas']['ProductListResponse'];

jest.mock('../../../lib/services/adminProductService', () => ({
  adminProductService: {
    list: jest.fn(),
    activate: jest.fn(),
    deactivate: jest.fn(),
    delete: jest.fn(),
  },
}));
```

**Mock fixtures:**

```typescript
import { createProduct, createProducts } from '../../../components/product/testing/fixtures';

const mockResponse: ProductListResponse = {
  data: createProducts(3),
  meta: { page: 1, limit: 20, total: 3, totalPages: 1 },
};
```

**Test cases:**

`describe('AdminProductsPage')`:
- should call `adminProductService.list` on mount
- should pass `{ page: 1, limit: 20 }` as default params to `list()`
- should display product titles after successful fetch
- should show loading skeleton during fetch (check `role="status"` is present before data loads)
- should show error alert when list() rejects
- should show Retry button in error state
- should call `list()` again when Retry button is clicked
- should call `adminProductService.activate` with product ID when Activate is clicked
- should refresh the product list after activate succeeds (list called twice)
- should call `adminProductService.deactivate` with product ID when Deactivate is clicked
- should refresh the product list after deactivate succeeds
- should open DeleteProductDialog when Delete is clicked
- should call `adminProductService.delete` when deletion is confirmed in the dialog
- should refresh list after delete
- should close the dialog after delete
- should update search state and re-fetch when search input changes (debounced)
- should pass `isActive: true` to `list()` when status filter is "active"
- should pass `isActive: false` to `list()` when status filter is "inactive"
- should not pass `isActive` param when status filter is "all"
- should update current page state and re-fetch when page changes

**Note on debounce testing:** The page uses `setTimeout`/`clearTimeout` (300ms). In tests, use `jest.useFakeTimers()` in `beforeEach` and `jest.runAllTimers()` to trigger the debounced call. Remember to restore with `jest.useRealTimers()` in `afterEach`.

**Note on act() warnings:** React 19 async state updates produce act() warnings in tests — these are expected and not failures (documented in project memory).

#### Step 5b — Implement `AdminProductsPage`

**File to create:** `frontend/app/admin/products/page.tsx`

**Pattern:** Follow `frontend/app/admin/product-types/page.tsx` exactly, with additions for search, status filter, pagination, and activate/deactivate.

**Imports:**

```typescript
'use client';

import { useEffect, useState, useCallback, useRef } from 'react';
import type { components, operations } from '@/lib/api/types';
import { adminProductService } from '@/lib/services/adminProductService';
import { AdminProductsTable } from '@/components/admin/products/AdminProductsTable';
import { DeleteProductDialog } from '@/components/admin/products/DeleteProductDialog';
```

**Type aliases:**

```typescript
type Product = components['schemas']['Product'];
type PaginationMeta = components['schemas']['PaginationMeta'];
type ListProductsParams = NonNullable<operations['listProducts']['parameters']['query']>;
```

**State:**

```typescript
const [products, setProducts] = useState<Product[]>([]);
const [meta, setMeta] = useState<PaginationMeta>({});
const [isLoading, setIsLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
const [actionLoadingId, setActionLoadingId] = useState<string | null>(null);

const [isDeleteOpen, setIsDeleteOpen] = useState(false);
const [deletingProduct, setDeletingProduct] = useState<Product | null>(null);

// Filter state
const [search, setSearch] = useState('');
const [statusFilter, setStatusFilter] = useState<'all' | 'active' | 'inactive'>('all');
const [currentPage, setCurrentPage] = useState(1);

// Debounce ref
const searchDebounceRef = useRef<ReturnType<typeof setTimeout> | null>(null);
```

**`fetchProducts` callback:**

```typescript
const fetchProducts = useCallback(async (params: ListProductsParams) => {
  setIsLoading(true);
  setError(null);
  try {
    const response = await adminProductService.list(params);
    setProducts(response.data ?? []);
    setMeta(response.meta ?? {});
  } catch {
    setError('Failed to load products');
  } finally {
    setIsLoading(false);
  }
}, []);
```

**Build params helper:**

```typescript
const buildParams = useCallback((): ListProductsParams => {
  const params: ListProductsParams = { page: currentPage, limit: 20 };
  if (search) params.search = search;
  if (statusFilter === 'active') params.isActive = true;
  if (statusFilter === 'inactive') params.isActive = false;
  return params;
}, [currentPage, search, statusFilter]);
```

**Effects:**

```typescript
// Re-fetch when page or status filter changes (immediate, no debounce)
useEffect(() => {
  fetchProducts(buildParams());
}, [currentPage, statusFilter]); // eslint-disable-line react-hooks/exhaustive-deps

// Re-fetch when search changes (debounced 300ms), reset to page 1
useEffect(() => {
  if (searchDebounceRef.current) clearTimeout(searchDebounceRef.current);
  searchDebounceRef.current = setTimeout(() => {
    setCurrentPage(1);
    fetchProducts(buildParams());
  }, 300);
  return () => {
    if (searchDebounceRef.current) clearTimeout(searchDebounceRef.current);
  };
}, [search]); // eslint-disable-line react-hooks/exhaustive-deps
```

**Note on useEffect dependencies:** The exhaustive-deps lint rule is intentionally suppressed in both effects to avoid infinite loops. `fetchProducts` is wrapped in `useCallback` with no dependencies, and `buildParams` reads state directly. This is the same approach used in `CatalogPage` (`frontend/app/products/page.tsx`).

**Handlers:**

```typescript
const handleActivate = async (product: Product) => {
  if (!product.id) return;
  setActionLoadingId(product.id);
  try {
    await adminProductService.activate(product.id);
    fetchProducts(buildParams());
  } catch {
    // Silently handle for now — could show a toast in future
  } finally {
    setActionLoadingId(null);
  }
};

const handleDeactivate = async (product: Product) => {
  if (!product.id) return;
  setActionLoadingId(product.id);
  try {
    await adminProductService.deactivate(product.id);
    fetchProducts(buildParams());
  } catch {
    // Silently handle for now
  } finally {
    setActionLoadingId(null);
  }
};

const handleDelete = (product: Product) => {
  setDeletingProduct(product);
  setIsDeleteOpen(true);
};

const handleDeleteSuccess = () => {
  fetchProducts(buildParams());
};

const handleSearchChange = (value: string) => {
  setSearch(value);
};

const handleStatusChange = (value: 'all' | 'active' | 'inactive') => {
  setStatusFilter(value);
  setCurrentPage(1);
};

const handlePageChange = (page: number) => {
  setCurrentPage(page);
};

const handleRetry = () => {
  fetchProducts(buildParams());
};
```

**JSX return:**

```typescript
return (
  <div>
    <h1 className="text-2xl font-bold mb-6">Products</h1>

    <AdminProductsTable
      products={products}
      isLoading={isLoading}
      error={error}
      onRetry={handleRetry}
      onActivate={handleActivate}
      onDeactivate={handleDeactivate}
      onDelete={handleDelete}
      actionLoadingId={actionLoadingId}
      search={search}
      onSearchChange={handleSearchChange}
      statusFilter={statusFilter}
      onStatusChange={handleStatusChange}
      currentPage={currentPage}
      totalPages={meta.totalPages ?? 1}
      onPageChange={handlePageChange}
    />

    <DeleteProductDialog
      open={isDeleteOpen}
      onOpenChange={setIsDeleteOpen}
      product={deletingProduct}
      onSuccess={handleDeleteSuccess}
    />
  </div>
);
```

**Run tests:**
```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npx jest --testPathPatterns "app/admin/products/page.test"
```

---

### Step 6 — Update `AdminSidebar` to add Products nav item

**File to modify:** `frontend/components/admin/AdminSidebar.tsx`

**What to change:** Add a new entry to the `navItems` array before (or after) the existing "Product Types" entry. The icon to use is `ShoppingBag` from `lucide-react` (currently only `Package` is imported).

**Update the import:**
```typescript
import { Package, ShoppingBag } from 'lucide-react';
```

**Add to `navItems` array (insert before Product Types for logical ordering):**
```typescript
{
  label: 'Products',
  href: '/admin/products',
  icon: <ShoppingBag className="h-4 w-4" />,
},
```

**No test file change needed** — the existing AdminSidebar test (if any) or the fact that the component is rendered in existing admin pages is sufficient. If there is an `AdminSidebar.test.tsx`, add one test: "should render Products link with href /admin/products".

**Check for existing sidebar test:**
```bash
ls /Users/pb/Developer/FiveGuays/memes/frontend/components/admin/
```

---

### Step 7 — Run full test suite and build check

**Run all frontend tests:**
```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npm test
```

All tests must pass. Known acceptable warnings:
- React 19 act() warnings in test output (not failures)

**Run linting:**
```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npm run lint
```

**Run build:**
```bash
cd /Users/pb/Developer/FiveGuays/memes/frontend && npm run build
```

The build must succeed with zero errors.

---

### Key Patterns Summary

| Pattern | Source | Where Used |
|---------|--------|------------|
| Service with `apiClient.get/post/delete` | `productTypeService.ts` | `adminProductService.ts` |
| Param stripping (`filter(([, v]) => v !== undefined)`) | `productService.ts` | `adminProductService.list()` |
| Page state management with `fetchX` callback | `product-types/page.tsx` | `admin/products/page.tsx` |
| Loading skeleton with `role="status"` | `ProductTypesTable.tsx` | `AdminProductsTable.tsx` |
| Error state with `Alert` + Retry button | `ProductTypesTable.tsx` | `AdminProductsTable.tsx` |
| Delete dialog with `isDeleting` + `ApiException` | `DeleteProductTypeDialog.tsx` | `DeleteProductDialog.tsx` |
| Radix Select sentinel value (`__all__`) | `ProductFilters.tsx` | `AdminProductsTable.tsx` status filter |
| Radix Select JSDOM mock | `ProductFilters.test.tsx` | `AdminProductsTable.test.tsx` |
| Test fixtures (`createProduct`, `createProducts`) | `fixtures.ts` | All test files |
| Debounced search with `useRef<ReturnType<typeof setTimeout>>` | — | `admin/products/page.tsx` |
| `getLocalizedName(product.title)` | `ProductTypesTable.tsx` | `AdminProductsTable.tsx` |
| `formatPrice(product.price)` | `ProductCard.tsx` | `AdminProductsTable.tsx` |

### Important Notes

1. **`isActive` in `listProducts` params**: After Step 1 regenerates the types, `ListProductsParams` will include `isActive?: boolean`. The `adminProductService.list()` method receives it as part of the same `ListProductsParams` type used by `productService.list()`. No custom type is needed.

2. **`adminProductService` vs `productService`**: Two separate services are intentional. `adminProductService` is used exclusively in admin pages and will grow with activate/deactivate/delete. `productService` remains the public-facing service used in the catalog.

3. **Activate/deactivate response shape**: The API returns `ProductResponse = { data?: Product }`. Extract with `.data.data` (Axios wraps in `.data`, then the API envelope has another `.data`).

4. **Delete is soft**: `DELETE /products/{productId}` is a soft delete (204, no body). The product remains in the database and can be restored via `POST /products/{productId}/restore`. The Delete button does NOT need a "restore" flow in this ticket — that is out of scope for F3.8.

5. **No `RestoreProduct` in scope for F3.8**: The `restoreProduct` operation exists in the API types but is not required here. Only list/activate/deactivate/delete are in scope.

6. **`actionLoadingId`**: The page tracks which product is currently being acted on (activate/deactivate/delete in progress) and passes it to `AdminProductsTable`. The table uses it to disable all three action buttons for that specific row, preventing double-clicks.

7. **Pagination limit**: Use `limit: 20` for the admin view (not 12 like the public catalog). Admin tables typically show more rows.

8. **`next/image` in tests**: Must mock `next/image` in `AdminProductsTable.test.tsx` — same pattern as other product component tests. Filter out `fill` and `sizes` props to avoid JSDOM warnings.

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing
- [x] Code follows project standards (TDD, full types, English only)
- [x] No linting errors
- [x] Build succeeds

---

*Ticket created: 2026-02-17*
