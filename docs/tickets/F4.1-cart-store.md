# F4.1: Create cartStore (Zustand with persistence)

**Sprint:** 4
**Type:** Frontend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint4-F4.1-cart-store
**Created:** 2026-02-19
**Dependencies:** None

---

## Description

Create a client-side cart store using Zustand with localStorage persistence. This is the foundation for all cart/checkout frontend tasks (F4.2–F4.8). The cart is entirely client-side — the backend receives `{ productId, quantity, size? }[]` items for validation/calculation but does not store cart state.

The store must hold enough product data per item for UI rendering (title, price, image, slug) without requiring server round-trips.

---

## Acceptance Criteria

- [x] `useCartStore` created at `frontend/stores/cartStore.ts`
- [x] Cart state persists to localStorage via Zustand `persist` middleware
- [x] SSR-compatible with `skipHydration: true` (matches `authStore` pattern)
- [x] `addItem` — adds new item or increments quantity if same productId+size exists
- [x] `removeItem` — removes item by productId+size
- [x] `updateQuantity` — updates quantity for a specific item; removes if quantity <= 0
- [x] `clearCart` — resets cart to empty state
- [x] Computed getters: `itemCount` (total quantity), `subtotal` (sum of price × quantity, rounded to 2dp)
- [x] Cart item shape includes: productId, slug, title, price, primaryImage, size, quantity
- [x] `partialize` excludes transient state from persistence
- [x] Types exported: `CartItemLocal`, `CartState`, `CartActions`, `CartStore`, `MAX_ITEM_QUANTITY`
- [x] Quantity capped at MAX_ITEM_QUANTITY (99) in addItem and updateQuantity
- [x] Unit tests for all actions and edge cases (24 tests)
- [x] All tests pass (630 total)
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `frontend/stores/cartStore.ts` | Zustand cart store with persist middleware |
| `frontend/stores/cartStore.test.ts` | Unit tests for cart store |

---

## Implementation Steps

### Step 1: Define types
1. Define `CartItemLocal` — client-side cart item shape with fields needed for rendering
2. Define `CartState` — items array + computed getters
3. Define `CartActions` — addItem, removeItem, updateQuantity, clearCart
4. Combine as `CartStore = CartState & CartActions`

### Step 2: Implement store
1. Create store with `persist` + `createJSONStorage(() => localStorage)` + `skipHydration: true`
2. Implement `addItem` — upsert logic: increment quantity if same productId+size, else append
3. Implement `removeItem` — filter by productId+size
4. Implement `updateQuantity` — map/filter: update quantity, remove if <= 0
5. Implement `clearCart` — reset to `initialState`
6. Implement computed `itemCount` and `subtotal` from items array
7. Configure `partialize` to persist only `items`

### Step 3: Write tests (TDD)
1. Test initial state is empty
2. Test `addItem` adds a new item
3. Test `addItem` increments quantity for duplicate productId+size
4. Test `addItem` treats same productId with different size as separate items
5. Test `removeItem` removes correct item
6. Test `removeItem` by productId+size (not just productId)
7. Test `updateQuantity` changes quantity
8. Test `updateQuantity` removes item when quantity <= 0
9. Test `clearCart` resets to empty
10. Test `itemCount` returns total quantity across items
11. Test `subtotal` returns sum of price × quantity

---

## Technical Notes

- **Follow `authStore` pattern exactly**: persist, createJSONStorage, skipHydration, partialize, State/Actions split, initialState constant
- **No `devtools` wrapper**: production stores in this project don't use devtools
- **Item identity**: Items are uniquely identified by `productId + size` combination (same product in different sizes = different cart items)
- **Price stored at add-time**: The `price` field captures the product price when added; validation endpoint will confirm current price at checkout
- **Types from OpenAPI**: Reference `components['schemas']['ProductImage']` for the primaryImage field type
- **Test pattern**: Use `act()` from `@testing-library/react`, reset via `clearCart()` in `beforeEach`, read state via `.getState()`

---

## Implementation Plan

### Overview

TDD (Red-Green-Refactor). Tests first, then implementation. Follows `authStore` pattern exactly: `create<Store>()(persist(...))` with `createJSONStorage`, `skipHydration: true`, `partialize`, State/Actions split, `initialState` constant. No devtools.

### Phase 1: Types (`cartStore.ts`)

```typescript
import type { components } from '../lib/api/types';
type ProductImage = components['schemas']['ProductImage'];

export interface CartItemLocal {
  productId: string;                    // UUID
  slug: string;                         // for URL navigation
  title: string;                        // localized title (resolved at add-time)
  price: number;                        // price at add-time
  primaryImage: ProductImage | null;    // for rendering
  size: string | null;                  // null if product has no sizes
  quantity: number;                     // >= 1
}

export interface CartState {
  items: CartItemLocal[];
  itemCount: number;   // derived: total quantity
  subtotal: number;    // derived: sum(price * quantity)
}

export interface CartActions {
  addItem: (item: Omit<CartItemLocal, 'quantity'>, quantity?: number) => void;
  removeItem: (productId: string, size: string | null) => void;
  updateQuantity: (productId: string, size: string | null, quantity: number) => void;
  clearCart: () => void;
}

export type CartStore = CartState & CartActions;
```

### Phase 2: Helpers (private, not exported)

- `computeDerived(items)` — returns `{ itemCount, subtotal }` from items array
- `itemMatches(item, productId, size)` — identity check by productId + size

### Phase 3: Store Creation

- `initialState: CartState = { items: [], itemCount: 0, subtotal: 0 }`
- `addItem(itemData, quantity=1)` — find existing by productId+size; if found, increment quantity; else append. Recompute derived.
- `removeItem(productId, size)` — filter out matching item. Recompute derived.
- `updateQuantity(productId, size, quantity)` — if quantity <= 0, remove item; else update. Recompute derived.
- `clearCart()` — `set(initialState)`
- Persist config: `name: 'cart-storage'`, `createJSONStorage(() => localStorage)`, `partialize: (state) => ({ items: state.items })`, `skipHydration: true`, `onRehydrateStorage` callback to recompute derived values after hydration.

### Phase 4: Tests (`cartStore.test.ts`) — 21 cases

**Fixtures:** `itemTShirtM` (prod-1, size M, $24.99), `itemTShirtL` (prod-1, size L, $24.99), `itemMug` (prod-2, size null, $14.99)

| Suite | Test | Expected |
|-------|------|----------|
| initial state | empty cart | items: [], itemCount: 0, subtotal: 0 |
| addItem | add new item default qty | 1 item, qty 1, subtotal 24.99 |
| addItem | add with specified qty | qty 3, subtotal 74.97 |
| addItem | duplicate productId+size | 1 item, qty 2, subtotal 49.98 |
| addItem | same product different size | 2 items, itemCount 2 |
| addItem | null size item | size === null |
| addItem | duplicate null size | 1 item, qty 2 |
| removeItem | by productId+size | empty cart |
| removeItem | only matching size | 1 item remaining (other size) |
| removeItem | null size | empty cart |
| removeItem | no effect on other items | other item preserved |
| removeItem | no-op if not found | unchanged |
| updateQuantity | update to new value | qty 5, subtotal 124.95 |
| updateQuantity | qty 0 removes | empty cart |
| updateQuantity | negative qty removes | empty cart |
| updateQuantity | only matching item | other items unaffected |
| updateQuantity | no-op if not found | unchanged |
| clearCart | reset to empty | items: [], itemCount: 0, subtotal: 0 |
| computed | itemCount = total qty | 2+1 = 3 |
| computed | subtotal = sum(price*qty) | 24.99*2 + 14.99 = 64.97 |
| computed | 0s when empty | itemCount: 0, subtotal: 0 |

### Phase 5: TDD Execution Order

1. Create test file with all 21 tests (RED)
2. Create store file with types + helpers + store (GREEN)
3. Run `cd frontend && npx jest --testPathPatterns cartStore`
4. Refactor if needed
5. Run full suite: `cd frontend && npm test`
6. Run lint: `cd frontend && npm run lint`
7. Run build: `cd frontend && npm run build`

### Edge Cases

- **Floating-point**: `24.99 * 2 = 49.98` is exact in JS. Backend does authoritative price math at checkout.
- **onRehydrateStorage**: Recomputes `itemCount`/`subtotal` after localStorage hydration since only `items` is persisted.
- **null === null**: Works correctly for null-size product identity matching.
- **No server sync**: Purely client-side. Backend validation (`POST /cart/validate`) is called in F4.5+.

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing (24 tests, 630 total)
- [x] Code follows project standards (authStore pattern)
- [x] No linting errors
- [x] Build succeeds

---

*Ticket created: 2026-02-19*
