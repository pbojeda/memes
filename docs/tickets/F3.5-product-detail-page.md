# F3.5: Create Product Detail Page

**Sprint:** 3
**Type:** Frontend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint3-F3.5-product-detail-page
**Created:** 2026-02-17
**Dependencies:** F3.6 (ImageGallery) ✅, F3.7 (ReviewList) ✅

---

## Description

Create the public product detail page at `/products/[slug]`. This page composes existing components (ImageGallery, ReviewList) with product information (title, description, price, sizes, color, Hot badge). It fetches product data via `GET /products/{slug}` (public, no auth) which returns a `ProductDetailResponse` containing the full product with images and reviews.

The page uses Next.js App Router dynamic route `app/products/[slug]/page.tsx`.

---

## Acceptance Criteria

- [x] Page renders at `/products/[slug]` route
- [x] Fetches product detail via `productService.getBySlug(slug)`
- [x] Displays product title (localized via `getLocalizedName`)
- [x] Displays product description (localized)
- [x] Displays price (formatted EUR) and compare-at-price (strikethrough)
- [x] Displays available sizes as selectable badges
- [x] Displays color information
- [x] Shows "Hot" badge when `isHot` is true
- [x] Shows product type name
- [x] Composes `ImageGallery` component with product images
- [x] Composes `ReviewList` component with product ID
- [x] Loading state with skeleton placeholders
- [x] Error state with retry option
- [x] 404 state when product not found
- [x] Back-to-catalog link
- [x] Unit tests for all states and interactions
- [x] All tests pass
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `frontend/app/products/[slug]/page.tsx` | Product detail page component |
| `frontend/app/products/[slug]/page.test.tsx` | Tests for product detail page |
| `frontend/lib/services/productService.ts` | Add `getBySlug()` method |
| `frontend/components/product/index.ts` | Re-export if needed |

---

## Implementation Steps

### Step 1: Add `getBySlug` to productService
1. Add `getBySlug(slug: string): Promise<ProductDetailResponse>` method
2. Calls `GET /products/{slug}` via apiClient
3. Returns `ProductDetailResponse`

### Step 2: Create Product Detail Page
1. Create `app/products/[slug]/page.tsx`
2. Server component that extracts slug from params
3. Client component (`ProductDetailContent`) handles data fetching and state
4. Compose: ImageGallery (images), product info (title, desc, price, sizes), ReviewList (productId)
5. Loading skeleton, error state, 404 state

### Step 3: Write Tests
1. Test loading state renders skeleton
2. Test successful product render (all fields)
3. Test ImageGallery receives images
4. Test ReviewList receives productId
5. Test Hot badge shown/hidden
6. Test compare-at-price strikethrough
7. Test available sizes display
8. Test error state with retry
9. Test 404 state
10. Test back-to-catalog link
11. Test localized title/description

---

## Technical Notes

- **API endpoint:** `GET /products/{slug}` — public, no auth, returns `ProductDetailResponse`
- **ProductDetail** = Product + `images: ProductImage[]` + `reviews: Review[]`
- **Localization:** Use `getLocalizedName()` from `lib/utils.ts` for title and description
- **Price format:** Use `formatPrice()` (same pattern as ProductCard — Intl.NumberFormat es-ES EUR)
- **Components:** ImageGallery takes `images?: ProductImage[]`, ReviewList takes `productId: string`
- **Dynamic route:** Next.js App Router `[slug]` param — `params.slug`
- **Pattern:** Follow catalog page pattern — client component with loading/error states

---

## Implementation Plan

### Overview

The implementation follows strict TDD (Red-Green-Refactor). Tests are written first for each piece, then the implementation is added to make them pass. The page uses the same client-component-with-loading/error-state pattern as the catalog page.

---

### Component Hierarchy

```
app/products/[slug]/page.tsx          ← Thin server wrapper (extracts params.slug)
  └── ProductDetailContent            ← Client component ('use client'), all state logic
        ├── Loading state             ← Skeleton layout (no service call yet)
        ├── Error state               ← Alert + Retry button (same pattern as catalog)
        ├── Not-found state           ← Dedicated 404 message + back link
        └── Populated state
              ├── <Link href="/products">← Back to catalog
              ├── <ImageGallery images={product.images} />
              ├── Product info section
              │     ├── Hot badge (Badge variant="destructive", shown when isHot)
              │     ├── Product type name (ProductTypeSummary.name via getLocalizedName)
              │     ├── Title (h1, getLocalizedName)
              │     ├── Description (getLocalizedName)
              │     ├── Price row (formatPrice + compareAtPrice strikethrough)
              │     ├── Color
              │     └── Available sizes (Badge per size, hasSizes guard)
              └── <ReviewList productId={product.id} />
```

---

### Step 1 — Add `getBySlug` to `productService` (TDD)

**File:** `frontend/lib/services/productService.ts`

#### 1a. Write failing tests first

There are no existing tests for `productService` — create a new test file `frontend/lib/services/productService.test.ts`.

**Mocks needed:**
- `jest.mock('../api/client')` — mock `apiClient` with a typed mock object

**Tests to write:**

| # | Test name | What it verifies |
|---|-----------|------------------|
| 1 | `getBySlug should call GET /products/{slug}` | `apiClient.get` called with `/products/funny-cat` |
| 2 | `getBySlug should return ProductDetailResponse data` | Resolves with the data from `apiClient.get` |
| 3 | `getBySlug should propagate errors from apiClient` | Rejects when `apiClient.get` rejects |

**Test setup pattern** (follow `reviewService` pattern if it exists, otherwise follow `productService.list` call pattern):

```typescript
import { apiClient } from '../api/client';
import { productService } from './productService';
import type { components } from '../api/types';

jest.mock('../api/client', () => ({
  apiClient: { get: jest.fn(), post: jest.fn() },
}));

const mockApiClient = apiClient as jest.Mocked<typeof apiClient>;
```

**Important:** `apiClient.get` returns `{ data: ProductDetailResponse }` (Axios response shape), so the mock must return `Promise.resolve({ data: mockResponse })`.

#### 1b. Implement `getBySlug`

Add the following method to the `productService` object in `frontend/lib/services/productService.ts`:

```typescript
async getBySlug(slug: string): Promise<ProductDetailResponse> {
  const response = await apiClient.get<ProductDetailResponse>(`/products/${slug}`);
  return response.data;
},
```

Type alias to add at the top of the file:
```typescript
type ProductDetailResponse = components['schemas']['ProductDetailResponse'];
```

**Note:** Do NOT use `encodeURIComponent` on the slug — the backend expects the plain slug string and the axios client handles URL encoding.

---

### Step 2 — Product Detail Page (TDD)

**Files:**
- `frontend/app/products/[slug]/page.test.tsx` (write first)
- `frontend/app/products/[slug]/page.tsx` (write to make tests pass)

#### 2a. Test file setup

**File:** `frontend/app/products/[slug]/page.test.tsx`

**Mocks block — must appear before any imports of the page:**

```typescript
// 1. Mock next/navigation — page uses useParams to get slug
jest.mock('next/navigation', () => ({
  useParams: jest.fn(() => ({ slug: 'funny-cat-meme-tshirt' })),
  useRouter: jest.fn(() => ({ push: jest.fn() })),
}));

// 2. Mock productService
jest.mock('../../lib/services/productService', () => ({
  productService: { list: jest.fn(), getBySlug: jest.fn() },
}));

// 3. Mock ImageGallery — isolate page logic
jest.mock('../../components/product/ImageGallery', () => ({
  ImageGallery: ({ images }: { images?: unknown[] }) => (
    <div data-testid="image-gallery" data-image-count={images?.length ?? 0} />
  ),
}));

// 4. Mock ReviewList — isolate page logic
jest.mock('../../components/product/ReviewList', () => ({
  ReviewList: ({ productId }: { productId: string }) => (
    <div data-testid="review-list" data-product-id={productId} />
  ),
}));

// 5. Mock next/link
jest.mock('next/link', () => {
  return function MockLink({ children, href, ...props }: {
    children: React.ReactNode; href: string; className?: string;
  }) {
    return <a href={href} {...props}>{children}</a>;
  };
});

// 6. Mock next/image (filter fill/sizes props)
jest.mock('next/image', () => {
  return function MockImage({ fill, sizes, ...props }: Record<string, unknown>) {
    return <img {...(props as React.ImgHTMLAttributes<HTMLImageElement>)} />;
  };
});

// 7. Mock lucide-react icons used by the page
jest.mock('lucide-react', () => ({
  ArrowLeft: (props: Record<string, unknown>) => <svg data-testid="arrow-left-icon" {...props} />,
  // Add others if used directly in the page (AlertCircle, etc.)
}));
```

**Imports after mocks:**
```typescript
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { useParams } from 'next/navigation';
import ProductDetailPage from './page';
import { productService } from '../../lib/services/productService';
import { createProduct, createProductImages } from '../../components/product/testing/fixtures';
import type { components } from '../../lib/api/types';
```

**Helper — `createProductDetail`:**

The test file needs a helper that creates a `ProductDetail` (which is `Product & { images?, reviews? }`). Add this helper near the top of the test file (after imports):

```typescript
type ProductDetail = components['schemas']['ProductDetail'];
type ProductDetailResponse = components['schemas']['ProductDetailResponse'];

const createProductDetail = (overrides: Partial<ProductDetail> = {}): ProductDetail => ({
  ...createProduct(),
  productType: { id: 'pt-1', name: 'T-Shirts', slug: 'tshirts', hasSizes: true },
  description: 'A great meme t-shirt',
  availableSizes: ['S', 'M', 'L'],
  color: 'white',
  images: createProductImages(2),
  ...overrides,
});

const createDetailResponse = (product: ProductDetail): ProductDetailResponse => ({
  data: product,
});
```

**`beforeEach` setup:**

```typescript
beforeEach(() => {
  jest.clearAllMocks();
  // Default: useParams returns the slug
  (useParams as jest.Mock).mockReturnValue({ slug: 'funny-cat-meme-tshirt' });
  // Default: getBySlug resolves with a full product
  (productService.getBySlug as jest.Mock).mockResolvedValue(
    createDetailResponse(createProductDetail())
  );
});
```

#### 2b. Tests to write and their corresponding implementation steps

Tests are grouped by feature. Write each group of tests, then implement the feature to make them pass.

---

**Group A — Loading state** (implement skeleton first)

| # | Test name | What it verifies |
|---|-----------|------------------|
| A1 | `should show loading skeleton while fetching` | `role="status"` present initially (mock `getBySlug` as never-resolving promise) |
| A2 | `should show multiple skeleton placeholder elements` | At least 2 elements with `animate-pulse` class visible during load |

**Implementation note:** Use `getBySlug: () => new Promise(() => {})` to freeze in loading state. The skeleton should have `role="status"` and an `<span className="sr-only">Loading product...</span>` for accessibility, mirroring the `ReviewList` loading pattern.

---

**Group B — Successful product render (core fields)**

| # | Test name | What it verifies |
|---|-----------|------------------|
| B1 | `should call productService.getBySlug with slug from useParams` | `getBySlug` called with `'funny-cat-meme-tshirt'` |
| B2 | `should display product title as h1` | `screen.getByRole('heading', { level: 1 })` has title text |
| B3 | `should display product description` | Description text is in the document |
| B4 | `should display formatted EUR price` | Text matching `/24,99\s€/` is present |
| B5 | `should display compare-at price with strikethrough` | Text matching `/34,99\s€/` has class `line-through` |
| B6 | `should not display compare-at price when absent` | Only one element matching `/€/` |
| B7 | `should not display compare-at price when not higher than price` | `compareAtPrice <= price` → no strikethrough |
| B8 | `should display product type name` | `'T-Shirts'` text in document |
| B9 | `should display color` | `'white'` or a color label + value in document |

**Implementation note for B4/B5:** The page must define or import `formatPrice`. Per `key_facts.md`, `formatPrice` is co-located in `ProductCard.tsx` and should be extracted to `lib/utils.ts` when reused. Since this is the second usage, the implementation must:
1. Move `formatPrice` from `ProductCard.tsx` to `frontend/lib/utils.ts` (export it)
2. Update `ProductCard.tsx` to import `formatPrice` from `@/lib/utils`
3. Import `formatPrice` from `@/lib/utils` in the page

---

**Group C — Hot badge**

| # | Test name | What it verifies |
|---|-----------|------------------|
| C1 | `should show "Hot" badge when isHot is true` | `screen.getByText('Hot')` is in document |
| C2 | `should not show "Hot" badge when isHot is false` | `screen.queryByText('Hot')` is null |

---

**Group D — Available sizes**

| # | Test name | What it verifies |
|---|-----------|------------------|
| D1 | `should display each available size as a badge` | `screen.getByText('S')`, `getByText('M')`, `getByText('L')` are in document |
| D2 | `should not render sizes section when availableSizes is empty` | No size badges when `availableSizes: []` |
| D3 | `should not render sizes section when hasSizes is false` | No size badges when `productType.hasSizes: false` |

**Implementation note for D3:** The sizes section should only render when `productType?.hasSizes === true` AND `availableSizes` is non-empty. This prevents showing an empty sizes section for product types without sizes.

---

**Group E — ImageGallery composition**

| # | Test name | What it verifies |
|---|-----------|------------------|
| E1 | `should render ImageGallery with product images` | `data-testid="image-gallery"` with `data-image-count="2"` |
| E2 | `should render ImageGallery with empty images when product has none` | `data-image-count="0"` when `images: undefined` |

---

**Group F — ReviewList composition**

| # | Test name | What it verifies |
|---|-----------|------------------|
| F1 | `should render ReviewList with product id` | `data-testid="review-list"` with `data-product-id="prod-1"` |

---

**Group G — Back-to-catalog link**

| # | Test name | What it verifies |
|---|-----------|------------------|
| G1 | `should render a back-to-catalog link pointing to /products` | `screen.getByRole('link', { name: /back/i })` with `href="/products"` |

---

**Group H — Error state**

| # | Test name | What it verifies |
|---|-----------|------------------|
| H1 | `should show error alert when getBySlug rejects` | `role="alert"` present after rejection |
| H2 | `should show retry button in error state` | Button with name `/retry/i` present |
| H3 | `should refetch when retry is clicked` | `getBySlug` called twice after retry click |
| H4 | `should clear error and show product after successful retry` | Product title appears after retry resolves |

---

**Group I — 404 state**

| # | Test name | What it verifies |
|---|-----------|------------------|
| I1 | `should show not-found message when getBySlug throws 404` | Text like `/product not found/i` in document |
| I2 | `should show link to catalog in not-found state` | Link to `/products` in 404 state |
| I3 | `should not show retry button in 404 state` | No retry button when 404 |

**Implementation note:** Detect 404 by catching `ApiException` from `lib/api/exceptions.ts` and checking `error.status === 404`. Use `import { ApiException } from '@/lib/api/exceptions'`. The 404 state is distinct from the generic error state — it shows a "Product not found" message without a retry button.

```typescript
// In catch block:
import { ApiException } from '@/lib/api/exceptions';

if (err instanceof ApiException && err.status === 404) {
  setNotFound(true);
} else {
  setError(err instanceof Error ? err.message : 'Failed to load product');
}
```

**Mock for 404 test:**
```typescript
import { ApiException } from '../../lib/api/exceptions';
// ...
(productService.getBySlug as jest.Mock).mockRejectedValue(
  new ApiException('NOT_FOUND', 'Product not found', 404)
);
```

---

**Group J — Localization**

| # | Test name | What it verifies |
|---|-----------|------------------|
| J1 | `should handle localized title (object form)` | Title renders correctly when `title` is `{ es: 'Camiseta', en: 'T-Shirt' }` |
| J2 | `should handle localized description (object form)` | Description renders correctly when `description` is `{ es: 'Descripción', en: 'Description' }` |

**Implementation note:** Use `getLocalizedName(title, '')` and `getLocalizedName(description, '')` imported from `@/lib/utils`. The `Product.title` and `Product.description` fields are typed as `string?` in the generated types (because the API returns already-localized strings), but in tests we can cast to `any` to pass localized objects, mirroring the `ProductCard.test.tsx` pattern.

---

#### 2c. Page implementation details

**File:** `frontend/app/products/[slug]/page.tsx`

**Architecture decision:** The page file exports a default `ProductDetailPage` component. Internally it uses `useParams` from `next/navigation` (not server-side `params` prop), so the entire file is a single client component marked `'use client'`. This is the simplest approach that avoids needing a server/client component split for this ticket.

**Reasoning:** The catalog page (`app/products/page.tsx`) is entirely `'use client'` and uses `useSearchParams`. The same pattern applies here with `useParams`. A server+client split (server extracts params, passes to client) would work but adds complexity not needed for a public page with no SSR requirement.

**State variables:**
```typescript
const [product, setProduct] = useState<ProductDetail | null>(null);
const [loading, setLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
const [notFound, setNotFound] = useState(false);
```

**Type aliases:**
```typescript
type ProductDetail = components['schemas']['ProductDetail'];
```

**Fetch effect:**
```typescript
useEffect(() => {
  const fetchProduct = async () => {
    setLoading(true);
    setError(null);
    setNotFound(false);
    try {
      const response = await productService.getBySlug(slug);
      setProduct(response.data ?? null);
    } catch (err) {
      if (err instanceof ApiException && err.status === 404) {
        setNotFound(true);
      } else {
        setError(err instanceof Error ? err.message : 'Failed to load product');
      }
    } finally {
      setLoading(false);
    }
  };
  fetchProduct();
}, [slug]);
```

**Slug extraction:**
```typescript
const params = useParams();
const slug = typeof params.slug === 'string' ? params.slug : '';
```

**Layout structure (populated state):**

```tsx
<main className="container mx-auto px-4 py-8">
  {/* Back link */}
  <Link href="/products" className="...">
    <ArrowLeft /> Back to catalog
  </Link>

  <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mt-6">
    {/* Left column: ImageGallery */}
    <ImageGallery images={product.images} />

    {/* Right column: Product info */}
    <div className="space-y-4">
      {/* Hot badge + product type */}
      <div className="flex items-center gap-2">
        {product.isHot && <Badge variant="destructive">Hot</Badge>}
        {product.productType?.name && (
          <span className="text-sm text-muted-foreground">
            {getLocalizedName(product.productType.name, '')}
          </span>
        )}
      </div>

      {/* Title */}
      <h1 className="text-3xl font-bold">{getLocalizedName(product.title, '')}</h1>

      {/* Price */}
      <div className="flex items-center gap-3">
        {product.price !== undefined && (
          <span className="text-2xl font-bold">{formatPrice(product.price)}</span>
        )}
        {product.compareAtPrice !== undefined &&
          product.price !== undefined &&
          product.compareAtPrice > product.price && (
          <span className="text-lg text-muted-foreground line-through">
            {formatPrice(product.compareAtPrice)}
          </span>
        )}
      </div>

      {/* Description */}
      {product.description && (
        <p className="text-muted-foreground">
          {getLocalizedName(product.description, '')}
        </p>
      )}

      {/* Color */}
      {product.color && (
        <div>
          <span className="font-medium">Color: </span>
          <span>{product.color}</span>
        </div>
      )}

      {/* Sizes (only when productType.hasSizes && availableSizes non-empty) */}
      {product.productType?.hasSizes && (product.availableSizes?.length ?? 0) > 0 && (
        <div>
          <span className="font-medium block mb-2">Sizes:</span>
          <div className="flex gap-2 flex-wrap">
            {product.availableSizes!.map((size) => (
              <Badge key={size} variant="outline">{size}</Badge>
            ))}
          </div>
        </div>
      )}
    </div>
  </div>

  {/* Reviews section */}
  <div className="mt-12">
    <ReviewList productId={product.id ?? ''} />
  </div>
</main>
```

**Loading skeleton layout:**

```tsx
<main className="container mx-auto px-4 py-8" role="status">
  <span className="sr-only">Loading product...</span>
  <div className="animate-pulse h-6 w-32 bg-muted rounded mb-6" />  {/* back link skeleton */}
  <div className="grid grid-cols-1 md:grid-cols-2 gap-8 mt-6">
    <div className="animate-pulse aspect-square bg-muted rounded" />  {/* image skeleton */}
    <div className="space-y-4">
      <div className="animate-pulse h-8 w-48 bg-muted rounded" />   {/* title skeleton */}
      <div className="animate-pulse h-6 w-24 bg-muted rounded" />   {/* price skeleton */}
      <div className="animate-pulse h-24 bg-muted rounded" />       {/* description skeleton */}
    </div>
  </div>
</main>
```

**Error state layout:**

```tsx
<main className="container mx-auto px-4 py-8">
  <Alert variant="destructive">
    <AlertTitle>Error</AlertTitle>
    <AlertDescription>Failed to load product. Please try again.</AlertDescription>
    <Button onClick={handleRetry} variant="outline" className="mt-4">Retry</Button>
  </Alert>
</main>
```

**Not-found state layout:**

```tsx
<main className="container mx-auto px-4 py-8">
  <div className="text-center py-16">
    <h1 className="text-2xl font-bold mb-4">Product not found</h1>
    <p className="text-muted-foreground mb-6">
      The product you are looking for does not exist or has been removed.
    </p>
    <Link href="/products">
      <Button variant="outline">Back to catalog</Button>
    </Link>
  </div>
</main>
```

---

### Step 3 — Extract `formatPrice` to `lib/utils.ts`

This must happen as part of the implementation of Step 2 (since the page imports it from `@/lib/utils`).

**Changes:**

1. In `frontend/lib/utils.ts`: Add `formatPrice` export.
2. In `frontend/components/product/ProductCard.tsx`: Remove local `formatPrice` definition, import from `@/lib/utils`.

**Test for `formatPrice` in `lib/utils.ts`** — NOT needed as a separate test file. The existing `ProductCard.test.tsx` already covers `formatPrice` behavior via integration (B4/B5 in the ProductCard tests cover formatting). The page tests (B4/B5 above) will also cover it implicitly. No isolated unit test for `formatPrice` is required since it is a trivial formatter.

**However**, if the existing `ProductCard.test.tsx` tests for `formatPrice` start failing after the refactor (e.g., import path changed), fix them — do not delete them.

---

### Step 4 — Final checks

After all tests pass:

1. Run `cd /path/to/frontend && npm test -- --testPathPatterns="products/\\[slug\\]"` to run only the new tests.
2. Run the full test suite: `cd /path/to/frontend && npm test` to check no regressions.
3. Run `cd /path/to/frontend && npm run lint` to check for lint errors.
4. Run `cd /path/to/frontend && npm run build` to verify the build.

---

### Files Summary

| File | Action | Notes |
|------|--------|-------|
| `frontend/lib/services/productService.ts` | Modify | Add `getBySlug(slug)` method + `ProductDetailResponse` type alias |
| `frontend/lib/services/productService.test.ts` | Create | New test file for `getBySlug` (3 tests) |
| `frontend/lib/utils.ts` | Modify | Extract + export `formatPrice` from `ProductCard.tsx` |
| `frontend/components/product/ProductCard.tsx` | Modify | Remove local `formatPrice`, import from `@/lib/utils` |
| `frontend/app/products/[slug]/page.tsx` | Create | Product detail page (client component) |
| `frontend/app/products/[slug]/page.test.tsx` | Create | ~30 tests covering all states and behaviors |

### Existing Components / Utilities Reused

| Item | Source | How reused |
|------|--------|------------|
| `ImageGallery` | `components/product/ImageGallery.tsx` | Rendered with `product.images` |
| `ReviewList` | `components/product/ReviewList.tsx` | Rendered with `product.id` |
| `Badge` | `components/ui/badge` | Hot badge + size badges |
| `Button` | `components/ui/button` | Retry button |
| `Alert`, `AlertTitle`, `AlertDescription` | `components/ui/alert` | Error state |
| `getLocalizedName` | `lib/utils.ts` | Title, description, product type name |
| `formatPrice` | `lib/utils.ts` (extracted from `ProductCard.tsx`) | Price formatting |
| `ApiException` | `lib/api/exceptions.ts` | Detect 404 vs generic errors |
| `createProduct`, `createProductImages` | `components/product/testing/fixtures.ts` | Test data |
| Catalog page pattern | `app/products/page.tsx` | loading/error/retry state pattern |

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing
- [x] Code follows project standards
- [x] No linting errors
- [x] Build succeeds

---

*Ticket created: 2026-02-17*
