# B4.5: Create order total calculation service

**Sprint:** 4
**Type:** Backend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint4-B4.5-order-total-calculation
**Created:** 2026-02-19
**Dependencies:** B4.3 (cart validation) ✅, B4.4 (promo code validation) ✅

---

## Description

Implement a pure calculation service that computes the full order financial breakdown from validated cart data and an optional promo code. This service orchestrates `validateCart` (B4.3) and `validatePromoCode` (B4.4) to produce the final totals that the checkout flow will display.

The service will also be exposed via `POST /cart/calculate` so the frontend can request real-time order totals during checkout (e.g., when the user applies a promo code or changes cart contents).

This is the last backend building block before integration tests (B4.6) and the frontend checkout flow (F4.5).

---

## Acceptance Criteria

- [x] `OrderTotalCalculationInput` accepts cart items and optional promo code
- [x] Service calls `validateCart` internally and returns cart validation errors if any items are invalid
- [x] Service calls `validatePromoCode` (with subtotal as `orderTotal`) when a promo code is provided
- [x] Returns structured `OrderTotalResult` with: `subtotal`, `discountAmount`, `shippingCost`, `taxAmount`, `total`, `currency`, `itemCount`, `validatedItems`, `appliedPromoCode`
- [x] `discountAmount` = `calculatedDiscount` from promo code result (or 0 if no promo / invalid promo)
- [x] `shippingCost` = flat rate (configurable constant, 0 for MVP)
- [x] `taxAmount` = 0 for MVP (tax calculation deferred)
- [x] `total` = `subtotal - discountAmount + shippingCost + taxAmount`, floored at 0
- [x] All monetary values rounded to 2 decimal places
- [x] `currency` = `"MXN"` (hardcoded for MVP)
- [x] Validator rejects malformed input → `InvalidOrderTotalDataError` → HTTP 400
- [x] Invalid promo code returns `valid: true` overall (cart is still valid) with `appliedPromoCode: null` and a promo error message
- [x] `POST /cart/calculate` endpoint exposed (public, no auth required)
- [x] Endpoint follows ADR-010 pattern (200 for business failures, 400 for malformed input)
- [x] API spec updated with `OrderTotalRequest`, `OrderTotalResponse`, and `/cart/calculate` endpoint
- [x] Unit tests for calculation service (all scenarios)
- [x] Unit tests for validator
- [x] Unit tests for controller
- [x] All tests pass
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `backend/src/application/services/orderTotalService.ts` | Order total calculation logic |
| `backend/src/application/services/__tests__/orderTotalService.test.ts` | Service unit tests |
| `backend/src/application/validators/orderTotalValidator.ts` | Input validation |
| `backend/src/application/validators/__tests__/orderTotalValidator.test.ts` | Validator tests |
| `backend/src/domain/errors/OrderTotalError.ts` | `InvalidOrderTotalDataError` |
| `backend/src/presentation/controllers/orderTotalController.ts` | HTTP handler |
| `backend/src/presentation/controllers/__tests__/orderTotalController.test.ts` | Controller tests |
| `backend/src/presentation/routes/orderTotalRoutes.ts` | Route definition |
| `ai-specs/specs/api-spec.yaml` | Add `/cart/calculate` endpoint + schemas |

---

## Technical Notes

### Calculation Logic
```
subtotal        = cartValidationResult.summary.subtotal (from validateCart)
discountAmount  = promoCodeResult.calculatedDiscount ?? 0 (from validatePromoCode with orderTotal=subtotal)
shippingCost    = ORDER_TOTAL_CONSTANTS.SHIPPING_COST (0 for MVP)
taxAmount       = ORDER_TOTAL_CONSTANTS.TAX_RATE * (subtotal - discountAmount) (0% for MVP)
total           = Math.max(0, subtotal - discountAmount + shippingCost + taxAmount)
```

### Dependencies Used
- `validateCart` from `cartService.ts` — provides validated items + subtotal
- `validatePromoCode` from `promoCodeService.ts` — provides discount calculation

### Patterns to Follow
- ADR-010: Return HTTP 200 with structured result for business failures
- Monetary rounding: `Math.round(value * 100) / 100`
- Prisma Decimal: `Number()` conversion (handled by cart/promo services already)
- Service returns structured result, never throws for business logic
- Only validator throws (`InvalidOrderTotalDataError`) for malformed input

### Constants (MVP defaults)
```typescript
const ORDER_TOTAL_CONSTANTS = {
  SHIPPING_COST: 0,      // flat shipping — free for MVP
  TAX_RATE: 0,           // 0% tax for MVP
  CURRENCY: 'MXN',
};
```

---

## Implementation Plan

### Overview

This feature adds an `orderTotalService` that orchestrates the existing `validateCart` (B4.3) and `validatePromoCode` (B4.4) services to produce a full financial breakdown. It follows the exact same pattern as `cartService` and `promoCodeService`: pure TypeScript validation (no Zod), structured result objects (never throws for business failures), ADR-010 HTTP 200 for business outcomes, and 400 only for malformed input.

The new route `POST /cart/calculate` is added to the existing `cartRoutes.ts` file (not a separate routes file) because the endpoint lives under the `/cart` prefix that is already registered in `routes/index.ts`.

---

### Phase 1: Domain Error (`OrderTotalError.ts`)

**Follow TDD: write the test first, then create the error class.**

#### 1a. Test first — `backend/src/domain/errors/OrderTotalError.test.ts`

Test scenarios (mirror `CartError.test.ts` exactly):

- `OrderTotalError` (base class)
  - creates error with `message`, `code`, `name = 'OrderTotalError'`, is instance of `Error`
- `InvalidOrderTotalDataError`
  - has `code = 'INVALID_ORDER_TOTAL_DATA'`
  - has `name = 'InvalidOrderTotalDataError'`
  - is instance of `OrderTotalError` and `Error`
  - accepts optional `field` parameter
  - `field` is `undefined` when not provided

#### 1b. Create `backend/src/domain/errors/OrderTotalError.ts`

Structure mirrors `CartError.ts` exactly:

```
OrderTotalError (base) extends Error
  constructor(message: string, public readonly code: string)
  this.name = 'OrderTotalError'

InvalidOrderTotalDataError extends OrderTotalError
  constructor(message: string, public readonly field?: string)
  calls super(message, 'INVALID_ORDER_TOTAL_DATA')
  this.name = 'InvalidOrderTotalDataError'
```

No other error classes needed — the service never throws for business failures (only the validator throws `InvalidOrderTotalDataError`).

---

### Phase 2: Validator (`orderTotalValidator.ts`)

**Follow TDD: write the test first.**

#### 2a. Test first — `backend/src/application/validators/orderTotalValidator.test.ts`

Mirrors `cartValidator.test.ts` structure. Test scenarios:

**valid inputs:**
- accepts `{ items: [...validItems] }` with no `promoCode` — returns validated input unchanged
- accepts `{ items: [...validItems], promoCode: 'SUMMER20' }` — trims and uppercases `promoCode`
- accepts `promoCode: 'summer20'` and returns it as `'SUMMER20'`
- accepts `promoCode` with whitespace `' SAVE10 '` and returns `'SAVE10'`
- `promoCode` absent — result has no `promoCode` field

**invalid items:**
- throws `InvalidOrderTotalDataError` when `items` is missing (field: `'items'`)
- throws `InvalidOrderTotalDataError` when `items` is not an array (field: `'items'`)
- throws `InvalidOrderTotalDataError` when `items` is empty (field: `'items'`)
- throws `InvalidOrderTotalDataError` when `items` exceeds 50 (field: `'items'`)
- throws `InvalidOrderTotalDataError` when `productId` is not a valid UUID (field: `'items[0].productId'`)
- throws `InvalidOrderTotalDataError` when `quantity` is missing (field: `'items[0].quantity'`)
- throws `InvalidOrderTotalDataError` when `quantity` is 0 (field: `'items[0].quantity'`)
- throws `InvalidOrderTotalDataError` when `quantity` exceeds 99 (field: `'items[0].quantity'`)
- throws `InvalidOrderTotalDataError` when `quantity` is not an integer (field: `'items[0].quantity'`)
- throws `InvalidOrderTotalDataError` when `size` is not a string (field: `'items[0].size'`)
- throws `InvalidOrderTotalDataError` when `size` is empty string (field: `'items[0].size'`)
- throws `InvalidOrderTotalDataError` when `size` exceeds 20 chars (field: `'items[0].size'`)

**invalid promoCode:**
- throws `InvalidOrderTotalDataError` when `promoCode` is not a string (field: `'promoCode'`)
- throws `InvalidOrderTotalDataError` when `promoCode` is empty string after trim (field: `'promoCode'`)
- throws `InvalidOrderTotalDataError` when `promoCode` exceeds 50 chars (field: `'promoCode'`)

#### 2b. Create `backend/src/application/validators/orderTotalValidator.ts`

Interfaces:

```typescript
// Reuses CartItemInput structure from cartValidator types but declares its own
// to remain self-contained (no cross-validator imports for types)
export interface OrderTotalItemInput {
  productId: string;
  quantity: number;
  size?: string;
}

export interface OrderTotalCalculationInput {
  items: OrderTotalItemInput[];
  promoCode?: unknown;  // unknown so validator can type-check it
}

export interface ValidatedOrderTotalItem {
  productId: string;
  quantity: number;
  size?: string;
}

export interface ValidatedOrderTotalInput {
  items: ValidatedOrderTotalItem[];
  promoCode?: string;
}
```

Constants (copy from `cartValidator.ts` — these are the same business rules):

```typescript
const MAX_CART_ITEMS = 50;
const MAX_QUANTITY_PER_ITEM = 99;
const MAX_SIZE_LENGTH = 20;
const MAX_PROMO_CODE_LENGTH = 50;
```

Private helpers (same pattern as `cartValidator.ts`):

- `throwOrderTotalError(message, field)` — throws `InvalidOrderTotalDataError`
- `validateUUID(id, fieldName)` — delegates to `sharedValidateUUID` from `./shared`
- `validateQuantity(value, fieldName)` — same checks as `cartValidator.ts`
- `validateOptionalSize(value, fieldName)` — same checks as `cartValidator.ts`
- `validateOptionalPromoCode(value)` — validates optional promo code string:
  - if `undefined`/`null`, return `undefined`
  - if not a string, throw with field `'promoCode'`
  - trim; if empty, throw with field `'promoCode'`
  - if exceeds 50 chars, throw with field `'promoCode'`
  - return `trimmed.toUpperCase()`

Exported function `validateOrderTotalInput(input: OrderTotalCalculationInput): ValidatedOrderTotalInput`:
- validates `items` array (non-empty, max 50)
- maps each item through UUID/quantity/size validators
- validates optional `promoCode`
- returns `{ items: validatedItems, promoCode? }` (omit `promoCode` key when absent)

**Important:** The item validation logic is intentionally duplicated from `cartValidator.ts` rather than sharing code. This keeps each validator self-contained and avoids coupling. The shared `validateUUID` from `./shared` is still used.

---

### Phase 3: Service (`orderTotalService.ts`)

**Follow TDD: write the test first.**

#### 3a. Test first — `backend/src/application/services/__tests__/orderTotalService.test.ts`

**Mock setup** — mock both dependency services (not Prisma directly, since the service delegates to them):

```typescript
jest.mock('../cartService');
jest.mock('../promoCodeService');
```

Use `jest.Mocked<typeof cartService>` and `jest.Mocked<typeof promoCodeService>`.

**Helper factories** — define a `makeCartResult(overrides?)` that returns a `CartValidationResult` with `valid: true`, one valid item (price 100.00, quantity 1, subtotal 100.00), summary `{ subtotal: 100, itemCount: 1 }`, errors `[]`.

Test scenarios:

**no promo code:**
- returns `valid: true` with correct `subtotal`, `discountAmount: 0`, `shippingCost: 0`, `taxAmount: 0`, `total: 100`, `currency: 'MXN'`, `itemCount: 1`, `validatedItems` (the cart items array), `appliedPromoCode: null`
- calls `validateCart` with the input items (passes the items through)
- does NOT call `validatePromoCode` when no promo code in input

**with valid promo code (PERCENTAGE, calculatedDiscount: 20):**
- calls `validatePromoCode` with `{ code: 'SUMMER20', orderTotal: 100 }` (subtotal as orderTotal)
- returns `discountAmount: 20`
- returns `total: 80` (100 - 20 + 0 + 0)
- returns `appliedPromoCode: { code: 'SUMMER20', discountType: 'PERCENTAGE', discountValue: 20, calculatedDiscount: 20 }`

**with invalid promo code (valid: false from promoCodeService):**
- returns `valid: true` overall (cart is still valid)
- returns `discountAmount: 0`
- returns `total: 100`
- returns `appliedPromoCode: null`
- returns `promoCodeMessage: 'Promo code has expired'` (the message from promoCodeService result)

**with promo code where calculatedDiscount is null (PERCENTAGE, no orderTotal scenario — edge case):**
- returns `discountAmount: 0` when `calculatedDiscount` is null

**cart is invalid (validateCart returns valid: false):**
- returns `valid: false`
- returns same `errors` from `validateCart`
- still returns correct `subtotal`, `total` based on valid items only
- still processes promo code if provided (since subtotal from valid items is what matters)

**total floor at 0:**
- if discount would exceed subtotal (edge case — should not happen since promoCodeService caps it, but guard exists), `total` is `Math.max(0, ...)` = 0

**monetary rounding:**
- `discountAmount` is rounded to 2 decimal places
- `total` is rounded to 2 decimal places
- test with 0.1 + 0.2 subtotal edge case

**input validation throws:**
- throws `InvalidOrderTotalDataError` for empty `items` (propagated from validator)
- throws `InvalidOrderTotalDataError` for invalid `productId`
- throws `InvalidOrderTotalDataError` for invalid `promoCode` type (e.g., number)

**FIXED_AMOUNT promo code:**
- returns `discountAmount` equal to the fixed amount (e.g., 10)
- returns correct `total`

#### 3b. Create `backend/src/application/services/orderTotalService.ts`

Imports:
- `{ validateOrderTotalInput, type OrderTotalCalculationInput }` from `../validators/orderTotalValidator`
- `{ validateCart, type CartValidationResult }` from `./cartService`
- `{ validatePromoCode, type PromoCodeValidationResult }` from `./promoCodeService`
- `type { DiscountType }` from `../../generated/prisma/enums`

Constants:

```typescript
const ORDER_TOTAL_CONSTANTS = {
  SHIPPING_COST: 0,
  TAX_RATE: 0,
  CURRENCY: 'MXN',
} as const;
```

Exported interfaces:

```typescript
export interface AppliedPromoCodeInfo {
  code: string;
  discountType: DiscountType;
  discountValue: number;
  calculatedDiscount: number;
}

export interface OrderTotalResult {
  valid: boolean;
  subtotal: number;
  discountAmount: number;
  shippingCost: number;
  taxAmount: number;
  total: number;
  currency: string;
  itemCount: number;
  validatedItems: CartValidationResult['items'];
  appliedPromoCode: AppliedPromoCodeInfo | null;
  promoCodeMessage?: string;
  cartErrors: CartValidationResult['errors'];
}
```

Exported function `calculateOrderTotal(input: OrderTotalCalculationInput): Promise<OrderTotalResult>`:

1. Call `validateOrderTotalInput(input)` — throws `InvalidOrderTotalDataError` on malformed input
2. Call `validateCart({ items: validated.items })` — returns `CartValidationResult`
3. Extract `subtotal = cartResult.summary.subtotal`
4. If `validated.promoCode` is defined:
   - Call `validatePromoCode({ code: validated.promoCode, orderTotal: subtotal })`
   - If `promoCodeResult.valid === true` and `promoCodeResult.calculatedDiscount != null`:
     - `discountAmount = Math.round(promoCodeResult.calculatedDiscount * 100) / 100`
     - `appliedPromoCode = { code, discountType, discountValue, calculatedDiscount: discountAmount }`
   - Else:
     - `discountAmount = 0`
     - `appliedPromoCode = null`
     - `promoCodeMessage = promoCodeResult.message`
5. Else: `discountAmount = 0`, `appliedPromoCode = null`
6. `shippingCost = ORDER_TOTAL_CONSTANTS.SHIPPING_COST`
7. `taxAmount = Math.round(ORDER_TOTAL_CONSTANTS.TAX_RATE * (subtotal - discountAmount) * 100) / 100`
8. `rawTotal = subtotal - discountAmount + shippingCost + taxAmount`
9. `total = Math.round(Math.max(0, rawTotal) * 100) / 100`
10. Return `OrderTotalResult`:
    - `valid: cartResult.valid`
    - `subtotal`
    - `discountAmount`
    - `shippingCost`
    - `taxAmount`
    - `total`
    - `currency: ORDER_TOTAL_CONSTANTS.CURRENCY`
    - `itemCount: cartResult.summary.itemCount`
    - `validatedItems: cartResult.items`
    - `appliedPromoCode`
    - `promoCodeMessage` (only if set)
    - `cartErrors: cartResult.errors`

**Important:** The function never throws for business failures. Only the validator throws.

---

### Phase 4: Controller (`orderTotalController.ts`)

**Follow TDD: write the test first.**

#### 4a. Test first — `backend/src/presentation/controllers/__tests__/orderTotalController.test.ts`

**Note:** Create this file in `backend/src/presentation/controllers/__tests__/` (the `__tests__` subdirectory that already exists based on the file list above, though there are no files in it currently — other controller tests are at the parent level). Looking at existing controller tests, they are placed at `backend/src/presentation/controllers/cartController.test.ts`. Follow the same colocation — place at `backend/src/presentation/controllers/orderTotalController.test.ts`.

Mock setup:
```typescript
jest.mock('../../application/services/orderTotalService');
```

Helper — define `mockValidResult: OrderTotalResult` with `valid: true`, all monetary fields, `appliedPromoCode: null`, `cartErrors: []`.

Test scenarios:

**successful calculation — 200:**
- `calculateOrderTotal` — calls `orderTotalService.calculateOrderTotal` with `req.body`
- returns HTTP 200 with `{ success: true, data: result }`
- works even when `valid: false` in result (cart has errors but still HTTP 200 — ADR-010)

**invalid promo code (still 200):**
- result has `valid: true`, `appliedPromoCode: null`, `promoCodeMessage: 'Promo code not found'`
- returns HTTP 200 with `{ success: true, data: result }`

**malformed input — 400:**
- when service throws `InvalidOrderTotalDataError`:
  - returns HTTP 400
  - body: `{ success: false, error: { message, code: 'INVALID_ORDER_TOTAL_DATA', field } }`
  - does NOT call `next()`
- when `field` is `undefined` — `error.field` is `undefined`

**unexpected errors — calls next:**
- when service throws a generic `Error` — calls `next(error)`, does not set status

#### 4b. Create `backend/src/presentation/controllers/orderTotalController.ts`

Structure mirrors `cartController.ts` exactly:

```typescript
import { Request, Response, NextFunction } from 'express';
import * as orderTotalService from '../../application/services/orderTotalService';
import { InvalidOrderTotalDataError } from '../../domain/errors/OrderTotalError';
import { success } from '../../utils/responseHelpers';

export async function calculateOrderTotal(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> {
  try {
    const result = await orderTotalService.calculateOrderTotal(req.body);
    success(res, result);
  } catch (error) {
    handleOrderTotalError(error, res, next);
  }
}

function handleOrderTotalError(error: unknown, res: Response, next: NextFunction): void {
  if (error instanceof InvalidOrderTotalDataError) {
    res.status(400).json({
      success: false,
      error: {
        message: error.message,
        code: error.code,
        field: error.field,
      },
    });
    return;
  }
  next(error);
}
```

---

### Phase 5: Route Registration

**No new route file is needed.** The `POST /cart/calculate` endpoint belongs under the `/cart` prefix, which is already handled by `backend/src/routes/cartRoutes.ts`. Add the new handler to the existing file.

#### 5a. Modify `backend/src/routes/cartRoutes.ts`

Add the import and route:

```typescript
import { Router } from 'express';
import { validateCart } from '../presentation/controllers/cartController';
import { calculateOrderTotal } from '../presentation/controllers/orderTotalController';

const router = Router();

// Public endpoints — no authMiddleware required
router.post('/validate', validateCart);
router.post('/calculate', calculateOrderTotal);

export default router;
```

**No changes to `backend/src/routes/index.ts`** — the `/cart` prefix is already registered.

---

### Phase 6: Integration Test

#### Create `backend/src/routes/orderTotalRoutes.integration.test.ts`

**Note:** Name this file `orderTotalRoutes.integration.test.ts` to match the naming convention of other integration test files. It tests the `POST /cart/calculate` endpoint end-to-end via supertest but mocks at the Prisma level (same pattern as `cartRoutes.integration.test.ts`).

Mock setup — mock both Prisma models used by the two underlying services:

```typescript
jest.mock('../lib/prisma', () => ({
  __esModule: true,
  default: {
    product: { findMany: jest.fn() },
    promoCode: { findUnique: jest.fn() },
  },
}));

jest.mock('../application/services/tokenService', () => ({
  generateAccessToken: jest.fn(),
  generateRefreshToken: jest.fn(),
  verifyAccessToken: jest.fn(),
  refreshTokens: jest.fn(),
}));
```

Use the same `createTestApp` pattern as other integration tests (requires `./index`).

Define `mockProduct` and `makePromoCode` helpers (same shape as in `cartRoutes.integration.test.ts` and `promoCodeRoutes.integration.test.ts`).

Test scenarios:

**success — no promo code:**
- POST `/cart/calculate` with valid items, no `promoCode`
- mock `product.findMany` returns one active product (price: 100)
- response: HTTP 200, `success: true`
- `data.valid: true`, `data.subtotal: 100`, `data.discountAmount: 0`, `data.shippingCost: 0`, `data.taxAmount: 0`, `data.total: 100`, `data.currency: 'MXN'`, `data.itemCount: 1`, `data.appliedPromoCode: null`, `data.validatedItems` has one item, `data.cartErrors` is empty array

**success — with valid PERCENTAGE promo code:**
- mock product findMany + promoCode findUnique (PERCENTAGE, 20%, no caps)
- `data.discountAmount: 20`, `data.total: 80`, `data.appliedPromoCode.code: 'SUMMER20'`

**success — with invalid promo code (not found):**
- mock product findMany (valid product), promoCode findUnique returns null
- response: HTTP 200, `data.valid: true`, `data.appliedPromoCode: null`, `data.discountAmount: 0`, `data.promoCodeMessage: 'Promo code not found'`

**success — cart has invalid items (still 200):**
- mock product findMany returns empty (product not found)
- response: HTTP 200, `data.valid: false`, `data.cartErrors[0].code: 'PRODUCT_NOT_FOUND'`, `data.subtotal: 0`, `data.total: 0`

**public endpoint:**
- accessible without Authorization header — HTTP 200

**input validation — 400:**
- missing `items` — HTTP 400, `error.code: 'INVALID_ORDER_TOTAL_DATA'`, `error.field: 'items'`
- empty `items` array — HTTP 400
- invalid `productId` (not UUID) — HTTP 400
- `promoCode` is a number — HTTP 400, `error.field: 'promoCode'`
- `promoCode` is empty string — HTTP 400, `error.field: 'promoCode'`

**response shape:**
- response always includes all fields: `valid`, `subtotal`, `discountAmount`, `shippingCost`, `taxAmount`, `total`, `currency`, `itemCount`, `validatedItems`, `appliedPromoCode`, `cartErrors`

---

### Phase 7: API Spec Update

Modify `ai-specs/specs/api-spec.yaml`.

#### 7a. Add endpoint `/cart/calculate` (after `/cart/validate` at line ~1386)

Insert before the `# ORDER ENDPOINTS` comment block:

```yaml
  /cart/calculate:
    post:
      tags: [Cart]
      summary: Calculate order total
      operationId: calculateOrderTotal
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/OrderTotalRequest'
      responses:
        '200':
          description: Order total calculation result (appliedPromoCode=null if promo code invalid)
          content:
            application/json:
              schema:
                type: object
                properties:
                  success:
                    type: boolean
                  data:
                    $ref: '#/components/schemas/OrderTotalResponse'
        '400':
          $ref: '#/components/responses/ValidationError'
```

#### 7b. Add schemas (after `CartValidationError` schema, before `# ORDER SCHEMAS` comment at line ~3545)

Insert these two new schemas:

```yaml
    OrderTotalRequest:
      type: object
      required: [items]
      properties:
        items:
          type: array
          minItems: 1
          maxItems: 50
          items:
            type: object
            required: [productId, quantity]
            properties:
              productId:
                type: string
                format: uuid
              quantity:
                type: integer
                minimum: 1
                maximum: 99
              size:
                type: string
                maxLength: 20
        promoCode:
          type: string
          maxLength: 50
          description: Optional promo code to apply

    OrderTotalResponse:
      type: object
      required: [valid, subtotal, discountAmount, shippingCost, taxAmount, total, currency, itemCount, validatedItems, appliedPromoCode, cartErrors]
      properties:
        valid:
          type: boolean
          description: false if any cart items are invalid
        subtotal:
          type: number
          format: float
          description: Sum of valid item subtotals
        discountAmount:
          type: number
          format: float
          description: Discount from applied promo code (0 if none)
        shippingCost:
          type: number
          format: float
          description: Flat shipping cost (0 for MVP)
        taxAmount:
          type: number
          format: float
          description: Tax amount (0 for MVP)
        total:
          type: number
          format: float
          description: subtotal - discountAmount + shippingCost + taxAmount, floored at 0
        currency:
          type: string
          example: MXN
        itemCount:
          type: integer
        validatedItems:
          type: array
          items:
            $ref: '#/components/schemas/CartValidatedItem'
        appliedPromoCode:
          nullable: true
          oneOf:
            - type: 'null'
            - $ref: '#/components/schemas/AppliedPromoCodeDetail'
        promoCodeMessage:
          type: string
          description: Error message when promo code is invalid (only present if promoCode was provided but invalid)
        cartErrors:
          type: array
          items:
            $ref: '#/components/schemas/CartValidationError'

    AppliedPromoCodeDetail:
      type: object
      required: [code, discountType, discountValue, calculatedDiscount]
      properties:
        code:
          type: string
        discountType:
          type: string
          enum: [PERCENTAGE, FIXED_AMOUNT]
        discountValue:
          type: number
        calculatedDiscount:
          type: number
          format: float
```

After updating the spec, run `cd frontend && npm run generate:api` to regenerate frontend types.

---

### Phase 8: Update `key_facts.md`

After all phases are complete, update `docs/project_notes/key_facts.md`:

**In "Domain Errors" section:**
- Add: `OrderTotalError` - `InvalidOrderTotalDataError`

**In "Services" section:**
- Add: `orderTotalService` - `calculateOrderTotal(input)` — orchestrates `validateCart` + `validatePromoCode`. Returns `OrderTotalResult` with full financial breakdown. Never throws for business failures.

**In "Validators" section:**
- Add: `orderTotalValidator` - `validateOrderTotalInput` — validates items array (same rules as cartValidator) + optional `promoCode` string (max 50 chars, uppercased)

**In "Controllers" section:**
- Add: `orderTotalController` - Order total calculation handler, maps `InvalidOrderTotalDataError` → 400

**In "Routes" section:**
- Update: `/cart` — Add `POST /calculate` (public — no auth) alongside existing `POST /validate`

**Update total test count:** 1245 + (estimated ~40 new tests from this feature)

---

### Implementation Order Summary

| Step | Action | Files |
|------|--------|-------|
| 1 | Write error test | `domain/errors/OrderTotalError.test.ts` |
| 2 | Implement error class | `domain/errors/OrderTotalError.ts` |
| 3 | Write validator test | `application/validators/orderTotalValidator.test.ts` |
| 4 | Implement validator | `application/validators/orderTotalValidator.ts` |
| 5 | Write service test | `application/services/__tests__/orderTotalService.test.ts` |
| 6 | Implement service | `application/services/orderTotalService.ts` |
| 7 | Write controller test | `presentation/controllers/orderTotalController.test.ts` |
| 8 | Implement controller | `presentation/controllers/orderTotalController.ts` |
| 9 | Modify routes file | `routes/cartRoutes.ts` (add POST /calculate) |
| 10 | Write integration test | `routes/orderTotalRoutes.integration.test.ts` |
| 11 | Update API spec | `ai-specs/specs/api-spec.yaml` |
| 12 | Regenerate frontend types | `cd frontend && npm run generate:api` |
| 13 | Update key_facts.md | `docs/project_notes/key_facts.md` |

---

### Key Notes for Implementer

1. **Service mocking in service test** — mock `cartService` and `promoCodeService` directly (not Prisma), because `orderTotalService` calls those services, not Prisma directly. In the integration test, mock Prisma (both `product.findMany` and `promoCode.findUnique`).

2. **`promoCodeMessage` is optional** — only include it in `OrderTotalResult` when `promoCode` was provided but invalid. Do not include the key at all when no promo code was given.

3. **Cart errors vs promo errors** — `valid` in `OrderTotalResult` reflects only the cart validity (from `cartResult.valid`), not the promo code validity. An invalid promo code still results in `valid: true` (if cart is fine). This matches the acceptance criterion: "Invalid promo code returns `valid: true` overall."

4. **`validatePromoCode` is called even when cart is invalid** — the spec says the promo code is applied to the subtotal of valid items. However, if the cart is entirely invalid (subtotal = 0), the promo code call is technically a no-op. The service should still call `validatePromoCode` whenever `promoCode` is present, regardless of cart validity. This is simpler and consistent.

5. **Validator item validation uses `InvalidOrderTotalDataError`**, not `InvalidCartDataError` — even though the item validation rules are identical to `cartValidator`. Each validator throws its own domain error.

6. **`validateUUID` from `./shared`** — import and use the shared UUID validator helper. Pass the local `throwOrderTotalError` as the error factory. This is the same pattern as `cartValidator.ts`.

7. **No new `routes/index.ts` changes** — `/cart` is already mounted. Only `cartRoutes.ts` needs editing.

8. **Controller test file location** — place `orderTotalController.test.ts` directly in `backend/src/presentation/controllers/` (not in `__tests__/` subdirectory), matching the pattern of all other controller tests (`cartController.test.ts`, `promoCodeController.test.ts`, etc.).

9. **Monetary rounding** — use `Math.round(value * 100) / 100` consistently. Apply rounding after every arithmetic operation (subtotal already rounded by cartService; apply again to discountAmount, taxAmount, total for safety).

10. **`ORDER_TOTAL_CONSTANTS` is file-private** — do not export it. It is an implementation detail of the service. The frontend reads the computed values from the response, not the constants.

---

## Definition of Done

- [x] All acceptance criteria met
- [x] Unit tests written and passing
- [x] Code follows project standards (DDD layers, error handling)
- [x] No linting errors
- [x] Build succeeds
- [x] API spec updated
- [x] Production-code-validator passed

---

*Ticket created: 2026-02-19*
