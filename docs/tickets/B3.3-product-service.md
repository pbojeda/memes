# B3.3: Implement product service (CRUD)

**Sprint:** 3
**Type:** Backend - Feature
**Priority:** High
**Status:** In Progress
**Branch:** feature/sprint3-B3.3-product-service
**Created:** 2026-02-11
**Dependencies:** B3.1 (Product, ProductImage, ProductReview models) — Completed

---

## Description

Implement the product service layer with full CRUD operations for the Product entity. The service must support soft delete (via `deletedAt`), localized JSON fields (title, description with `{es, en}` format), price tracking (creates PriceHistory entry on price changes), and slug uniqueness enforcement.

This is the core service that downstream tasks (B3.4 listing/filters, B3.5 detail endpoint, B3.6 soft delete, B3.9 admin endpoints) depend on.

---

## Acceptance Criteria

- [x] Product validator with input validation (create, update, ID)
  - Validates localized fields (`title`, `description`) require `es` key
  - Validates `slug` format (lowercase, alphanumeric + hyphens)
  - Validates `price` is positive decimal
  - Validates `compareAtPrice` is greater than `price` when provided
  - Validates `availableSizes` is a valid JSON array of strings
  - Validates `productTypeId` exists (UUID format)
  - Validates `color` is non-empty string
- [x] `createProduct` — creates product with validated input, handles slug uniqueness (P2002)
- [x] `getProductById` — finds product by ID, excludes soft-deleted unless `includeSoftDeleted` flag
- [x] `getProductBySlug` — finds product by slug, excludes soft-deleted
- [x] `updateProduct` — partial update, handles slug uniqueness, creates PriceHistory entry when price changes
- [x] `softDeleteProduct` — sets `deletedAt` timestamp (does not hard-delete)
- [x] `restoreProduct` — clears `deletedAt` timestamp
- [x] All service functions throw appropriate domain errors (ProductNotFoundError, InvalidProductDataError, ProductSlugAlreadyExistsError)
- [x] Unit tests for all service functions with >90% coverage
- [x] All existing tests pass
- [x] Build succeeds

---

## Files to Create/Modify

| File | Purpose |
|------|---------|
| `backend/src/application/validators/productValidator.ts` | Input validation for product CRUD |
| `backend/src/application/validators/productValidator.test.ts` | Tests for product validator |
| `backend/src/application/services/productService.ts` | Product CRUD service functions |
| `backend/src/application/services/productService.test.ts` | Tests for product service |

---

## Technical Notes

### Patterns to Follow
- Follow `productTypeService.ts` patterns: async functions, validate first, handle Prisma P2002, throw domain errors
- Follow `productTypeValidator.ts` patterns: Input/Validated types, private helpers, field-specific error messages
- Use existing domain errors from `src/domain/errors/ProductError.ts` (ProductNotFoundError, InvalidProductDataError, ProductSlugAlreadyExistsError)

### Soft Delete
- All "read" operations must exclude soft-deleted products (`deletedAt === null`) unless explicitly requested
- `softDeleteProduct` sets `deletedAt = new Date()`
- `restoreProduct` sets `deletedAt = null`
- No hard-delete operation in this task

### Localized Fields
- `title` and `description` are JSON with format `{ es: "...", en: "..." }`
- `es` key is required (MVP targets Spanish market — ADR-003)
- `en` key is optional
- Validate both as non-empty strings when provided, with max length constraints

### Price History
- When `updateProduct` changes `price`, create a `PriceHistory` entry:
  - `productId`: the product being updated
  - `price`: the **new** price
  - `changedByUserId`: passed as parameter (optional)
  - `reason`: passed as parameter (optional)
- Use Prisma transaction to ensure atomicity of product update + price history creation

### Prisma Import
- `import prisma from '../../lib/prisma'`
- `import { Prisma } from '../../generated/prisma/client'`
- `import type { Product } from '../../generated/prisma/client'`

---

## Implementation Plan

### Existing Code to Reuse

**Domain Errors:**
- `/Users/pb/Developer/FiveGuays/memes/backend/src/domain/errors/ProductError.ts` - Already exists with all needed error classes:
  - `ProductNotFoundError` - Thrown when product is not found
  - `ProductSlugAlreadyExistsError` - Thrown when slug already exists (Prisma P2002)
  - `InvalidProductDataError` - Thrown when validation fails (includes optional `field` parameter)

**Prisma Client:**
- `/Users/pb/Developer/FiveGuays/memes/backend/lib/prisma.ts` - Default Prisma client instance
- Import pattern: `import prisma from '../../lib/prisma'`
- Import Prisma types: `import { Prisma } from '../../generated/prisma/client'`
- Import Product type: `import type { Product } from '../../generated/prisma/client'`

**Validator Utilities (Reference Patterns):**
- `/Users/pb/Developer/FiveGuays/memes/backend/src/application/validators/productTypeValidator.ts` - Reuse validation patterns:
  - `LocalizedName` interface pattern for localized JSON fields
  - `validateName()` function pattern (checks `es` required, validates string lengths)
  - `validateSlug()` function pattern (regex, lowercase, max length)
  - `validateUUID()` function pattern for ID validation
  - UUID_REGEX constant: `/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i`
  - SLUG_REGEX constant: `/^[a-z0-9]+(?:-[a-z0-9]+)*$/`

**Service Patterns (Reference):**
- `/Users/pb/Developer/FiveGuays/memes/backend/src/application/services/productTypeService.ts` - Follow these patterns:
  - Validate input first using validator functions
  - Use try-catch to handle Prisma P2002 errors (unique constraint violations)
  - Throw domain-specific errors (not generic errors)
  - Check existence before update/delete operations
  - Use Prisma client for all database operations

---

### Files to Create

1. **`/Users/pb/Developer/FiveGuays/memes/backend/src/application/validators/productValidator.ts`**
   - Purpose: Input validation for product CRUD operations
   - Exports: Interfaces for Input/Validated types, validation functions
   - Reuses: LocalizedName pattern from productTypeValidator

2. **`/Users/pb/Developer/FiveGuays/memes/backend/src/application/validators/productValidator.test.ts`**
   - Purpose: Unit tests for product validator
   - Coverage: All validation functions with happy path, edge cases, and error scenarios
   - Pattern: Follow productTypeValidator.test.ts structure (AAA pattern, describe blocks)

3. **`/Users/pb/Developer/FiveGuays/memes/backend/src/application/services/productService.ts`**
   - Purpose: Product CRUD service functions
   - Exports: createProduct, getProductById, getProductBySlug, updateProduct, softDeleteProduct, restoreProduct
   - Integrates: Prisma transactions for price history tracking

4. **`/Users/pb/Developer/FiveGuays/memes/backend/src/application/services/productService.test.ts`**
   - Purpose: Unit tests for product service
   - Coverage: All service functions with happy path, error handling, and edge cases
   - Pattern: Follow productTypeService.test.ts structure (mock Prisma, AAA pattern)

---

### Files to Modify

**None** - All implementation is in new files. Existing domain errors are already complete.

---

### Implementation Order

#### Phase 1: Domain Layer (Already Complete)
- ✅ Domain errors already exist in `/backend/src/domain/errors/ProductError.ts`
- No changes needed

#### Phase 2: Application Layer - Validators

1. **Create `productValidator.ts`**
   - Define interfaces:
     - `LocalizedText` interface (same as LocalizedName but for product title/description)
     - `CreateProductInput` interface (all required fields from Prisma model)
     - `ValidatedCreateProductInput` interface (with defaults applied)
     - `UpdateProductInput` interface (all optional partial fields)
     - `ValidatedUpdateProductInput` interface
   - Define constants:
     - `UUID_REGEX` (reuse pattern from productTypeValidator)
     - `SLUG_REGEX` (reuse pattern from productTypeValidator)
     - `MAX_SLUG_LENGTH = 100`
     - `MAX_TITLE_LENGTH = 200`
     - `MAX_DESCRIPTION_LENGTH = 1000`
     - `MAX_COLOR_LENGTH = 50`
     - `MAX_URL_LENGTH = 500`
   - Implement private helper functions:
     - `validateLocalizedText(text: unknown, fieldName: string, maxLength: number): LocalizedText` - Check es required, validate string lengths
     - `validateSlug(slug: unknown, fieldName: string, required: boolean): string` - Lowercase, alphanumeric + hyphens
     - `validatePrice(price: unknown, fieldName: string): number` - Positive number (will be stored as Decimal in Prisma)
     - `validateCompareAtPrice(price: unknown, compareAtPrice: unknown, fieldName: string): number | undefined` - Greater than price if provided
     - `validateAvailableSizes(sizes: unknown, fieldName: string): string[] | undefined` - Array of non-empty strings
     - `validateUUID(id: unknown, fieldName: string): string` - UUID format
     - `validateBoolean(value: unknown, fieldName: string): boolean` - Type check
     - `validateString(value: unknown, fieldName: string, maxLength: number, required: boolean): string` - Non-empty, max length
   - Implement public validation functions:
     - `validateCreateProductInput(input: CreateProductInput): ValidatedCreateProductInput`
     - `validateUpdateProductInput(input: UpdateProductInput): ValidatedUpdateProductInput`
     - `validateProductId(id: string): string`

2. **Create `productValidator.test.ts`**
   - Test structure (following productTypeValidator.test.ts pattern):
     - `describe('validateCreateProductInput')`
       - `describe('valid inputs')` - Test happy paths with all combinations
       - `describe('title validation')` - Missing, invalid type, missing es, empty strings, max length
       - `describe('description validation')` - Same as title
       - `describe('slug validation')` - Missing, uppercase, special chars, max length
       - `describe('price validation')` - Missing, negative, zero, non-number
       - `describe('compareAtPrice validation')` - Less than price, equal to price, valid when greater
       - `describe('availableSizes validation')` - Invalid array, empty strings, non-array
       - `describe('productTypeId validation')` - Missing, invalid UUID format
       - `describe('color validation')` - Empty string, max length
     - `describe('validateUpdateProductInput')`
       - `describe('valid inputs')` - Partial updates
       - `describe('field validation')` - Same validations as create but optional
     - `describe('validateProductId')`
       - Valid UUID
       - Invalid UUID format

#### Phase 3: Application Layer - Services

3. **Create `productService.ts`**
   - Implement `createProduct(input: CreateProductInput): Promise<Product>`
     - Validate input using `validateCreateProductInput`
     - Create product via `prisma.product.create()`
     - Catch Prisma P2002 error and throw `ProductSlugAlreadyExistsError`
     - Return created product
   - Implement `getProductById(id: string, includeSoftDeleted: boolean = false): Promise<Product>`
     - Validate ID using `validateProductId`
     - Query with `prisma.product.findUnique({ where: { id, ...(includeSoftDeleted ? {} : { deletedAt: null }) } })`
     - Throw `ProductNotFoundError` if null
     - Return product
   - Implement `getProductBySlug(slug: string): Promise<Product>`
     - Validate slug format
     - Query with `prisma.product.findUnique({ where: { slug, deletedAt: null } })`
     - Throw `ProductNotFoundError` if null
     - Return product
   - Implement `updateProduct(id: string, input: UpdateProductInput, changedByUserId?: string, reason?: string): Promise<Product>`
     - Validate ID and input
     - Check product exists (non-soft-deleted)
     - **If price changed**: Use Prisma `$transaction` to:
       - Update product
       - Create PriceHistory entry with new price, changedByUserId, reason
     - **If price not changed**: Simple update
     - Catch P2002 error and throw `ProductSlugAlreadyExistsError`
     - Return updated product
   - Implement `softDeleteProduct(id: string): Promise<void>`
     - Validate ID
     - Check product exists and not already deleted
     - Update `deletedAt = new Date()`
   - Implement `restoreProduct(id: string): Promise<Product>`
     - Validate ID
     - Check product exists and is soft-deleted
     - Update `deletedAt = null`
     - Return restored product

4. **Create `productService.test.ts`**
   - Mock setup (following productTypeService.test.ts pattern):
     - `jest.mock('../../lib/prisma')` with mocked Prisma methods
     - Mock both `prisma.product` and `prisma.priceHistory` methods
     - Mock `prisma.$transaction` to execute callback immediately
   - Test structure:
     - `describe('createProduct')`
       - Should create product with valid input
       - Should apply default values (isActive=true, isHot=false, salesCount=0, viewCount=0)
       - Should throw ProductSlugAlreadyExistsError on P2002
       - Should re-throw non-P2002 Prisma errors
       - Should throw InvalidProductDataError on validation failure
     - `describe('getProductById')`
       - Should return product when found (non-deleted)
       - Should exclude soft-deleted by default
       - Should include soft-deleted when flag is true
       - Should throw ProductNotFoundError when not found
       - Should throw InvalidProductDataError on invalid ID
     - `describe('getProductBySlug')`
       - Should return product when found
       - Should exclude soft-deleted products
       - Should throw ProductNotFoundError when not found
     - `describe('updateProduct')`
       - Should update product with valid partial input
       - Should update without creating PriceHistory when price unchanged
       - Should create PriceHistory entry when price changes (test transaction)
       - Should pass changedByUserId and reason to PriceHistory
       - Should throw ProductNotFoundError when product doesn't exist
       - Should throw ProductSlugAlreadyExistsError on P2002
       - Should not update soft-deleted products
     - `describe('softDeleteProduct')`
       - Should set deletedAt timestamp
       - Should throw ProductNotFoundError when product doesn't exist
       - Should throw error if already soft-deleted
     - `describe('restoreProduct')`
       - Should clear deletedAt timestamp
       - Should throw ProductNotFoundError when product doesn't exist
       - Should throw error if product is not deleted

---

### Testing Strategy

#### Test Files to Create

1. **`productValidator.test.ts`** (Unit tests)
   - Focus: Pure validation logic, no database interaction
   - Mocking: None (validator is pure functions)
   - Coverage targets:
     - All validation functions (create, update, ID)
     - All validation rules (type, format, length, required fields)
     - All error paths (missing, invalid format, constraint violations)
     - All edge cases (empty strings, boundary values, null/undefined)

2. **`productService.test.ts`** (Unit tests)
   - Focus: Service orchestration logic, error handling
   - Mocking:
     - Mock `prisma.product.*` methods (create, findUnique, update)
     - Mock `prisma.priceHistory.create` for price tracking
     - Mock `prisma.$transaction` to execute callback immediately (tests transaction logic without real DB)
   - Coverage targets:
     - All CRUD operations (create, read, update, soft delete, restore)
     - Error handling (P2002, not found, validation errors)
     - Business logic (soft delete filtering, price history on price change)
     - Transaction behavior (atomic product update + price history creation)

#### Key Test Scenarios

**Happy Path:**
- Create product with all required fields → Returns created product
- Get product by ID (non-deleted) → Returns product
- Get product by slug → Returns product
- Update product without price change → Returns updated product
- Update product with price change → Creates PriceHistory entry in transaction
- Soft delete product → Sets deletedAt
- Restore soft-deleted product → Clears deletedAt

**Edge Cases:**
- Create with minimum required fields (defaults applied)
- Get by ID with `includeSoftDeleted=true` → Returns soft-deleted product
- Update product with partial data (only changed fields)
- Update product price with changedByUserId and reason → Stored in PriceHistory
- Soft delete already deleted product → Throws error
- Restore non-deleted product → Throws error

**Error Cases:**
- Create with duplicate slug → ProductSlugAlreadyExistsError (P2002)
- Create with invalid data → InvalidProductDataError
- Get non-existent product → ProductNotFoundError
- Get soft-deleted product (without flag) → ProductNotFoundError
- Update non-existent product → ProductNotFoundError
- Update with duplicate slug → ProductSlugAlreadyExistsError
- Update soft-deleted product → ProductNotFoundError
- Soft delete non-existent product → ProductNotFoundError
- Restore non-existent product → ProductNotFoundError
- Prisma errors other than P2002 → Re-thrown as-is

#### Mocking Strategy

**Validator Tests:**
- No mocking needed (pure functions)
- Use real InvalidProductDataError instances

**Service Tests:**
- **Mock Prisma client** completely (following productTypeService.test.ts pattern):
  ```typescript
  jest.mock('../../lib/prisma', () => ({
    __esModule: true,
    default: {
      product: {
        findUnique: jest.fn(),
        create: jest.fn(),
        update: jest.fn(),
      },
      priceHistory: {
        create: jest.fn(),
      },
      $transaction: jest.fn(),
    },
  }));
  ```
- **Mock `$transaction`** to execute callback function immediately:
  ```typescript
  (mockPrisma.$transaction as jest.Mock).mockImplementation(async (callback) => {
    return await callback(mockPrisma);
  });
  ```
- **Create realistic mock data**:
  - `mockProduct` objects with all Prisma Product fields
  - `mockPriceHistory` objects with all PriceHistory fields
- **Clear all mocks** in `beforeEach()` for test isolation

**What NOT to mock:**
- Domain errors (use real instances)
- Validator functions (integration with service tests validator behavior)

---

### Key Patterns

#### 1. DDD Layered Architecture
- **Domain errors** (`ProductError.ts`) - Already complete, no Prisma dependencies
- **Validators** (`productValidator.ts`) - Pure validation logic, no Prisma
- **Services** (`productService.ts`) - Orchestration, uses validators and Prisma
- **Flow**: Controller → Service → Validator → Prisma

#### 2. Validation Pattern (from productTypeValidator.ts)
- Input interfaces define expected structure (with optional fields)
- Validated interfaces define guaranteed structure (defaults applied)
- Private helper functions for field-specific validation
- Public functions return validated data (never mutate input)
- Throw `InvalidProductDataError` with descriptive messages and `field` parameter

#### 3. Service Pattern (from productTypeService.ts)
- Always validate input first using validator functions
- Check existence before update/delete operations
- Wrap Prisma operations in try-catch to handle P2002 (unique constraint)
- Throw domain-specific errors, not generic errors
- Use async/await consistently

#### 4. Soft Delete Pattern
- All "read" operations filter `deletedAt: null` by default
- `getProductById` accepts optional `includeSoftDeleted` flag
- `getProductBySlug` always excludes soft-deleted (public-facing)
- Soft delete sets `deletedAt = new Date()`
- Restore sets `deletedAt = null`
- No hard delete in this task

#### 5. Localized JSON Fields Pattern
- `title` and `description` are `Json` type in Prisma (stored as `{ es: "...", en: "..." }`)
- Validator checks: `es` key is required (MVP targets Spanish market - ADR-003)
- Validator checks: `en` key is optional
- Validator checks: All provided values are non-empty strings with max length

#### 6. Price History Tracking Pattern
- Only create PriceHistory entry when price actually changes
- Use Prisma `$transaction` for atomicity:
  ```typescript
  await prisma.$transaction(async (tx) => {
    const updated = await tx.product.update({ ... });
    await tx.priceHistory.create({ ... });
    return updated;
  });
  ```
- PriceHistory stores: `productId`, `price` (new price), `changedByUserId`, `reason`, `createdAt`

#### 7. Test Pattern (from productTypeService.test.ts)
- **AAA structure**: Arrange (setup mocks), Act (call function), Assert (verify behavior)
- **Describe blocks**: Group by function name, then by scenario type
- **Mock setup**: Mock entire Prisma client at module level, clear mocks in `beforeEach()`
- **Realistic data**: Create mock objects with all required fields
- **Specific assertions**: Use `toHaveBeenCalledWith()` to verify exact parameters

#### 8. Prisma Transaction Testing Pattern
- Mock `$transaction` to execute callback immediately:
  ```typescript
  (mockPrisma.$transaction as jest.Mock).mockImplementation(async (callback) => {
    return await callback(mockPrisma);
  });
  ```
- Verify both operations in transaction were called
- Test transaction rollback scenarios (e.g., second operation fails)

---

### Gotchas and Constraints

1. **Prisma Decimal Type**: `price` and `compareAtPrice` are `Decimal` in Prisma schema. Validator should accept number, but Prisma will convert to Decimal automatically.

2. **UUID vs String**: Product ID is `String @default(uuid())` in Prisma, not a dedicated UUID type. Use regex validation for UUID format.

3. **JSON Fields**: `title`, `description`, and `availableSizes` are `Json` type. Prisma accepts plain objects, but validator must ensure correct structure.

4. **Slug Uniqueness**: Slug has `@unique` constraint. Service must catch Prisma P2002 error and throw `ProductSlugAlreadyExistsError`.

5. **Soft Delete Query Pattern**: Use `{ deletedAt: null }` in where clause, NOT `{ deletedAt: { equals: null } }` (more concise).

6. **Price History on Update Only**: Do NOT create PriceHistory on initial product creation (only on price changes during updates).

7. **Transaction Return Value**: `prisma.$transaction(callback)` returns the callback's return value. Ensure callback returns the updated product.

8. **Test Isolation**: Always clear mocks in `beforeEach()` to prevent test pollution.

9. **Validator Throws, Service Catches**: Validator throws `InvalidProductDataError` → Service lets it propagate (no try-catch around validation).

10. **Reference productTypeService.ts**: Follow the exact patterns from productTypeService.ts for consistency (import order, function structure, error handling).

11. **No Repository Layer**: This project uses service layer directly with Prisma (no separate repository classes). Services import Prisma client directly.

12. **TypeScript Strict Mode**: All functions must have explicit return types. Use `Promise<Product>`, `Promise<void>`, etc.

---

### Implementation Checklist for backend-developer Agent

- [ ] Create `productValidator.ts` with all validation functions
- [ ] Create `productValidator.test.ts` with comprehensive test coverage
- [ ] Verify all validator tests pass (`npm test productValidator.test.ts`)
- [ ] Create `productService.ts` with all CRUD functions
- [ ] Create `productService.test.ts` with comprehensive test coverage
- [ ] Verify all service tests pass (`npm test productService.test.ts`)
- [ ] Verify all existing tests still pass (`npm test`)
- [ ] Verify build succeeds (`npm run build`)
- [ ] Verify no linting errors (`npm run lint`)
- [ ] Run production-code-validator agent
- [ ] Update ticket acceptance criteria (mark each item `[x]` as completed)

---

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Unit tests written and passing
- [ ] Code follows project standards (DDD, SOLID)
- [ ] No linting errors
- [ ] Build succeeds
- [ ] Production validator passed

---

*Ticket created: 2026-02-11*
